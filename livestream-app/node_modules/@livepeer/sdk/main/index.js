"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deployContract = deployContract;
exports.getContractAt = getContractAt;
exports.initRPC = initRPC;
exports.initContracts = initContracts;
exports.default = exports.LivepeerSDK = exports.createLivepeerSDK = createLivepeerSDK;
Object.defineProperty(exports, "VIDEO_PROFILES", {
  enumerable: true,
  get: function get() {
    return _video_profiles.VIDEO_PROFILES;
  }
});
exports.utils = exports.DEFAULTS = exports.TRANSCODER_STATUS = exports.DELEGATOR_STATUS = exports.VIDEO_PROFILE_ID_SIZE = exports.ADDRESS_PAD = exports.EMPTY_ADDRESS = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _ethjs = _interopRequireDefault(require("ethjs"));

var _ethjsProviderSigner = _interopRequireDefault(require("ethjs-provider-signer"));

var _ethereumjsTx = _interopRequireDefault(require("ethereumjs-tx"));

var _ethjsAbi = require("ethjs-abi");

var _ethjsEns = _interopRequireDefault(require("ethjs-ens"));

var _LivepeerToken = _interopRequireDefault(require("../etc/LivepeerToken"));

var _LivepeerTokenFaucet = _interopRequireDefault(require("../etc/LivepeerTokenFaucet"));

var _Controller = _interopRequireDefault(require("../etc/Controller"));

var _RoundsManager = _interopRequireDefault(require("../etc/RoundsManager"));

var _BondingManager = _interopRequireDefault(require("../etc/BondingManager"));

var _Minter = _interopRequireDefault(require("../etc/Minter"));

var _PollCreator = _interopRequireDefault(require("../etc/PollCreator"));

var _Poll = _interopRequireDefault(require("../etc/Poll"));

var _MerkleSnapshot = _interopRequireDefault(require("../etc/MerkleSnapshot"));

var _video_profiles = require("./video_profiles.js");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000';
exports.EMPTY_ADDRESS = EMPTY_ADDRESS;
var ADDRESS_PAD = '0x000000000000000000000000';
exports.ADDRESS_PAD = ADDRESS_PAD;
var VIDEO_PROFILE_ID_SIZE = 8;
exports.VIDEO_PROFILE_ID_SIZE = VIDEO_PROFILE_ID_SIZE;
var DELEGATOR_STATUS = ['Pending', 'Bonded', 'Unbonded', 'Unbonding'];
exports.DELEGATOR_STATUS = DELEGATOR_STATUS;
DELEGATOR_STATUS.Pending = DELEGATOR_STATUS[0];
DELEGATOR_STATUS.Bonded = DELEGATOR_STATUS[1];
DELEGATOR_STATUS.Unbonded = DELEGATOR_STATUS[2];
DELEGATOR_STATUS.Unbonding = DELEGATOR_STATUS[3];
var TRANSCODER_STATUS = ['NotRegistered', 'Registered'];
exports.TRANSCODER_STATUS = TRANSCODER_STATUS;
TRANSCODER_STATUS.NotRegistered = TRANSCODER_STATUS[0];
TRANSCODER_STATUS.Registered = TRANSCODER_STATUS[1];
// Defaults
var DEFAULTS = {
  controllerAddress: '0xf96d54e490317c557a967abfa5d6e33006be69b3',
  pollCreatorAddress: '0xbf824edb6b94d9b52d972d5b25bcc19b4e6e3f3c',
  provider: process.env.INFURA_ENDPOINT,
  privateKeys: {},
  // { [publicKey: string]: privateKey }
  account: '',
  gas: null,
  artifacts: {
    LivepeerToken: _LivepeerToken.default,
    LivepeerTokenFaucet: _LivepeerTokenFaucet.default,
    Controller: _Controller.default,
    RoundsManager: _RoundsManager.default,
    BondingManager: _BondingManager.default,
    Minter: _Minter.default,
    PollCreator: _PollCreator.default,
    Poll: _Poll.default,
    MerkleSnapshot: _MerkleSnapshot.default
  },
  ensRegistries: {
    // Mainnet
    1: '0x314159265dd8dbb310642f98f50c066173c1259b',
    // Ropsten
    3: '0x112234455c3a32fd11230c42e7bccd4a84e02010',
    // Rinkeby
    4: '0xe7410170f87102df0055eb195163a03b7f2bff4a'
  }
}; // Utils

exports.DEFAULTS = DEFAULTS;
var utils = {
  isValidAddress: function isValidAddress(x) {
    return /^0x[a-fA-F0-9]{40}$/.test(x);
  },
  resolveAddress: function () {
    var _resolveAddress = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(resolve, x) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!utils.isValidAddress(x)) {
                _context.next = 4;
                break;
              }

              _context.t0 = x;
              _context.next = 7;
              break;

            case 4:
              _context.next = 6;
              return resolve(x);

            case 6:
              _context.t0 = _context.sent;

            case 7:
              return _context.abrupt("return", _context.t0);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function resolveAddress(_x, _x2) {
      return _resolveAddress.apply(this, arguments);
    }

    return resolveAddress;
  }(),
  getMethodHash: function getMethodHash(item) {
    // const sig = `${item.name}(${item.inputs.map(x => x.type).join(',')})`
    // const hash = Eth.keccak256(sig)
    // return hash
    return (0, _ethjsAbi.encodeSignature)(item);
  },
  findAbiByName: function findAbiByName(abis, name) {
    var _abis$filter = abis.filter(function (item) {
      if (item.type !== 'function') return false;
      if (item.name === name) return true;
    }),
        _abis$filter2 = (0, _slicedToArray2.default)(_abis$filter, 1),
        abi = _abis$filter2[0];

    return abi;
  },
  findAbiByHash: function findAbiByHash(abis, hash) {
    var _abis$filter3 = abis.filter(function (item) {
      if (item.type !== 'function') return false;
      return (0, _ethjsAbi.encodeSignature)(item) === hash;
    }),
        _abis$filter4 = (0, _slicedToArray2.default)(_abis$filter3, 1),
        abi = _abis$filter4[0];

    return abi;
  },
  encodeMethodParams: function encodeMethodParams(abi, params) {
    return (0, _ethjsAbi.encodeMethod)(abi, params);
  },
  decodeMethodParams: function decodeMethodParams(abi, bytecode) {
    return (0, _ethjsAbi.decodeParams)(abi.inputs.map(function (x) {
      return x.name;
    }), abi.inputs.map(function (x) {
      return x.type;
    }), "0x".concat(bytecode.substr(10)), false);
  },
  decodeContractInput: function decodeContractInput(contracts, contractAddress, input) {
    for (var key in contracts) {
      var contract = contracts[key];
      if (contract.address !== contractAddress) continue;
      var hash = input.substring(0, 10);
      var abi = utils.findAbiByHash(contract.abi, hash);
      return {
        contract: key,
        method: abi.name,
        params: Object.entries(utils.decodeMethodParams(abi, input)).reduce(function (obj, _ref) {
          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
              k = _ref2[0],
              v = _ref2[1];

          return _objectSpread(_objectSpread({}, obj), {}, (0, _defineProperty2.default)({}, k, Array.isArray(v) ? v.map(function (_v) {
            return BN.isBN(_v) ? toString(_v) : _v;
          }) : BN.isBN(v) ? toString(v) : v));
        }, {})
      };
    }

    return {
      contract: '',
      method: '',
      params: {}
    };
  },

  /**
   * Polls for a transaction receipt
   * @ignore
   * @param {string}   txHash - the transaction hash
   * @param {Eth}      eth    - an instance of Ethjs
   * @return {Object}
   */
  getTxReceipt: function () {
    var _getTxReceipt = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(txHash, eth) {
      return _regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return new Promise(function (resolve, reject) {
                setTimeout( /*#__PURE__*/function () {
                  var _pollForReceipt = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
                    var receipt;
                    return _regenerator.default.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.prev = 0;
                            _context2.next = 3;
                            return eth.getTransactionReceipt(txHash);

                          case 3:
                            receipt = _context2.sent;

                            if (!receipt) {
                              _context2.next = 21;
                              break;
                            }

                            if (!(receipt.status === '0x1')) {
                              _context2.next = 9;
                              break;
                            }

                            _context2.t0 = // success
                            resolve(receipt);
                            _context2.next = 20;
                            break;

                          case 9:
                            _context2.t1 = reject;
                            _context2.t2 = Error;
                            _context2.t3 = JSON;
                            _context2.t4 = receipt;
                            _context2.next = 15;
                            return eth.getTransactionByHash(receipt.transactionHash);

                          case 15:
                            _context2.t5 = _context2.sent;
                            _context2.t6 = {
                              receipt: _context2.t4,
                              transaction: _context2.t5
                            };
                            _context2.t7 = _context2.t3.stringify.call(_context2.t3, _context2.t6, null, 2);
                            _context2.t8 = new _context2.t2(_context2.t7);
                            _context2.t0 = (0, _context2.t1)(_context2.t8);

                          case 20:
                            return _context2.abrupt("return", _context2.t0);

                          case 21:
                            setTimeout(pollForReceipt, 300);
                            _context2.next = 27;
                            break;

                          case 24:
                            _context2.prev = 24;
                            _context2.t9 = _context2["catch"](0);
                            reject(_context2.t9);

                          case 27:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, null, [[0, 24]]);
                  }));

                  function pollForReceipt() {
                    return _pollForReceipt.apply(this, arguments);
                  }

                  return pollForReceipt;
                }(), 0);
              });

            case 2:
              return _context3.abrupt("return", _context3.sent);

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function getTxReceipt(_x3, _x4) {
      return _getTxReceipt.apply(this, arguments);
    }

    return getTxReceipt;
  }(),

  /**
   * Parses an encoded string of transcoding options
   * @ignore
   * @param  {string} opts - transcoding options
   * @return {Object[]}
   */
  parseTranscodingOptions: function parseTranscodingOptions(opts) {
    var profiles = Object.values(_video_profiles.VIDEO_PROFILES);
    var validHashes = new Set(profiles.map(function (x) {
      return x.hash;
    }));
    var hashes = [];

    for (var i = 0; i < opts.length; i += VIDEO_PROFILE_ID_SIZE) {
      var hash = opts.slice(i, i + VIDEO_PROFILE_ID_SIZE);
      if (!validHashes.has(hash)) continue;
      hashes.push(hash);
    }

    return hashes.map(function (x) {
      return profiles.find(function (_ref3) {
        var hash = _ref3.hash;
        return x === hash;
      });
    });
  },

  /**
   * Serializes a list of transcoding profiles name into a hash
   * @ignore
   * @param  {string[]} name - transcoding profile name
   * @return {string}
   */
  serializeTranscodingProfiles: function serializeTranscodingProfiles(names) {
    return (0, _toConsumableArray2.default)(new Set( // dedupe profiles
    names.map(function (x) {
      return _video_profiles.VIDEO_PROFILES[x] ? _video_profiles.VIDEO_PROFILES[x].hash : _video_profiles.VIDEO_PROFILES.P240p30fps4x3.hash;
    }))).join('');
  },

  /**
   * Pads an address with 0s on the left (for topic encoding)
   * @ignore
   * @param  {string} addr - an ETH address
   * @return {string}
   */
  padAddress: function padAddress(addr) {
    return ADDRESS_PAD + addr.substr(2);
  },

  /**
   * Encodes an event filter object into a topic list
   * @ignore
   * @param  {Function} event   - a contract event method
   * @param  {Object}   filters - key/value map of indexed event params
   * @return {string[]}
   */
  encodeEventTopics: function encodeEventTopics(event, filters) {
    return event.abi.inputs.reduce(function (topics, _ref4, i) {
      var indexed = _ref4.indexed,
          name = _ref4.name,
          type = _ref4.type;
      if (!indexed) return topics;
      if (!filters.hasOwnProperty(name)) return [].concat((0, _toConsumableArray2.default)(topics), [null]);
      if (type === 'address' && 'string' === typeof filters[name]) return [].concat((0, _toConsumableArray2.default)(topics), [utils.padAddress(filters[name])]);
      return [].concat((0, _toConsumableArray2.default)(topics), [filters[name]]);
    }, [event().options.defaultFilterObject.topics[0]]);
  },

  /**
   * Turns a raw event log into a result object
   * @ignore
   * @param  {Function} event  - a contract event method
   * @param  {string}   data   - bytecode from log
   * @param  {string[]} topics - list of topics for log query
   * @return {Object}
   */
  decodeEvent: function decodeEvent(event) {
    return function (_ref5) {
      var data = _ref5.data,
          topics = _ref5.topics;
      return (0, _ethjsAbi.decodeEvent)(event.abi, data, topics, false);
    };
  }
}; // Helper functions
// ethjs returns a Result type from rpc requests
// these functions help with formatting those values

exports.utils = utils;
var BN = _ethjs.default.BN;

var toBN = function toBN(n) {
  return BN.isBN(n) ? n : new BN(n.toString(10), 10);
};

var compose = function compose() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return fns.reduce(function (f, g) {
    return function () {
      return f(g.apply(void 0, arguments));
    };
  });
};

var prop = function prop(k) {
  return function (x) {
    return x[k];
  };
};

var toBool = function toBool(x) {
  return !!x;
};

var toString = function toString(x) {
  return x.toString(10);
};

var toNumber = function toNumber(x) {
  return Number(x.toString(10));
};

var headToBool = compose(toBool, prop(0));
var headToString = compose(toString, prop(0));
var headToNumber = compose(toNumber, prop(0));

var invariant = function invariant(name, pos, type) {
  throw new Error("Missing argument \"".concat(name, "\" (").concat(type, ") at position ").concat(pos));
};

var formatDuration = function formatDuration(ms) {
  var seconds = (ms / 1000).toFixed(1);
  var minutes = (ms / (1000 * 60)).toFixed(1);
  var hours = (ms / (1000 * 60 * 60)).toFixed(1);
  var days = (ms / (1000 * 60 * 60 * 24)).toFixed(1);
  if (seconds < 60) return seconds + ' sec';else if (minutes < 60) return minutes + ' min';else if (hours < 24) return hours + ' hours';
  return days + ' days';
};
/**
 * Deploys contract and return instance at deployed address
 * @ignore
 * @param {*} eth
 * @param {*} args
 */


function deployContract(_x5, _x6) {
  return _deployContract.apply(this, arguments);
}
/**
 * Creates a contract instance from a specific address
 * @ignore
 * @param {Eth}    eth     - ethjs instance
 * @param {string} address -
 * @param {Object} args[0] - an object containing all relevant Livepeer Artifacts
 */


function _deployContract() {
  _deployContract = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(eth, _ref6) {
    var abi, bytecode, defaultTx, contract, txHash, receipt;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            abi = _ref6.abi, bytecode = _ref6.bytecode, defaultTx = _ref6.defaultTx;
            contract = eth.contract(abi, bytecode, defaultTx);
            _context4.next = 4;
            return contract.new();

          case 4:
            txHash = _context4.sent;
            _context4.next = 7;
            return eth.getTransactionSuccess(txHash);

          case 7:
            receipt = _context4.sent;
            return _context4.abrupt("return", contract.at(receipt.contractAddress));

          case 9:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _deployContract.apply(this, arguments);
}

function getContractAt(eth, _ref7) {
  var abi = _ref7.abi,
      bytecode = _ref7.bytecode,
      address = _ref7.address,
      defaultTx = _ref7.defaultTx;
  return eth.contract(abi, bytecode, defaultTx).at(address);
}
/**
 * Creates an instance of Eth and a default transaction object
 * @ignore
 * @return {{ et, gas: Eth, defaultTx: { from: string, gas: number } }}
 */


function initRPC(_x7) {
  return _initRPC.apply(this, arguments);
}
/**
 * Creates instances of all main Livepeer contracts
 * @ignore
 * @param {string} opts.provider  - the httpProvider for contract RPC
 * @param {Object} opts.artifacts - ...
 */


function _initRPC() {
  _initRPC = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(_ref8) {
    var account, privateKeys, gas, provider, usePrivateKeys, ethjsProvider, eth, ens, _accounts, from;

    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            account = _ref8.account, privateKeys = _ref8.privateKeys, gas = _ref8.gas, provider = _ref8.provider;
            usePrivateKeys = 0 < Object.keys(privateKeys).length;
            ethjsProvider = 'object' === (0, _typeof2.default)(provider) && provider ? provider : usePrivateKeys ? // Use provider-signer to locally sign transactions
            new _ethjsProviderSigner.default(provider, {
              signTransaction: function signTransaction(rawTx, cb) {
                var tx = new _ethereumjsTx.default(rawTx);
                tx.sign(privateKeys[from]);
                cb(null, '0x' + tx.serialize().toString('hex'));
              },
              accounts: function accounts(cb) {
                return cb(null, _accounts);
              },
              timeout: 10 * 1000
            }) : // Use default signer
            new _ethjs.default.HttpProvider(provider || DEFAULTS.provider);
            eth = new _ethjs.default(ethjsProvider);
            _context5.t0 = _ethjsEns.default;
            _context5.t1 = eth.currentProvider;
            _context5.next = 8;
            return eth.net_version();

          case 8:
            _context5.t2 = _context5.sent;
            _context5.t3 = DEFAULTS.ensRegistries[_context5.t2];
            _context5.t4 = {
              provider: _context5.t1,
              registryAddress: _context5.t3
            };
            ens = new _context5.t0(_context5.t4);

            if (!usePrivateKeys) {
              _context5.next = 16;
              break;
            }

            _context5.t5 = Object.keys(privateKeys);
            _context5.next = 19;
            break;

          case 16:
            _context5.next = 18;
            return eth.accounts();

          case 18:
            _context5.t5 = _context5.sent;

          case 19:
            _accounts = _context5.t5;
            from = // select account by address or index
            // default to EMPTY_ADDRESS (read-only; cannot transact)
            new Set(_accounts).has(account) ? account : _accounts[account] || EMPTY_ADDRESS;
            return _context5.abrupt("return", {
              eth: eth,
              ens: ens,
              provider: provider,
              accounts: _accounts,
              defaultTx: {
                from: from,
                gas: gas
              }
            });

          case 22:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _initRPC.apply(this, arguments);
}

function initContracts() {
  return _initContracts.apply(this, arguments);
}
/**
 * Livepeer SDK main module exports
 * @namespace module~exports
 */

/**
 * Livepeer SDK factory function. Creates an instance of the Livepeer SDK -- an object with useful methods for interacting with Livepeer protocol smart contracts
 * @memberof module~exports
 * @name default
 * @param {LivepeerSDKOptions} opts - SDK configuration options
 * @return {Promise<LivepeerSDK>}
 *
 * @example
 *
 * // Here we're naming the default export "LivepeerSDK"
 * import LivepeerSDK from '@livepeer/sdk'
 *
 * // Call the factory function and await its Promise
 * LivepeerSDK().then(sdk => {
 *   // Your Livepeer SDK instance is now ready to use
 * })
 *
 */


function _initContracts() {
  _initContracts = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
    var opts,
        _opts$account,
        account,
        _opts$artifacts,
        artifacts,
        _opts$controllerAddre,
        controllerAddress,
        _opts$pollCreatorAddr,
        pollCreatorAddress,
        _opts$gas,
        gas,
        _opts$privateKeys,
        privateKeys,
        _opts$provider,
        provider,
        _yield$initRPC,
        accounts,
        defaultTx,
        ens,
        eth,
        contracts,
        hashes,
        Controller,
        PollCreator,
        Poll,
        _i,
        _Object$keys,
        name,
        hash,
        address,
        _iterator,
        _step,
        item,
        abis,
        events,
        _args6 = arguments;

    return _regenerator.default.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            opts = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {};
            // Merge pass options with defaults
            _opts$account = opts.account, account = _opts$account === void 0 ? DEFAULTS.account : _opts$account, _opts$artifacts = opts.artifacts, artifacts = _opts$artifacts === void 0 ? DEFAULTS.artifacts : _opts$artifacts, _opts$controllerAddre = opts.controllerAddress, controllerAddress = _opts$controllerAddre === void 0 ? DEFAULTS.controllerAddress : _opts$controllerAddre, _opts$pollCreatorAddr = opts.pollCreatorAddress, pollCreatorAddress = _opts$pollCreatorAddr === void 0 ? DEFAULTS.pollCreatorAddress : _opts$pollCreatorAddr, _opts$gas = opts.gas, gas = _opts$gas === void 0 ? DEFAULTS.gas : _opts$gas, _opts$privateKeys = opts.privateKeys, privateKeys = _opts$privateKeys === void 0 ? DEFAULTS.privateKeys : _opts$privateKeys, _opts$provider = opts.provider, provider = _opts$provider === void 0 ? DEFAULTS.provider : _opts$provider; // Instanstiate new ethjs instance with specified provider

            _context6.next = 4;
            return initRPC({
              account: account,
              gas: gas,
              privateKeys: privateKeys,
              provider: provider
            });

          case 4:
            _yield$initRPC = _context6.sent;
            accounts = _yield$initRPC.accounts;
            defaultTx = _yield$initRPC.defaultTx;
            ens = _yield$initRPC.ens;
            eth = _yield$initRPC.eth;
            contracts = {
              LivepeerToken: null,
              LivepeerTokenFaucet: null,
              BondingManager: null,
              RoundsManager: null,
              Minter: null,
              MerkleSnapshot: null
            };
            hashes = {
              LivepeerToken: {},
              LivepeerTokenFaucet: {},
              BondingManager: {},
              RoundsManager: {},
              Minter: {},
              MerkleSnapshot: {}
            }; // Create a Controller contract instance

            _context6.next = 13;
            return getContractAt(eth, _objectSpread(_objectSpread({}, artifacts.Controller), {}, {
              defaultTx: defaultTx,
              address: controllerAddress
            }));

          case 13:
            Controller = _context6.sent;
            _context6.next = 16;
            return getContractAt(eth, _objectSpread(_objectSpread({}, artifacts.PollCreator), {}, {
              defaultTx: defaultTx,
              address: pollCreatorAddress
            }));

          case 16:
            PollCreator = _context6.sent;
            _context6.next = 19;
            return getContractAt(eth, _objectSpread(_objectSpread({}, artifacts.Poll), {}, {
              defaultTx: defaultTx,
              address: EMPTY_ADDRESS
            }));

          case 19:
            Poll = _context6.sent;
            _i = 0, _Object$keys = Object.keys(contracts);

          case 21:
            if (!(_i < _Object$keys.length)) {
              _context6.next = 35;
              break;
            }

            name = _Object$keys[_i];
            // Get contract address from Controller
            hash = _ethjs.default.keccak256(name);
            _context6.next = 26;
            return Controller.getContract(hash);

          case 26:
            address = _context6.sent[0];
            _context6.next = 29;
            return getContractAt(eth, _objectSpread(_objectSpread({}, artifacts[name]), {}, {
              defaultTx: defaultTx,
              address: address
            }));

          case 29:
            contracts[name] = _context6.sent;
            _iterator = _createForOfIteratorHelper(contracts[name].abi);

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                item = _step.value;
                hashes[name][utils.getMethodHash(item)] = item.name;
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

          case 32:
            _i++;
            _context6.next = 21;
            break;

          case 35:
            // Add the Controller contract to the contracts object
            contracts.Controller = Controller; // Add the PollCreator contract to the contracts object

            contracts.PollCreator = PollCreator; // Add the PollCreator contract to the contracts object

            contracts.Poll = Poll; // Key ABIs by contract name

            abis = Object.entries(artifacts).map(function (_ref9) {
              var _ref10 = (0, _slicedToArray2.default)(_ref9, 2),
                  k = _ref10[0],
                  v = _ref10[1];

              return (0, _defineProperty2.default)({}, k, v.abi);
            }).reduce(function (a, b) {
              return _objectSpread(_objectSpread({}, a), b);
            }, {}); // Create a list of events in each contract

            events = Object.entries(abis).map(function (_ref12) {
              var _ref13 = (0, _slicedToArray2.default)(_ref12, 2),
                  contract = _ref13[0],
                  abi = _ref13[1];

              return abi.filter(function (x) {
                return x.type === 'event';
              }).map(function (abi) {
                return {
                  abi: abi,
                  contract: contract,
                  event: contracts[contract][abi.name],
                  name: abi.name
                };
              });
            }).reduce(function (a, b) {
              return b.reduce(function (events, _ref14) {
                var name = _ref14.name,
                    event = _ref14.event,
                    abi = _ref14.abi,
                    contract = _ref14.contract;
                event.abi = abi;
                event.contract = contract;
                return _objectSpread(_objectSpread({}, events), {}, (0, _defineProperty2.default)({}, name, event));
              }, a);
            }, {});
            return _context6.abrupt("return", {
              abis: abis,
              accounts: accounts,
              contracts: contracts,
              defaultTx: defaultTx,
              ens: ens,
              eth: eth,
              events: events,
              hashes: hashes
            });

          case 41:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _initContracts.apply(this, arguments);
}

function createLivepeerSDK(_x8) {
  return _createLivepeerSDK.apply(this, arguments);
}

function _createLivepeerSDK() {
  _createLivepeerSDK = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee73(opts) {
    var _yield$initContracts, ens, events, config, _config$contracts, BondingManager, Controller, LivepeerToken, LivepeerTokenFaucet, RoundsManager, Minter, PollCreator, MerkleSnapshot, resolveAddress, cache, rpc;

    return _regenerator.default.wrap(function _callee73$(_context73) {
      while (1) {
        switch (_context73.prev = _context73.next) {
          case 0:
            _context73.next = 2;
            return initContracts(opts);

          case 2:
            _yield$initContracts = _context73.sent;
            ens = _yield$initContracts.ens;
            events = _yield$initContracts.events;
            config = (0, _objectWithoutProperties2.default)(_yield$initContracts, ["ens", "events"]);
            _config$contracts = config.contracts, BondingManager = _config$contracts.BondingManager, Controller = _config$contracts.Controller, LivepeerToken = _config$contracts.LivepeerToken, LivepeerTokenFaucet = _config$contracts.LivepeerTokenFaucet, RoundsManager = _config$contracts.RoundsManager, Minter = _config$contracts.Minter, PollCreator = _config$contracts.PollCreator, MerkleSnapshot = _config$contracts.MerkleSnapshot;
            resolveAddress = utils.resolveAddress; // Cache

            cache = {// previous log queries are held here to improve perf
            };
            /**
             * "rpc" namespace of a Livepeer SDK instance
             * @namespace livepeer~rpc
             *
             * @example
             *
             * import LivepeerSDK from '@livepeer/sdk'
             *
             * LivepeerSDK().then(({ rpc }) => {
             *   // Here, we're destructuring the sdk to expose only its rpc namespace
             *   // Now, you you are able call rpc.<method-name>()
             *   // All rpc method yield Promises. Their usage is further explained below.
             * })
             *
             */

            rpc = {
              /**
               * Gets the ENS name for an address. This is known as a reverse lookup.
               * Unfortunately, users must explicitly set their own resolver.
               * So most of the time, this method just returns an empty string
               * More info here:
               * (https://docs.ens.domains/en/latest/userguide.html#reverse-name-resolution)
               * @memberof livepeer~rpc
               * @param {string} address - address to look up an ENS name for
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getENSName('0xd34db33f...')
               * // => string
               */
              getENSName: function getENSName(address) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
                  return _regenerator.default.wrap(function _callee7$(_context7) {
                    while (1) {
                      switch (_context7.prev = _context7.next) {
                        case 0:
                          _context7.prev = 0;
                          _context7.next = 3;
                          return ens.reverse(address);

                        case 3:
                          return _context7.abrupt("return", _context7.sent);

                        case 6:
                          _context7.prev = 6;
                          _context7.t0 = _context7["catch"](0);

                          // custom networks or unavailable resolvers can cause failure
                          if (_context7.t0.message !== 'ENS name not defined.') {
                            console.warn("Could not get ENS name for address \"".concat(address, "\":"), _context7.t0.message);
                          } // if there's no name, we can just resolve an empty string


                          return _context7.abrupt("return", '');

                        case 10:
                        case "end":
                          return _context7.stop();
                      }
                    }
                  }, _callee7, null, [[0, 6]]);
                }))();
              },

              /**
               * Gets the address for an ENS name
               * @memberof livepeer~rpc
               * @param {string} name - ENS name to look up an address for
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getENSAddress('vitalik.eth')
               * // => string
               */
              getENSAddress: function getENSAddress(name) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
                  return _regenerator.default.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          _context8.prev = 0;
                          _context8.next = 3;
                          return ens.lookup(name);

                        case 3:
                          return _context8.abrupt("return", _context8.sent);

                        case 6:
                          _context8.prev = 6;
                          _context8.t0 = _context8["catch"](0);

                          // custom networks or unavailable resolvers can cause failure
                          if (_context8.t0.message !== 'ENS name not defined.') {
                            console.warn("Could not get address for ENS name \"".concat(name, "\":"), _context8.t0.message);
                          } // if there's no name, we can just resolve an empty string


                          return _context8.abrupt("return", '');

                        case 10:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8, null, [[0, 6]]);
                }))();
              },

              /**
               * Gets a block by number, hash, or keyword ('earliest' | 'latest')
               * @memberof livepeer~rpc
               * @param {string} block - Number of block to get
               *
               * @example
               *
               * await rpc.getBlock('latest')
               * // => {
               *   "number": string,
               *   "hash": string,
               *   "parentHash": string,
               *   "nonce": string,
               *   "sha3Uncles": string,
               *   "logsBloom": string,
               *   "transactionsRoot": string,
               *   "stateRoot": string,
               *   "receiptsRoot": string,
               *   "miner": string,
               *   "mixHash": string,
               *   "difficulty": string,
               *   "totalDifficulty": string,
               *   "extraData": string,
               *   "size": string,
               *   "gasLimit": string,
               *   "gasUsed": string,
               *   "timestamp": number,
               *   "transactions": Array<Transaction>,
               *   "transactionsRoot": string,
               *   "uncles": Array<Uncle>,
               * }
               */
              getBlock: function getBlock(id) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
                  var block;
                  return _regenerator.default.wrap(function _callee9$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          if (!id.toString().startsWith('0x')) {
                            _context9.next = 6;
                            break;
                          }

                          _context9.next = 3;
                          return config.eth.getBlockByHash(id, true);

                        case 3:
                          _context9.t0 = _context9.sent;
                          _context9.next = 9;
                          break;

                        case 6:
                          _context9.next = 8;
                          return config.eth.getBlockByNumber(id, true);

                        case 8:
                          _context9.t0 = _context9.sent;

                        case 9:
                          block = _context9.t0;
                          return _context9.abrupt("return", _objectSpread(_objectSpread({}, block), {}, {
                            difficulty: toString(block.difficulty),
                            gasLimit: toString(block.gasLimit),
                            gasUsed: toString(block.gasUsed),
                            number: toString(block.number),
                            size: toString(block.size),
                            timestamp: Number(toString(block.timestamp)),
                            totalDifficulty: toString(block.totalDifficulty)
                          }));

                        case 11:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  }, _callee9);
                }))();
              },

              /**
               * Gets the ETH balance for an account
               * @memberof livepeer~rpc
               * @param {string} addr - ETH account address
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getEthBalance('0xf00...')
               * // => string
               *
               */
              getEthBalance: function getEthBalance(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
                  return _regenerator.default.wrap(function _callee10$(_context10) {
                    while (1) {
                      switch (_context10.prev = _context10.next) {
                        case 0:
                          _context10.t0 = toString;
                          _context10.t1 = config.eth;
                          _context10.next = 4;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 4:
                          _context10.t2 = _context10.sent;
                          _context10.next = 7;
                          return _context10.t1.getBalance.call(_context10.t1, _context10.t2);

                        case 7:
                          _context10.t3 = _context10.sent;
                          return _context10.abrupt("return", (0, _context10.t0)(_context10.t3));

                        case 9:
                        case "end":
                          return _context10.stop();
                      }
                    }
                  }, _callee10);
                }))();
              },

              /**
               * Gets the unbonding period for transcoders
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getUnbondingPeriod()
               * // => string
               */
              getUnbondingPeriod: function getUnbondingPeriod() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
                  return _regenerator.default.wrap(function _callee11$(_context11) {
                    while (1) {
                      switch (_context11.prev = _context11.next) {
                        case 0:
                          _context11.t0 = headToString;
                          _context11.next = 3;
                          return BondingManager.unbondingPeriod();

                        case 3:
                          _context11.t1 = _context11.sent;
                          return _context11.abrupt("return", (0, _context11.t0)(_context11.t1));

                        case 5:
                        case "end":
                          return _context11.stop();
                      }
                    }
                  }, _callee11);
                }))();
              },

              /**
               * Gets the number of active transcoders
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getNumActiveTranscoders()
               * // => string
               */
              getNumActiveTranscoders: function getNumActiveTranscoders() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
                  return _regenerator.default.wrap(function _callee12$(_context12) {
                    while (1) {
                      switch (_context12.prev = _context12.next) {
                        case 0:
                          _context12.t0 = headToString;
                          _context12.next = 3;
                          return BondingManager.numActiveTranscoders();

                        case 3:
                          _context12.t1 = _context12.sent;
                          return _context12.abrupt("return", (0, _context12.t0)(_context12.t1));

                        case 5:
                        case "end":
                          return _context12.stop();
                      }
                    }
                  }, _callee12);
                }))();
              },

              /**
               * Gets the maximum earnings for claims rounds
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getMaxEarningsClaimsRounds()
               * // => string
               */
              getMaxEarningsClaimsRounds: function getMaxEarningsClaimsRounds() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
                  return _regenerator.default.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          _context13.t0 = headToString;
                          _context13.next = 3;
                          return BondingManager.maxEarningsClaimsRounds();

                        case 3:
                          _context13.t1 = _context13.sent;
                          return _context13.abrupt("return", (0, _context13.t0)(_context13.t1));

                        case 5:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13);
                }))();
              },

              /**
               * Gets the total amount of bonded tokens
               * @memberof livepeer~rpc
               * @return {Promise<string}
               *
               * @example
               *
               * await rpc.getTotalBonded()
               * // => string
               */
              getTotalBonded: function getTotalBonded() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
                  return _regenerator.default.wrap(function _callee14$(_context14) {
                    while (1) {
                      switch (_context14.prev = _context14.next) {
                        case 0:
                          _context14.t0 = headToString;
                          _context14.next = 3;
                          return BondingManager.getTotalBonded();

                        case 3:
                          _context14.t1 = _context14.sent;
                          return _context14.abrupt("return", (0, _context14.t0)(_context14.t1));

                        case 5:
                        case "end":
                          return _context14.stop();
                      }
                    }
                  }, _callee14);
                }))();
              },

              /**
               * Gets the total supply of token (LTPU) available in the protocol
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getTokenTotalSupply()
               * // => string
               */
              getTokenTotalSupply: function getTokenTotalSupply() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15() {
                  return _regenerator.default.wrap(function _callee15$(_context15) {
                    while (1) {
                      switch (_context15.prev = _context15.next) {
                        case 0:
                          _context15.t0 = headToString;
                          _context15.next = 3;
                          return LivepeerToken.totalSupply();

                        case 3:
                          _context15.t1 = _context15.sent;
                          return _context15.abrupt("return", (0, _context15.t0)(_context15.t1));

                        case 5:
                        case "end":
                          return _context15.stop();
                      }
                    }
                  }, _callee15);
                }))();
              },

              /**
               * Gets a user's token balance (LPTU)
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getTokenBalance('0xf00...')
               * // => string
               */
              getTokenBalance: function getTokenBalance(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16() {
                  return _regenerator.default.wrap(function _callee16$(_context16) {
                    while (1) {
                      switch (_context16.prev = _context16.next) {
                        case 0:
                          _context16.t0 = headToString;
                          _context16.t1 = LivepeerToken;
                          _context16.next = 4;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 4:
                          _context16.t2 = _context16.sent;
                          _context16.next = 7;
                          return _context16.t1.balanceOf.call(_context16.t1, _context16.t2);

                        case 7:
                          _context16.t3 = _context16.sent;
                          return _context16.abrupt("return", (0, _context16.t0)(_context16.t3));

                        case 9:
                        case "end":
                          return _context16.stop();
                      }
                    }
                  }, _callee16);
                }))();
              },

              /**
               * Gets general information about tokens
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<TokenInfo>}
               *
               * @example
               *
               * await rpc.getTokenInfo()
               * // => TokenInfo { totalSupply: string, balance: string }
               */
              getTokenInfo: function getTokenInfo(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17() {
                  return _regenerator.default.wrap(function _callee17$(_context17) {
                    while (1) {
                      switch (_context17.prev = _context17.next) {
                        case 0:
                          _context17.next = 2;
                          return rpc.getTokenTotalSupply();

                        case 2:
                          _context17.t0 = _context17.sent;
                          _context17.t1 = rpc;
                          _context17.next = 6;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 6:
                          _context17.t2 = _context17.sent;
                          _context17.next = 9;
                          return _context17.t1.getTokenBalance.call(_context17.t1, _context17.t2);

                        case 9:
                          _context17.t3 = _context17.sent;
                          return _context17.abrupt("return", {
                            totalSupply: _context17.t0,
                            balance: _context17.t3
                          });

                        case 11:
                        case "end":
                          return _context17.stop();
                      }
                    }
                  }, _callee17);
                }))();
              },

              /**
               * Transfers tokens (LPTU) from one account to another
               * @memberof livepeer~rpc
               * @param {string} to - the account ETH address to send tokens to
               * @param {string} amount - the amount of token to send (LPTU)
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.transferToken('0xf00...', '10')
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              transferToken: function transferToken(to, amount) {
                var _arguments = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18() {
                  var tx, value, balance;
                  return _regenerator.default.wrap(function _callee18$(_context18) {
                    while (1) {
                      switch (_context18.prev = _context18.next) {
                        case 0:
                          tx = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : config.defaultTx;
                          value = toBN(amount); // make sure balance is higher than transfer

                          _context18.next = 4;
                          return LivepeerToken.balanceOf(tx.from);

                        case 4:
                          balance = _context18.sent[0];

                          if (balance.gte(value)) {
                            _context18.next = 7;
                            break;
                          }

                          throw new Error("Cannot transfer ".concat(toString(value), " LPT because is it greater than your current balance (").concat(balance, " LPT)."));

                        case 7:
                          _context18.t0 = utils;
                          _context18.t1 = LivepeerToken;
                          _context18.next = 11;
                          return resolveAddress(rpc.getENSAddress, to);

                        case 11:
                          _context18.t2 = _context18.sent;
                          _context18.t3 = value;
                          _context18.t4 = tx;
                          _context18.next = 16;
                          return _context18.t1.transfer.call(_context18.t1, _context18.t2, _context18.t3, _context18.t4);

                        case 16:
                          _context18.t5 = _context18.sent;
                          _context18.t6 = config.eth;
                          _context18.next = 20;
                          return _context18.t0.getTxReceipt.call(_context18.t0, _context18.t5, _context18.t6);

                        case 20:
                          return _context18.abrupt("return", _context18.sent);

                        case 21:
                        case "end":
                          return _context18.stop();
                      }
                    }
                  }, _callee18);
                }))();
              },

              /**
               * The amount of LPT the faucet distributes when tapped
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getFaucetAmount()
               * // => string
               */
              getFaucetAmount: function getFaucetAmount() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19() {
                  return _regenerator.default.wrap(function _callee19$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          _context19.t0 = headToString;
                          _context19.next = 3;
                          return LivepeerTokenFaucet.requestAmount();

                        case 3:
                          _context19.t1 = _context19.sent;
                          return _context19.abrupt("return", (0, _context19.t0)(_context19.t1));

                        case 5:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  }, _callee19);
                }))();
              },

              /**
               * How often an address can tap the faucet (in hours)
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getFaucetWait()
               * // => string
               */
              getFaucetWait: function getFaucetWait() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee20() {
                  return _regenerator.default.wrap(function _callee20$(_context20) {
                    while (1) {
                      switch (_context20.prev = _context20.next) {
                        case 0:
                          _context20.t0 = headToString;
                          _context20.next = 3;
                          return LivepeerTokenFaucet.requestWait();

                        case 3:
                          _context20.t1 = _context20.sent;
                          return _context20.abrupt("return", (0, _context20.t0)(_context20.t1));

                        case 5:
                        case "end":
                          return _context20.stop();
                      }
                    }
                  }, _callee20);
                }))();
              },

              /**
               * Next timestamp at which the given address will be allowed to tap the faucet
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getFaucetNext()
               * // => string
               */
              getFaucetNext: function getFaucetNext(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee21() {
                  return _regenerator.default.wrap(function _callee21$(_context21) {
                    while (1) {
                      switch (_context21.prev = _context21.next) {
                        case 0:
                          _context21.t0 = headToString;
                          _context21.t1 = LivepeerTokenFaucet;
                          _context21.next = 4;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 4:
                          _context21.t2 = _context21.sent;
                          _context21.next = 7;
                          return _context21.t1.nextValidRequest.call(_context21.t1, _context21.t2);

                        case 7:
                          _context21.t3 = _context21.sent;
                          return _context21.abrupt("return", (0, _context21.t0)(_context21.t3));

                        case 9:
                        case "end":
                          return _context21.stop();
                      }
                    }
                  }, _callee21);
                }))();
              },

              /**
               * Info about the state of the LPT faucet
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<FaucetInfo>}
               *
               * @example
               *
               * await rpc.getFaucetInfo('0xf00...')
               * // => FaucetInfo {
               * //   amount: string,
               * //   wait: string,
               * //   next: string,
               * // }
               */
              getFaucetInfo: function getFaucetInfo(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee22() {
                  return _regenerator.default.wrap(function _callee22$(_context22) {
                    while (1) {
                      switch (_context22.prev = _context22.next) {
                        case 0:
                          _context22.next = 2;
                          return rpc.getFaucetAmount();

                        case 2:
                          _context22.t0 = _context22.sent;
                          _context22.next = 5;
                          return rpc.getFaucetWait();

                        case 5:
                          _context22.t1 = _context22.sent;
                          _context22.t2 = rpc;
                          _context22.next = 9;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 9:
                          _context22.t3 = _context22.sent;
                          _context22.next = 12;
                          return _context22.t2.getFaucetNext.call(_context22.t2, _context22.t3);

                        case 12:
                          _context22.t4 = _context22.sent;
                          return _context22.abrupt("return", {
                            amount: _context22.t0,
                            wait: _context22.t1,
                            next: _context22.t4
                          });

                        case 14:
                        case "end":
                          return _context22.stop();
                      }
                    }
                  }, _callee22);
                }))();
              },

              /**
               * Gets the per round inflation rate
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getInflation()
               * // => string
               */
              getInflation: function getInflation() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee23() {
                  return _regenerator.default.wrap(function _callee23$(_context23) {
                    while (1) {
                      switch (_context23.prev = _context23.next) {
                        case 0:
                          _context23.t0 = headToString;
                          _context23.next = 3;
                          return Minter.inflation();

                        case 3:
                          _context23.t1 = _context23.sent;
                          return _context23.abrupt("return", (0, _context23.t0)(_context23.t1));

                        case 5:
                        case "end":
                          return _context23.stop();
                      }
                    }
                  }, _callee23);
                }))();
              },

              /**
               * Gets the change in inflation rate per round until the target bonding rate is achieved
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getInflationChange()
               * // => string
               */
              getInflationChange: function getInflationChange() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee24() {
                  return _regenerator.default.wrap(function _callee24$(_context24) {
                    while (1) {
                      switch (_context24.prev = _context24.next) {
                        case 0:
                          _context24.t0 = headToString;
                          _context24.next = 3;
                          return Minter.inflationChange();

                        case 3:
                          _context24.t1 = _context24.sent;
                          return _context24.abrupt("return", (0, _context24.t0)(_context24.t1));

                        case 5:
                        case "end":
                          return _context24.stop();
                      }
                    }
                  }, _callee24);
                }))();
              },

              /**
               * The delegator status of the given address
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getDelegatorStatus('0xf00...')
               * // => 'Pending' | 'Bonded' | 'Unbonded'
               */
              getDelegatorStatus: function getDelegatorStatus(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee25() {
                  var status;
                  return _regenerator.default.wrap(function _callee25$(_context25) {
                    while (1) {
                      switch (_context25.prev = _context25.next) {
                        case 0:
                          _context25.t0 = headToString;
                          _context25.t1 = BondingManager;
                          _context25.next = 4;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 4:
                          _context25.t2 = _context25.sent;
                          _context25.next = 7;
                          return _context25.t1.delegatorStatus.call(_context25.t1, _context25.t2);

                        case 7:
                          _context25.t3 = _context25.sent;
                          status = (0, _context25.t0)(_context25.t3);
                          return _context25.abrupt("return", DELEGATOR_STATUS[status]);

                        case 10:
                        case "end":
                          return _context25.stop();
                      }
                    }
                  }, _callee25);
                }))();
              },

              /**
               * General info about a delegator
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<Delegator>}
               *
               * @example
               *
               * await rpc.getDelegator('0xf00...')
               * // => Delegator {
               * //   allowance: string,
               * //   address: string,
               * //   bondedAmount: string,
               * //   delegateAddress: string,
               * //   delegateAmount: string,
               * //   fees: string,
               * //   lastClaimRound: string,
               * //   pendingFees: string,
               * //   pendingStake: string,
               * //   startRound: string,
               * //   status: 'Pending' | 'Bonded' | 'Unbonding' | 'Unbonded',
               * //   withdrawRound: string,
               * //   nextUnbondingLockId: string,
               * // }
               */
              getDelegator: function getDelegator(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee26() {
                  var address, allowance, pollCreatorAllowance, currentRound, pendingStake, pendingFees, d, bondedAmount, fees, delegateAddress, delegatedAmount, lastClaimRound, startRound, nextUnbondingLockId, unbondingLockId, _yield$rpc$getDelegat, withdrawAmount, withdrawRound, status;

                  return _regenerator.default.wrap(function _callee26$(_context26) {
                    while (1) {
                      switch (_context26.prev = _context26.next) {
                        case 0:
                          _context26.next = 2;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 2:
                          address = _context26.sent;
                          _context26.t0 = headToString;
                          _context26.next = 6;
                          return LivepeerToken.allowance(address, BondingManager.address);

                        case 6:
                          _context26.t1 = _context26.sent;
                          allowance = (0, _context26.t0)(_context26.t1);
                          _context26.t2 = headToString;
                          _context26.next = 11;
                          return LivepeerToken.allowance(address, PollCreator.address);

                        case 11:
                          _context26.t3 = _context26.sent;
                          pollCreatorAllowance = (0, _context26.t2)(_context26.t3);
                          _context26.next = 15;
                          return rpc.getCurrentRound();

                        case 15:
                          currentRound = _context26.sent;
                          _context26.t4 = headToString;
                          _context26.next = 19;
                          return BondingManager.pendingStake(address, currentRound);

                        case 19:
                          _context26.t5 = _context26.sent;
                          pendingStake = (0, _context26.t4)(_context26.t5);
                          _context26.t6 = headToString;
                          _context26.next = 24;
                          return BondingManager.pendingFees(address, currentRound);

                        case 24:
                          _context26.t7 = _context26.sent;
                          pendingFees = (0, _context26.t6)(_context26.t7);
                          _context26.next = 28;
                          return BondingManager.getDelegator(address);

                        case 28:
                          d = _context26.sent;
                          bondedAmount = toString(d.bondedAmount);
                          fees = toString(d.fees);
                          delegateAddress = d.delegateAddress === EMPTY_ADDRESS ? '' : d.delegateAddress;
                          delegatedAmount = toString(d.delegatedAmount);
                          lastClaimRound = toString(d.lastClaimRound);
                          startRound = toString(d.startRound);
                          nextUnbondingLockId = toString(d.nextUnbondingLockId);
                          unbondingLockId = toBN(nextUnbondingLockId);

                          if (unbondingLockId.cmp(new BN(0)) > 0) {
                            unbondingLockId = unbondingLockId.sub(new BN(1));
                          }

                          _context26.next = 40;
                          return rpc.getDelegatorUnbondingLock(address, toString(unbondingLockId));

                        case 40:
                          _yield$rpc$getDelegat = _context26.sent;
                          withdrawAmount = _yield$rpc$getDelegat.amount;
                          withdrawRound = _yield$rpc$getDelegat.withdrawRound;

                          if (!(withdrawRound !== '0' && toBN(currentRound).cmp(toBN(withdrawRound)) < 0)) {
                            _context26.next = 47;
                            break;
                          }

                          _context26.t8 = DELEGATOR_STATUS.Unbonding;
                          _context26.next = 50;
                          break;

                        case 47:
                          _context26.next = 49;
                          return rpc.getDelegatorStatus(address);

                        case 49:
                          _context26.t8 = _context26.sent;

                        case 50:
                          status = _context26.t8;
                          return _context26.abrupt("return", {
                            address: address,
                            allowance: allowance,
                            pollCreatorAllowance: pollCreatorAllowance,
                            bondedAmount: bondedAmount,
                            delegateAddress: delegateAddress,
                            delegatedAmount: delegatedAmount,
                            fees: fees,
                            lastClaimRound: lastClaimRound,
                            pendingFees: pendingFees,
                            pendingStake: pendingStake,
                            startRound: startRound,
                            status: status,
                            withdrawRound: withdrawRound,
                            withdrawAmount: withdrawAmount,
                            nextUnbondingLockId: nextUnbondingLockId
                          });

                        case 52:
                        case "end":
                          return _context26.stop();
                      }
                    }
                  }, _callee26);
                }))();
              },

              /**
               * Get all the unbonding locks for a delegator
               * @param {string} addr - delegator's ETH address
               * @return {Promise<Array<UnbondingLock>>}
               *
               * @example
               *
               * await rpc.getDelegatorUnbondingLocks('0xf00...')
               * // => UnbondingLock [{
               * //   id: string,
               * //   delegator: string,
               * //   amount: string,
               * //   withdrawRound: string
               * // }]
               */
              getDelegatorUnbondingLocks: function getDelegatorUnbondingLocks(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee27() {
                  var _yield$rpc$getDelegat2, nextUnbondingLockId, unbondingLockId, result, unbond;

                  return _regenerator.default.wrap(function _callee27$(_context27) {
                    while (1) {
                      switch (_context27.prev = _context27.next) {
                        case 0:
                          _context27.next = 2;
                          return rpc.getDelegator(addr);

                        case 2:
                          _yield$rpc$getDelegat2 = _context27.sent;
                          nextUnbondingLockId = _yield$rpc$getDelegat2.nextUnbondingLockId;
                          unbondingLockId = toNumber(nextUnbondingLockId);

                          if (unbondingLockId > 0) {
                            unbondingLockId -= 1;
                          }

                          result = [];

                        case 7:
                          if (!(unbondingLockId >= 0)) {
                            _context27.next = 15;
                            break;
                          }

                          _context27.next = 10;
                          return rpc.getDelegatorUnbondingLock(addr, toString(unbondingLockId));

                        case 10:
                          unbond = _context27.sent;
                          result.push(unbond);
                          unbondingLockId -= 1;
                          _context27.next = 7;
                          break;

                        case 15:
                          return _context27.abrupt("return", result);

                        case 16:
                        case "end":
                          return _context27.stop();
                      }
                    }
                  }, _callee27);
                }))();
              },

              /**
               * Get an unbonding lock for a delegator
               * @param {string} addr - delegator's ETH address
               * @param {string} unbondingLockId - unbonding lock ID
               *
               * @example
               *
               * await rpc.getDelegatorUnbondingLock('0xf00...', 1)
               * // => UnbondingLock {
               * //   id: string,
               * //   delegator: string,
               * //   amount: string,
               * //   withdrawRound: string
               * // }
               */
              getDelegatorUnbondingLock: function getDelegatorUnbondingLock(addr, unbondingLockId) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee28() {
                  var lock, amount, withdrawRound;
                  return _regenerator.default.wrap(function _callee28$(_context28) {
                    while (1) {
                      switch (_context28.prev = _context28.next) {
                        case 0:
                          _context28.next = 2;
                          return BondingManager.getDelegatorUnbondingLock(addr, unbondingLockId);

                        case 2:
                          lock = _context28.sent;
                          amount = toString(lock.amount);
                          withdrawRound = toString(lock.withdrawRound);
                          return _context28.abrupt("return", {
                            id: unbondingLockId,
                            delegator: addr,
                            amount: amount,
                            withdrawRound: withdrawRound
                          });

                        case 6:
                        case "end":
                          return _context28.stop();
                      }
                    }
                  }, _callee28);
                }))();
              },

              /**
               * Rebonds LPT from an address
               * @memberof livepeer~rpc
               * @param {number} unbondingLockId
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.rebond(0)
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              rebond: function rebond(unbondingLockId) {
                var _arguments2 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee29() {
                  var tx, txHash;
                  return _regenerator.default.wrap(function _callee29$(_context29) {
                    while (1) {
                      switch (_context29.prev = _context29.next) {
                        case 0:
                          tx = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : config.defaultTx;
                          _context29.next = 3;
                          return BondingManager.rebond(unbondingLockId, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 3:
                          txHash = _context29.sent;

                          if (!tx.returnTxHash) {
                            _context29.next = 6;
                            break;
                          }

                          return _context29.abrupt("return", txHash);

                        case 6:
                          _context29.next = 8;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 8:
                          return _context29.abrupt("return", _context29.sent);

                        case 9:
                        case "end":
                          return _context29.stop();
                      }
                    }
                  }, _callee29);
                }))();
              },

              /**
               * Rebonds LPT from an address with hint
               * @memberof livepeer~rpc
               * @param {number} unbondingLockId
               * @param {string} newPosPrev
               * @param {string} newPosNext
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.rebondWithHint(0, "0x", "0x")
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              rebondWithHint: function rebondWithHint(unbondingLockId, newPosPrev, newPosNext, tx) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee30() {
                  var txHash;
                  return _regenerator.default.wrap(function _callee30$(_context30) {
                    while (1) {
                      switch (_context30.prev = _context30.next) {
                        case 0:
                          _context30.next = 2;
                          return BondingManager.rebondWithHint(unbondingLockId, newPosPrev, newPosNext, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 2:
                          txHash = _context30.sent;

                          if (!tx.returnTxHash) {
                            _context30.next = 5;
                            break;
                          }

                          return _context30.abrupt("return", txHash);

                        case 5:
                          _context30.next = 7;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 7:
                          return _context30.abrupt("return", _context30.sent);

                        case 8:
                        case "end":
                          return _context30.stop();
                      }
                    }
                  }, _callee30);
                }))();
              },

              /**
               * Rebonds LPT from an address
               * @memberof livepeer~rpc
               * @param {string} to
               * @param {number} unbondingLockId
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.rebondFromUnbonded("0x", 1)
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              rebondFromUnbonded: function rebondFromUnbonded(to, unbondingLockId) {
                var _arguments3 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee31() {
                  var tx, txHash;
                  return _regenerator.default.wrap(function _callee31$(_context31) {
                    while (1) {
                      switch (_context31.prev = _context31.next) {
                        case 0:
                          tx = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : config.defaultTx;
                          _context31.next = 3;
                          return BondingManager.rebondFromUnbonded(to, unbondingLockId, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 3:
                          txHash = _context31.sent;

                          if (!tx.returnTxHash) {
                            _context31.next = 6;
                            break;
                          }

                          return _context31.abrupt("return", txHash);

                        case 6:
                          _context31.next = 8;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 8:
                          return _context31.abrupt("return", _context31.sent);

                        case 9:
                        case "end":
                          return _context31.stop();
                      }
                    }
                  }, _callee31);
                }))();
              },

              /**
               * Rebonds LPT from an address with hint
               * @memberof livepeer~rpc
               * @param {string} to
               * @param {number} unbondingLockId
               * @param {string} newPosPrev
               * @param {string} newPosNext
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.rebondFromUnbondedWithHint("0x", 1, "0x", "0x")
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              rebondFromUnbondedWithHint: function rebondFromUnbondedWithHint(to, unbondingLockId, newPosPrev, newPosNext) {
                var _arguments4 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee32() {
                  var tx, txHash;
                  return _regenerator.default.wrap(function _callee32$(_context32) {
                    while (1) {
                      switch (_context32.prev = _context32.next) {
                        case 0:
                          tx = _arguments4.length > 4 && _arguments4[4] !== undefined ? _arguments4[4] : config.defaultTx;
                          _context32.next = 3;
                          return BondingManager.rebondFromUnbondedWithHint(to, unbondingLockId, newPosPrev, newPosNext, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 3:
                          txHash = _context32.sent;

                          if (!tx.returnTxHash) {
                            _context32.next = 6;
                            break;
                          }

                          return _context32.abrupt("return", txHash);

                        case 6:
                          _context32.next = 8;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 8:
                          return _context32.abrupt("return", _context32.sent);

                        case 9:
                        case "end":
                          return _context32.stop();
                      }
                    }
                  }, _callee32);
                }))();
              },

              /**
               * Get a delegator's pending stake
               * @memberof livepeer~rpc
               * @param {string} addr - user's ETH address
               * @param {string} endRound The last round to compute pending stake from
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getPendingStake('0xf00...')
               * // => string
               */
              getPendingStake: function getPendingStake(addr, endRound) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee33() {
                  var address, currentRound;
                  return _regenerator.default.wrap(function _callee33$(_context33) {
                    while (1) {
                      switch (_context33.prev = _context33.next) {
                        case 0:
                          _context33.prev = 0;
                          _context33.next = 3;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 3:
                          address = _context33.sent;

                          if (endRound) {
                            _context33.next = 13;
                            break;
                          }

                          _context33.next = 7;
                          return rpc.getCurrentRound();

                        case 7:
                          currentRound = _context33.sent;
                          _context33.t0 = headToString;
                          _context33.next = 11;
                          return BondingManager.pendingStake(address, currentRound);

                        case 11:
                          _context33.t1 = _context33.sent;
                          return _context33.abrupt("return", (0, _context33.t0)(_context33.t1));

                        case 13:
                          _context33.t2 = headToString;
                          _context33.next = 16;
                          return BondingManager.pendingStake(address, endRound);

                        case 16:
                          _context33.t3 = _context33.sent;
                          return _context33.abrupt("return", (0, _context33.t2)(_context33.t3));

                        case 20:
                          _context33.prev = 20;
                          _context33.t4 = _context33["catch"](0);
                          _context33.t4.message = 'Error: getPendingStake\n' + _context33.t4.message;
                          throw _context33.t4;

                        case 24:
                        case "end":
                          return _context33.stop();
                      }
                    }
                  }, _callee33, null, [[0, 20]]);
                }))();
              },

              /**
               * Get a delegator's pending fees
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @param  {string} endRound The last round to compute pending fees from
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getPendingFees('0xf00...')
               * // => string
               */
              getPendingFees: function getPendingFees(addr, endRound) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee34() {
                  var address, currentRound;
                  return _regenerator.default.wrap(function _callee34$(_context34) {
                    while (1) {
                      switch (_context34.prev = _context34.next) {
                        case 0:
                          _context34.prev = 0;
                          _context34.next = 3;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 3:
                          address = _context34.sent;

                          if (endRound) {
                            _context34.next = 13;
                            break;
                          }

                          _context34.next = 7;
                          return rpc.getCurrentRound();

                        case 7:
                          currentRound = _context34.sent;
                          _context34.t0 = headToString;
                          _context34.next = 11;
                          return BondingManager.pendingFees(address, currentRound);

                        case 11:
                          _context34.t1 = _context34.sent;
                          return _context34.abrupt("return", (0, _context34.t0)(_context34.t1));

                        case 13:
                          _context34.t2 = headToString;
                          _context34.next = 16;
                          return BondingManager.pendingFees(address, endRound);

                        case 16:
                          _context34.t3 = _context34.sent;
                          return _context34.abrupt("return", (0, _context34.t2)(_context34.t3));

                        case 20:
                          _context34.prev = 20;
                          _context34.t4 = _context34["catch"](0);
                          _context34.t4.message = 'Error: getPendingFees\n' + _context34.t4.message;
                          throw _context34.t4;

                        case 24:
                        case "end":
                          return _context34.stop();
                      }
                    }
                  }, _callee34, null, [[0, 20]]);
                }))();
              },

              /**
               * Whether or not the transcoder is active
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<boolean>}
               *
               * @example
               *
               * await rpc.getTranscoderIsActive('0xf00...')
               * // => boolean
               */
              getTranscoderIsActive: function getTranscoderIsActive(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee35() {
                  return _regenerator.default.wrap(function _callee35$(_context35) {
                    while (1) {
                      switch (_context35.prev = _context35.next) {
                        case 0:
                          _context35.t0 = headToBool;
                          _context35.t1 = BondingManager;
                          _context35.next = 4;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 4:
                          _context35.t2 = _context35.sent;
                          _context35.next = 7;
                          return _context35.t1.isActiveTranscoder.call(_context35.t1, _context35.t2);

                        case 7:
                          _context35.t3 = _context35.sent;
                          return _context35.abrupt("return", (0, _context35.t0)(_context35.t3));

                        case 9:
                        case "end":
                          return _context35.stop();
                      }
                    }
                  }, _callee35);
                }))();
              },

              /**
               * Gets the status of a transcoder
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getTranscoderStatus('0xf00...')
               * // => 'NotRegistered' | 'Registered'
               */
              getTranscoderStatus: function getTranscoderStatus(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee36() {
                  var status;
                  return _regenerator.default.wrap(function _callee36$(_context36) {
                    while (1) {
                      switch (_context36.prev = _context36.next) {
                        case 0:
                          _context36.t0 = headToString;
                          _context36.t1 = BondingManager;
                          _context36.next = 4;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 4:
                          _context36.t2 = _context36.sent;
                          _context36.next = 7;
                          return _context36.t1.transcoderStatus.call(_context36.t1, _context36.t2);

                        case 7:
                          _context36.t3 = _context36.sent;
                          status = (0, _context36.t0)(_context36.t3);
                          return _context36.abrupt("return", TRANSCODER_STATUS[status]);

                        case 10:
                        case "end":
                          return _context36.stop();
                      }
                    }
                  }, _callee36);
                }))();
              },

              /**
               * Gets a transcoder's total stake
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getTranscoderTotalStake('0xf00...')
               * // => string
               */
              getTranscoderTotalStake: function getTranscoderTotalStake(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee37() {
                  return _regenerator.default.wrap(function _callee37$(_context37) {
                    while (1) {
                      switch (_context37.prev = _context37.next) {
                        case 0:
                          _context37.t0 = headToString;
                          _context37.t1 = BondingManager;
                          _context37.next = 4;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 4:
                          _context37.t2 = _context37.sent;
                          _context37.next = 7;
                          return _context37.t1.transcoderTotalStake.call(_context37.t1, _context37.t2);

                        case 7:
                          _context37.t3 = _context37.sent;
                          return _context37.abrupt("return", (0, _context37.t0)(_context37.t3));

                        case 9:
                        case "end":
                          return _context37.stop();
                      }
                    }
                  }, _callee37);
                }))();
              },

              /**
               * Gets a transcoder's pool max size
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getTranscoderPoolMaxSize()
               * // => string
               */
              getTranscoderPoolMaxSize: function getTranscoderPoolMaxSize() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee38() {
                  return _regenerator.default.wrap(function _callee38$(_context38) {
                    while (1) {
                      switch (_context38.prev = _context38.next) {
                        case 0:
                          _context38.t0 = headToString;
                          _context38.next = 3;
                          return BondingManager.getTranscoderPoolMaxSize();

                        case 3:
                          _context38.t1 = _context38.sent;
                          return _context38.abrupt("return", (0, _context38.t0)(_context38.t1));

                        case 5:
                        case "end":
                          return _context38.stop();
                      }
                    }
                  }, _callee38);
                }))();
              },

              /**
               * Gets info about a transcoder
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @return {Promise<Transcoder>}
               *
               * @example
               *
               * await rpc.getTranscoder('0xf00...')
               * // => Transcoder {
               * //   active: boolean,
               * //   address: string,
               * //   rewardCut: string,
               * //   feeShare: string,
               * //   lastRewardRound: string,
               * //   pendingRewardCut string,
               * //   pendingFeeShare: string,
               * //   pendingPricePerSegment: string,
               * //   pricePerSegment: string,
               * //   status: 'NotRegistered' | 'Registered',
               * //   totalStake: string,
               * // }
               */
              getTranscoder: function getTranscoder(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee39() {
                  var address, totalStake, t, feeShare, lastRewardRound, rewardCut, activationRound, deactivationRound, lastActiveStakeUpdateRound;
                  return _regenerator.default.wrap(function _callee39$(_context39) {
                    while (1) {
                      switch (_context39.prev = _context39.next) {
                        case 0:
                          _context39.next = 2;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 2:
                          address = _context39.sent;
                          _context39.next = 5;
                          return rpc.getTranscoderTotalStake(address);

                        case 5:
                          totalStake = _context39.sent;
                          _context39.next = 8;
                          return BondingManager.getTranscoder(address);

                        case 8:
                          t = _context39.sent;
                          feeShare = toString(t.feeShare);
                          lastRewardRound = toString(t.lastRewardRound);
                          rewardCut = toString(t.rewardCut);
                          activationRound = toString(t.activationRound);
                          deactivationRound = toString(t.deactivationRound);
                          lastActiveStakeUpdateRound = toString(t.lastActiveStakeUpdateRound);
                          return _context39.abrupt("return", {
                            address: address,
                            feeShare: feeShare,
                            lastRewardRound: lastRewardRound,
                            activationRound: activationRound,
                            deactivationRound: deactivationRound,
                            rewardCut: rewardCut,
                            totalStake: totalStake,
                            lastActiveStakeUpdateRound: lastActiveStakeUpdateRound
                          });

                        case 16:
                        case "end":
                          return _context39.stop();
                      }
                    }
                  }, _callee39);
                }))();
              },

              /**
               * Gets transcoders
               * @memberof livepeer~rpc
               * @return {Array<Transcoder>}
               *
               * @example
               *
               * await rpc.getTranscoders()
               * // => Array<Transcoder>
               */
              getTranscoders: function getTranscoders() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee40() {
                  var transcoders, addr, transcoder;
                  return _regenerator.default.wrap(function _callee40$(_context40) {
                    while (1) {
                      switch (_context40.prev = _context40.next) {
                        case 0:
                          transcoders = [];
                          _context40.t0 = headToString;
                          _context40.next = 4;
                          return BondingManager.getFirstTranscoderInPool();

                        case 4:
                          _context40.t1 = _context40.sent;
                          addr = (0, _context40.t0)(_context40.t1);

                        case 6:
                          if (!(addr !== EMPTY_ADDRESS)) {
                            _context40.next = 18;
                            break;
                          }

                          _context40.next = 9;
                          return rpc.getTranscoder(addr);

                        case 9:
                          transcoder = _context40.sent;
                          transcoders.push(transcoder);
                          _context40.t2 = headToString;
                          _context40.next = 14;
                          return BondingManager.getNextTranscoderInPool(addr);

                        case 14:
                          _context40.t3 = _context40.sent;
                          addr = (0, _context40.t2)(_context40.t3);
                          _context40.next = 6;
                          break;

                        case 18:
                          return _context40.abrupt("return", transcoders);

                        case 19:
                        case "end":
                          return _context40.stop();
                      }
                    }
                  }, _callee40);
                }))();
              },

              /**
               * Whether the protocol is paused
               * @memberof livepeer~rpc
               * @return {Promise<boolean>}
               *
               * @example
               *
               * await rpc.getProtocolPaused()
               * // => boolean
               */
              getProtocolPaused: function getProtocolPaused() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee41() {
                  return _regenerator.default.wrap(function _callee41$(_context41) {
                    while (1) {
                      switch (_context41.prev = _context41.next) {
                        case 0:
                          _context41.t0 = headToBool;
                          _context41.next = 3;
                          return Controller.paused();

                        case 3:
                          _context41.t1 = _context41.sent;
                          return _context41.abrupt("return", (0, _context41.t0)(_context41.t1));

                        case 5:
                        case "end":
                          return _context41.stop();
                      }
                    }
                  }, _callee41);
                }))();
              },

              /**
               * Gets the protocol
               * @memberof livepeer~rpc
               * @return {Promise<Protocol>}
               *
               * @example
               *
               * await rpc.getProtocol()
               * // => Protocol {
                  paused
                  totalTokenSupply
                  totalBondedToken
                  targetBondingRate
                  transcoderPoolMaxSize
                  maxEarningsClaimsRounds
               }
               */
              getProtocol: function getProtocol() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee42() {
                  var paused, totalTokenSupply, totalBondedToken, targetBondingRate, transcoderPoolMaxSize, maxEarningsClaimsRounds;
                  return _regenerator.default.wrap(function _callee42$(_context42) {
                    while (1) {
                      switch (_context42.prev = _context42.next) {
                        case 0:
                          _context42.next = 2;
                          return rpc.getProtocolPaused();

                        case 2:
                          paused = _context42.sent;
                          _context42.next = 5;
                          return rpc.getTokenTotalSupply();

                        case 5:
                          totalTokenSupply = _context42.sent;
                          _context42.next = 8;
                          return rpc.getTotalBonded();

                        case 8:
                          totalBondedToken = _context42.sent;
                          _context42.next = 11;
                          return rpc.getTargetBondingRate();

                        case 11:
                          targetBondingRate = _context42.sent;
                          _context42.next = 14;
                          return rpc.getTranscoderPoolMaxSize();

                        case 14:
                          transcoderPoolMaxSize = _context42.sent;
                          _context42.next = 17;
                          return rpc.getMaxEarningsClaimsRounds();

                        case 17:
                          maxEarningsClaimsRounds = _context42.sent;
                          return _context42.abrupt("return", {
                            paused: paused,
                            totalTokenSupply: totalTokenSupply,
                            totalBondedToken: totalBondedToken,
                            targetBondingRate: targetBondingRate,
                            transcoderPoolMaxSize: transcoderPoolMaxSize,
                            maxEarningsClaimsRounds: maxEarningsClaimsRounds
                          });

                        case 19:
                        case "end":
                          return _context42.stop();
                      }
                    }
                  }, _callee42);
                }))();
              },

              /**
               * Gets the length of a round (in blocks)
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getRoundLength()
               * // => string
               */
              getRoundLength: function getRoundLength() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee43() {
                  return _regenerator.default.wrap(function _callee43$(_context43) {
                    while (1) {
                      switch (_context43.prev = _context43.next) {
                        case 0:
                          _context43.t0 = headToString;
                          _context43.next = 3;
                          return RoundsManager.roundLength();

                        case 3:
                          _context43.t1 = _context43.sent;
                          return _context43.abrupt("return", (0, _context43.t0)(_context43.t1));

                        case 5:
                        case "end":
                          return _context43.stop();
                      }
                    }
                  }, _callee43);
                }))();
              },

              /**
               * Gets the estimated number of rounds per year
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getRoundsPerYear()
               * // => string
               */
              getRoundsPerYear: function getRoundsPerYear() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee44() {
                  return _regenerator.default.wrap(function _callee44$(_context44) {
                    while (1) {
                      switch (_context44.prev = _context44.next) {
                        case 0:
                          _context44.t0 = headToString;
                          _context44.next = 3;
                          return RoundsManager.roundsPerYear();

                        case 3:
                          _context44.t1 = _context44.sent;
                          return _context44.abrupt("return", (0, _context44.t0)(_context44.t1));

                        case 5:
                        case "end":
                          return _context44.stop();
                      }
                    }
                  }, _callee44);
                }))();
              },

              /**
               * Gets the number of the current round
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getCurrentRound()
               * // => string
               */
              getCurrentRound: function getCurrentRound() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee45() {
                  return _regenerator.default.wrap(function _callee45$(_context45) {
                    while (1) {
                      switch (_context45.prev = _context45.next) {
                        case 0:
                          _context45.t0 = headToString;
                          _context45.next = 3;
                          return RoundsManager.currentRound();

                        case 3:
                          _context45.t1 = _context45.sent;
                          return _context45.abrupt("return", (0, _context45.t0)(_context45.t1));

                        case 5:
                        case "end":
                          return _context45.stop();
                      }
                    }
                  }, _callee45);
                }))();
              },

              /**
               * Whether or not the current round is initalized
               * @memberof livepeer~rpc
               * @return {Promise<boolean>}
               *
               * @example
               *
               * await rpc.getCurrentRoundIsInitialized()
               * // => boolean
               */
              getCurrentRoundIsInitialized: function getCurrentRoundIsInitialized() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee46() {
                  return _regenerator.default.wrap(function _callee46$(_context46) {
                    while (1) {
                      switch (_context46.prev = _context46.next) {
                        case 0:
                          _context46.t0 = headToBool;
                          _context46.next = 3;
                          return RoundsManager.currentRoundInitialized();

                        case 3:
                          _context46.t1 = _context46.sent;
                          return _context46.abrupt("return", (0, _context46.t0)(_context46.t1));

                        case 5:
                        case "end":
                          return _context46.stop();
                      }
                    }
                  }, _callee46);
                }))();
              },

              /**
               * The block at which the current round started
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getCurrentRoundStartBlock()
               * // => string
               */
              getCurrentRoundStartBlock: function getCurrentRoundStartBlock() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee47() {
                  return _regenerator.default.wrap(function _callee47$(_context47) {
                    while (1) {
                      switch (_context47.prev = _context47.next) {
                        case 0:
                          _context47.t0 = headToString;
                          _context47.next = 3;
                          return RoundsManager.currentRoundStartBlock();

                        case 3:
                          _context47.t1 = _context47.sent;
                          return _context47.abrupt("return", (0, _context47.t0)(_context47.t1));

                        case 5:
                        case "end":
                          return _context47.stop();
                      }
                    }
                  }, _callee47);
                }))();
              },

              /**
               * The previously intitialized round
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getLastInitializedRound()
               * // => string
               */
              getLastInitializedRound: function getLastInitializedRound() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee48() {
                  return _regenerator.default.wrap(function _callee48$(_context48) {
                    while (1) {
                      switch (_context48.prev = _context48.next) {
                        case 0:
                          _context48.t0 = headToString;
                          _context48.next = 3;
                          return RoundsManager.lastInitializedRound();

                        case 3:
                          _context48.t1 = _context48.sent;
                          return _context48.abrupt("return", (0, _context48.t0)(_context48.t1));

                        case 5:
                        case "end":
                          return _context48.stop();
                      }
                    }
                  }, _callee48);
                }))();
              },

              /**
               * Gets general information about the rounds in the protocol
               * @memberof livepeer~rpc
               * @return {Promise<RoundInfo>}
               *
               * @example
               *
               * await rpc.getCurrentRoundInfo()
               * // => RoundInfo {
               * //   id: string,
               * //   initialized: boolean,
               * //   startBlock: string,
               * //   lastInitializedRound: string,
               * //   length: string,
               * // }
               */
              getCurrentRoundInfo: function getCurrentRoundInfo() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee49() {
                  var length, id, initialized, lastInitializedRound, startBlock;
                  return _regenerator.default.wrap(function _callee49$(_context49) {
                    while (1) {
                      switch (_context49.prev = _context49.next) {
                        case 0:
                          _context49.next = 2;
                          return rpc.getRoundLength();

                        case 2:
                          length = _context49.sent;
                          _context49.next = 5;
                          return rpc.getCurrentRound();

                        case 5:
                          id = _context49.sent;
                          _context49.next = 8;
                          return rpc.getCurrentRoundIsInitialized();

                        case 8:
                          initialized = _context49.sent;
                          _context49.next = 11;
                          return rpc.getLastInitializedRound();

                        case 11:
                          lastInitializedRound = _context49.sent;
                          _context49.next = 14;
                          return rpc.getCurrentRoundStartBlock();

                        case 14:
                          startBlock = _context49.sent;
                          return _context49.abrupt("return", {
                            id: id,
                            initialized: initialized,
                            lastInitializedRound: lastInitializedRound,
                            length: length,
                            startBlock: startBlock
                          });

                        case 16:
                        case "end":
                          return _context49.stop();
                      }
                    }
                  }, _callee49);
                }))();
              },
              getLipUpgradeRound: function getLipUpgradeRound(lipNumber) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee50() {
                  return _regenerator.default.wrap(function _callee50$(_context50) {
                    while (1) {
                      switch (_context50.prev = _context50.next) {
                        case 0:
                          _context50.next = 2;
                          return RoundsManager.lipUpgradeRound(lipNumber);

                        case 2:
                          return _context50.abrupt("return", _context50.sent[0]);

                        case 3:
                        case "end":
                          return _context50.stop();
                      }
                    }
                  }, _callee50);
                }))();
              },

              /**
               * Gets LPT from the faucet
               * @memberof livepeer~rpc
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.tapFaucet('1337')
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              tapFaucet: function tapFaucet() {
                var _arguments5 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee51() {
                  var tx;
                  return _regenerator.default.wrap(function _callee51$(_context51) {
                    while (1) {
                      switch (_context51.prev = _context51.next) {
                        case 0:
                          tx = _arguments5.length > 0 && _arguments5[0] !== undefined ? _arguments5[0] : config.defaultTx;
                          _context51.t0 = utils;
                          _context51.next = 4;
                          return LivepeerTokenFaucet.request(tx);

                        case 4:
                          _context51.t1 = _context51.sent;
                          _context51.t2 = config.eth;
                          _context51.next = 8;
                          return _context51.t0.getTxReceipt.call(_context51.t0, _context51.t1, _context51.t2);

                        case 8:
                          return _context51.abrupt("return", _context51.sent);

                        case 9:
                        case "end":
                          return _context51.stop();
                      }
                    }
                  }, _callee51);
                }))();
              },

              /**
               * Initializes the round
               * @memberof livepeer~rpc
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.initializeRound()
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              initializeRound: function initializeRound() {
                var _arguments6 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee52() {
                  var tx, txHash;
                  return _regenerator.default.wrap(function _callee52$(_context52) {
                    while (1) {
                      switch (_context52.prev = _context52.next) {
                        case 0:
                          tx = _arguments6.length > 0 && _arguments6[0] !== undefined ? _arguments6[0] : config.defaultTx;
                          _context52.prev = 1;
                          _context52.next = 4;
                          return RoundsManager.initializeRound(tx);

                        case 4:
                          txHash = _context52.sent;

                          if (!tx.returnTxHash) {
                            _context52.next = 7;
                            break;
                          }

                          return _context52.abrupt("return", txHash);

                        case 7:
                          _context52.next = 9;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 9:
                          return _context52.abrupt("return", _context52.sent);

                        case 12:
                          _context52.prev = 12;
                          _context52.t0 = _context52["catch"](1);
                          _context52.t0.message = 'Error: initializeRound\n' + _context52.t0.message;
                          throw _context52.t0;

                        case 16:
                        case "end":
                          return _context52.stop();
                      }
                    }
                  }, _callee52, null, [[1, 12]]);
                }))();
              },
              approveTokenPollCreationCost: function approveTokenPollCreationCost(amount, tx) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee53() {
                  var token, txHash;
                  return _regenerator.default.wrap(function _callee53$(_context53) {
                    while (1) {
                      switch (_context53.prev = _context53.next) {
                        case 0:
                          token = toBN(amount);
                          _context53.next = 3;
                          return LivepeerToken.approve(PollCreator.address, token, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 3:
                          txHash = _context53.sent;

                          if (!tx.returnTxHash) {
                            _context53.next = 6;
                            break;
                          }

                          return _context53.abrupt("return", txHash);

                        case 6:
                          _context53.next = 8;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 8:
                          return _context53.abrupt("return", _context53.sent);

                        case 9:
                        case "end":
                          return _context53.stop();
                      }
                    }
                  }, _callee53);
                }))();
              },

              /**
               * Creates a poll
               * @memberof livepeer~rpc
               * @param {string} proposal - The IPFS multihash for the proposal
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.createPoll('Qm...')
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              createPoll: function createPoll(proposal) {
                var _arguments7 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee54() {
                  var tx, txHash;
                  return _regenerator.default.wrap(function _callee54$(_context54) {
                    while (1) {
                      switch (_context54.prev = _context54.next) {
                        case 0:
                          tx = _arguments7.length > 1 && _arguments7[1] !== undefined ? _arguments7[1] : config.defaultTx;
                          _context54.prev = 1;
                          _context54.next = 4;
                          return PollCreator.createPoll(proposal, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 4:
                          txHash = _context54.sent;

                          if (!tx.returnTxHash) {
                            _context54.next = 7;
                            break;
                          }

                          return _context54.abrupt("return", txHash);

                        case 7:
                          _context54.next = 9;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 9:
                          return _context54.abrupt("return", _context54.sent);

                        case 12:
                          _context54.prev = 12;
                          _context54.t0 = _context54["catch"](1);
                          _context54.t0.message = 'Error: createPoll\n' + _context54.t0.message;
                          throw _context54.t0;

                        case 16:
                        case "end":
                          return _context54.stop();
                      }
                    }
                  }, _callee54, null, [[1, 12]]);
                }))();
              },

              /**
               * Get PollCreator transfer allowance
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.getPollCreatorAllowance('0x...')
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              getPollCreatorAllowance: function getPollCreatorAllowance(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee55() {
                  var address;
                  return _regenerator.default.wrap(function _callee55$(_context55) {
                    while (1) {
                      switch (_context55.prev = _context55.next) {
                        case 0:
                          _context55.prev = 0;
                          _context55.next = 3;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 3:
                          address = _context55.sent;
                          _context55.t0 = headToString;
                          _context55.next = 7;
                          return LivepeerToken.allowance(address, PollCreator.address);

                        case 7:
                          _context55.t1 = _context55.sent;
                          return _context55.abrupt("return", (0, _context55.t0)(_context55.t1));

                        case 11:
                          _context55.prev = 11;
                          _context55.t2 = _context55["catch"](0);
                          _context55.t2.message = 'Error: getPollCreatorAllowance\n' + _context55.t2.message;
                          throw _context55.t2;

                        case 15:
                        case "end":
                          return _context55.stop();
                      }
                    }
                  }, _callee55, null, [[0, 11]]);
                }))();
              },

              /**
               * Get BondingManager transfer allowance
               * @memberof livepeer~rpc
               * @param  {string} addr - user's ETH address
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.getBondingManagerAllowance('0x...')
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              getBondingManagerAllowance: function getBondingManagerAllowance(addr) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee56() {
                  var address;
                  return _regenerator.default.wrap(function _callee56$(_context56) {
                    while (1) {
                      switch (_context56.prev = _context56.next) {
                        case 0:
                          _context56.prev = 0;
                          _context56.next = 3;
                          return resolveAddress(rpc.getENSAddress, addr);

                        case 3:
                          address = _context56.sent;
                          _context56.t0 = headToString;
                          _context56.next = 7;
                          return LivepeerToken.allowance(address, BondingManager.address);

                        case 7:
                          _context56.t1 = _context56.sent;
                          return _context56.abrupt("return", (0, _context56.t0)(_context56.t1));

                        case 11:
                          _context56.prev = 11;
                          _context56.t2 = _context56["catch"](0);
                          _context56.t2.message = 'Error: getBondingManagerAllowance\n' + _context56.t2.message;
                          throw _context56.t2;

                        case 15:
                        case "end":
                          return _context56.stop();
                      }
                    }
                  }, _callee56, null, [[0, 11]]);
                }))();
              },

              /**
               * Creates a poll
               * @memberof livepeer~rpc
               * @param {string} pollAddress - poll contract address
               * @param {int} choiceId - vote (0 = yes, 1 = no)
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.initializeRound()
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              vote: function vote(pollAddress, choiceId) {
                var _arguments8 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee57() {
                  var tx, Poll, txHash;
                  return _regenerator.default.wrap(function _callee57$(_context57) {
                    while (1) {
                      switch (_context57.prev = _context57.next) {
                        case 0:
                          tx = _arguments8.length > 2 && _arguments8[2] !== undefined ? _arguments8[2] : config.defaultTx;
                          _context57.prev = 1;
                          _context57.next = 4;
                          return getContractAt(config.eth, _objectSpread(_objectSpread({}, _Poll.default), {}, {
                            defaultTx: config.defaultTx,
                            address: pollAddress
                          }));

                        case 4:
                          Poll = _context57.sent;
                          _context57.next = 7;
                          return Poll.vote(choiceId, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 7:
                          txHash = _context57.sent;

                          if (!tx.returnTxHash) {
                            _context57.next = 10;
                            break;
                          }

                          return _context57.abrupt("return", txHash);

                        case 10:
                          _context57.next = 12;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 12:
                          return _context57.abrupt("return", _context57.sent);

                        case 15:
                          _context57.prev = 15;
                          _context57.t0 = _context57["catch"](1);
                          _context57.t0.message = 'Error: vote\n' + _context57.t0.message;
                          throw _context57.t0;

                        case 19:
                        case "end":
                          return _context57.stop();
                      }
                    }
                  }, _callee57, null, [[1, 15]]);
                }))();
              },

              /**
               * Claims token and eth earnings from the sender's `lastClaimRound + 1` through a given `endRound`
               * @memberof livepeer~rpc
               * @param {string} endRound - the round to claim earnings until
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {string}
               *
               * @example
               *
               * await rpc.claimEarnings()
               * // => string
               */
              claimEarnings: function claimEarnings(endRound) {
                var _arguments9 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee58() {
                  var tx;
                  return _regenerator.default.wrap(function _callee58$(_context58) {
                    while (1) {
                      switch (_context58.prev = _context58.next) {
                        case 0:
                          tx = _arguments9.length > 1 && _arguments9[1] !== undefined ? _arguments9[1] : config.defaultTx;
                          _context58.next = 3;
                          return BondingManager.claimEarnings(endRound, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 3:
                          return _context58.abrupt("return", _context58.sent);

                        case 4:
                        case "end":
                          return _context58.stop();
                      }
                    }
                  }, _callee58);
                }))();
              },
              approveTokenBondAmount: function approveTokenBondAmount(amount, tx) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee59() {
                  var token, txHash;
                  return _regenerator.default.wrap(function _callee59$(_context59) {
                    while (1) {
                      switch (_context59.prev = _context59.next) {
                        case 0:
                          token = toBN(amount);
                          _context59.next = 3;
                          return LivepeerToken.approve(BondingManager.address, token, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 3:
                          txHash = _context59.sent;

                          if (!tx.returnTxHash) {
                            _context59.next = 6;
                            break;
                          }

                          return _context59.abrupt("return", txHash);

                        case 6:
                          _context59.next = 8;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 8:
                          return _context59.abrupt("return", _context59.sent);

                        case 9:
                        case "end":
                          return _context59.stop();
                      }
                    }
                  }, _callee59);
                }))();
              },
              bondApprovedTokenAmount: function bondApprovedTokenAmount(to, amount, tx) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee60() {
                  var token, txHash;
                  return _regenerator.default.wrap(function _callee60$(_context60) {
                    while (1) {
                      switch (_context60.prev = _context60.next) {
                        case 0:
                          token = toBN(amount);
                          _context60.t0 = BondingManager;
                          _context60.t1 = token;
                          _context60.next = 5;
                          return resolveAddress(rpc.getENSAddress, to);

                        case 5:
                          _context60.t2 = _context60.sent;
                          _context60.t3 = _objectSpread(_objectSpread({}, config.defaultTx), tx);
                          _context60.next = 9;
                          return _context60.t0.bond.call(_context60.t0, _context60.t1, _context60.t2, _context60.t3);

                        case 9:
                          txHash = _context60.sent;

                          if (!tx.returnTxHash) {
                            _context60.next = 12;
                            break;
                          }

                          return _context60.abrupt("return", txHash);

                        case 12:
                          _context60.next = 14;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 14:
                          return _context60.abrupt("return", _context60.sent);

                        case 15:
                        case "end":
                          return _context60.stop();
                      }
                    }
                  }, _callee60);
                }))();
              },

              /**
               * Bonds to a transcoder with hint
               * @memberof livepeer~rpc
               * @param {string} amount
               * @param {string} to
               * @param {string} oldDelegateNewPosPrev
               * @param {string} oldDelegateNewPosNext
               * @param {string} currDelegateNewPosPrev
               * @param {string} currDelegateNewPosNext
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.bondWithHint("100", "0x", "0x", "0x", "0x", "0x")
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              bondWithHint: function bondWithHint(amount, to, oldDelegateNewPosPrev, oldDelegateNewPosNext, currDelegateNewPosPrev, currDelegateNewPosNext, tx) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee61() {
                  var token, txHash;
                  return _regenerator.default.wrap(function _callee61$(_context61) {
                    while (1) {
                      switch (_context61.prev = _context61.next) {
                        case 0:
                          token = toBN(amount);
                          _context61.t0 = BondingManager;
                          _context61.t1 = token;
                          _context61.next = 5;
                          return resolveAddress(rpc.getENSAddress, to);

                        case 5:
                          _context61.t2 = _context61.sent;
                          _context61.t3 = oldDelegateNewPosPrev;
                          _context61.t4 = oldDelegateNewPosNext;
                          _context61.t5 = currDelegateNewPosPrev;
                          _context61.t6 = currDelegateNewPosNext;
                          _context61.t7 = _objectSpread(_objectSpread({}, config.defaultTx), tx);
                          _context61.next = 13;
                          return _context61.t0.bondWithHint.call(_context61.t0, _context61.t1, _context61.t2, _context61.t3, _context61.t4, _context61.t5, _context61.t6, _context61.t7);

                        case 13:
                          txHash = _context61.sent;

                          if (!tx.returnTxHash) {
                            _context61.next = 16;
                            break;
                          }

                          return _context61.abrupt("return", txHash);

                        case 16:
                          _context61.next = 18;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 18:
                          return _context61.abrupt("return", _context61.sent);

                        case 19:
                        case "end":
                          return _context61.stop();
                      }
                    }
                  }, _callee61);
                }))();
              },

              /**
               * Gets the estimated amount of gas to be used by a smart contract
               * method.
               * @memberof livepeer~rpc
               * @param
               *  contractName: name of contract containing method you wish to find gas price for.
               *  methodName: name of method on contract.
               *  methodArgs: array of argument to be passed to the contract in specified order.
               *  tx: (optioanl){
               *    from: address - 0x...,
               *    gas: number,
               *    value: (optional) number or string containing number
               *  }
               *
               * @return {Promise<number>} containing estimated gas price
               *
               * @example
               *
               * await rpc.estimateGas(
               *  'BondingManager',
               *  'bond',
               *  [10, '0x00.....']
               * )
               * // => 33454
               */
              estimateGas: function estimateGas(contractName, methodName, methodArgs) {
                var _arguments10 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee62() {
                  var tx, gasRate, contractABI, methodABI, encodedData;
                  return _regenerator.default.wrap(function _callee62$(_context62) {
                    while (1) {
                      switch (_context62.prev = _context62.next) {
                        case 0:
                          tx = _arguments10.length > 3 && _arguments10[3] !== undefined ? _arguments10[3] : config.defaultTx;
                          tx.value = tx.value ? tx.value : '0';
                          gasRate = 1.2;
                          contractABI = config.abis[contractName];
                          methodABI = utils.findAbiByName(contractABI, methodName);
                          encodedData = utils.encodeMethodParams(methodABI, methodArgs);
                          _context62.t0 = Math;
                          _context62.t1 = toNumber;
                          _context62.next = 10;
                          return config.eth.estimateGas({
                            to: config.contracts[contractName].address,
                            from: config.defaultTx.from,
                            value: tx.value,
                            data: encodedData
                          });

                        case 10:
                          _context62.t2 = _context62.sent;
                          _context62.t3 = (0, _context62.t1)(_context62.t2);
                          _context62.t4 = gasRate;
                          _context62.t5 = _context62.t3 * _context62.t4;
                          return _context62.abrupt("return", _context62.t0.round.call(_context62.t0, _context62.t5));

                        case 15:
                        case "end":
                          return _context62.stop();
                      }
                    }
                  }, _callee62);
                }))();
              },
              getCalldata: function getCalldata(contractName, methodName, methodArgs) {
                var contractABI = config.abis[contractName];
                var methodABI = utils.findAbiByName(contractABI, methodName);
                return utils.encodeMethodParams(methodABI, methodArgs);
              },
              estimateGasRaw: function estimateGasRaw(tx) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee63() {
                  var gasRate;
                  return _regenerator.default.wrap(function _callee63$(_context63) {
                    while (1) {
                      switch (_context63.prev = _context63.next) {
                        case 0:
                          gasRate = 1.2;
                          _context63.t0 = Math;
                          _context63.t1 = toNumber;
                          _context63.next = 5;
                          return config.eth.estimateGas(_objectSpread({}, tx));

                        case 5:
                          _context63.t2 = _context63.sent;
                          _context63.t3 = (0, _context63.t1)(_context63.t2);
                          _context63.t4 = gasRate;
                          _context63.t5 = _context63.t3 * _context63.t4;
                          return _context63.abrupt("return", _context63.t0.round.call(_context63.t0, _context63.t5));

                        case 10:
                        case "end":
                          return _context63.stop();
                      }
                    }
                  }, _callee63);
                }))();
              },
              sendTransaction: function sendTransaction() {
                var _arguments11 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee64() {
                  var tx, txHash;
                  return _regenerator.default.wrap(function _callee64$(_context64) {
                    while (1) {
                      switch (_context64.prev = _context64.next) {
                        case 0:
                          tx = _arguments11.length > 0 && _arguments11[0] !== undefined ? _arguments11[0] : config.defaultTx;
                          _context64.next = 3;
                          return config.eth.sendTransaction(_objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 3:
                          txHash = _context64.sent;

                          if (!tx.returnTxHash) {
                            _context64.next = 6;
                            break;
                          }

                          return _context64.abrupt("return", txHash);

                        case 6:
                          _context64.next = 8;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 8:
                          return _context64.abrupt("return", _context64.sent);

                        case 9:
                        case "end":
                          return _context64.stop();
                      }
                    }
                  }, _callee64);
                }))();
              },

              /**
               * Unbonds LPT from an address
               * @memberof livepeer~rpc
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.unbond(amount)
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              unbond: function unbond(amount) {
                var _arguments12 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee65() {
                  var tx, txHash;
                  return _regenerator.default.wrap(function _callee65$(_context65) {
                    while (1) {
                      switch (_context65.prev = _context65.next) {
                        case 0:
                          tx = _arguments12.length > 1 && _arguments12[1] !== undefined ? _arguments12[1] : config.defaultTx;
                          _context65.next = 3;
                          return BondingManager.unbond(amount, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 3:
                          txHash = _context65.sent;

                          if (!tx.returnTxHash) {
                            _context65.next = 6;
                            break;
                          }

                          return _context65.abrupt("return", txHash);

                        case 6:
                          _context65.next = 8;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 8:
                          return _context65.abrupt("return", _context65.sent);

                        case 9:
                        case "end":
                          return _context65.stop();
                      }
                    }
                  }, _callee65);
                }))();
              },

              /**
               * Unbonds LPT from an address with hint
               * @memberof livepeer~rpc
               * @param {string} amount
               * @param {string} newPosPrev
               * @param {string} newPosNext
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.unbondWithHint("100", "0x", "0x")
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              unbondWithHint: function unbondWithHint(amount, newPosPrev, newPosNext) {
                var _arguments13 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee66() {
                  var tx, txHash;
                  return _regenerator.default.wrap(function _callee66$(_context66) {
                    while (1) {
                      switch (_context66.prev = _context66.next) {
                        case 0:
                          tx = _arguments13.length > 3 && _arguments13[3] !== undefined ? _arguments13[3] : config.defaultTx;
                          _context66.next = 3;
                          return BondingManager.unbondWithHint(amount, newPosPrev, newPosNext, _objectSpread(_objectSpread({}, config.defaultTx), tx));

                        case 3:
                          txHash = _context66.sent;

                          if (!tx.returnTxHash) {
                            _context66.next = 6;
                            break;
                          }

                          return _context66.abrupt("return", txHash);

                        case 6:
                          _context66.next = 8;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 8:
                          return _context66.abrupt("return", _context66.sent);

                        case 9:
                        case "end":
                          return _context66.stop();
                      }
                    }
                  }, _callee66);
                }))();
              },

              /**
               * Sets transcoder parameters
               * @memberof livepeer~rpc
               * @param {string} rewardCut - the block reward cut you wish to set
               * @param {string} feeShare - the fee share you wish to set
               * @param {string} pricePerSegment - the price per segment you wish to set
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {Promise<TxReceipt>}
               *
               * @example
               *
               * await rpc.setupTranscoder('10', '10', '5')
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              setupTranscoder: function setupTranscoder(rewardCut, // percentage
              feeShare, // percentage
              pricePerSegment) {
                var _arguments14 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee67() {
                  var tx;
                  return _regenerator.default.wrap(function _callee67$(_context67) {
                    while (1) {
                      switch (_context67.prev = _context67.next) {
                        case 0:
                          tx = _arguments14.length > 3 && _arguments14[3] !== undefined ? _arguments14[3] : config.defaultTx;
                          _context67.t0 = utils;
                          _context67.next = 4;
                          return BondingManager.transcoder(toBN(rewardCut), toBN(feeShare), toBN(pricePerSegment), tx);

                        case 4:
                          _context67.t1 = _context67.sent;
                          _context67.t2 = config.eth;
                          _context67.next = 8;
                          return _context67.t0.getTxReceipt.call(_context67.t0, _context67.t1, _context67.t2);

                        case 8:
                          return _context67.abrupt("return", _context67.sent);

                        case 9:
                        case "end":
                          return _context67.stop();
                      }
                    }
                  }, _callee67);
                }))();
              },

              /**
               * Get target bonding rate
               * @memberof livepeer~rpc
               * @return {Promise<string>}
               *
               * @example
               *
               * await rpc.getTargetBondingRate()
               * // => string
               */
              getTargetBondingRate: function getTargetBondingRate() {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee68() {
                  return _regenerator.default.wrap(function _callee68$(_context68) {
                    while (1) {
                      switch (_context68.prev = _context68.next) {
                        case 0:
                          _context68.t0 = headToString;
                          _context68.next = 3;
                          return Minter.targetBondingRate();

                        case 3:
                          _context68.t1 = _context68.sent;
                          return _context68.abrupt("return", (0, _context68.t0)(_context68.t1));

                        case 5:
                        case "end":
                          return _context68.stop();
                      }
                    }
                  }, _callee68);
                }))();
              },

              /**
               * Withdraws earned token (Transfers a sender's delegator `bondedAmount` to their `tokenBalance`)
               * @memberof livepeer~rpc
               * @param {string} [unbondLockId] - the unbond lock id
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {TxReceipt}
               *
               * @example
               *
               * await rpc.withdrawStake()
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              withdrawStake: function withdrawStake(unbondLockId) {
                var _arguments15 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee69() {
                  var tx, id, txHash;
                  return _regenerator.default.wrap(function _callee69$(_context69) {
                    while (1) {
                      switch (_context69.prev = _context69.next) {
                        case 0:
                          tx = _arguments15.length > 1 && _arguments15[1] !== undefined ? _arguments15[1] : config.defaultTx;

                          if (!(typeof unbondLockId === 'undefined')) {
                            _context69.next = 3;
                            break;
                          }

                          throw new Error('missing argument unbondingLockId');

                        case 3:
                          id = toBN(unbondLockId);
                          _context69.next = 6;
                          return BondingManager.withdrawStake(toString(id), tx);

                        case 6:
                          txHash = _context69.sent;

                          if (!tx.returnTxHash) {
                            _context69.next = 9;
                            break;
                          }

                          return _context69.abrupt("return", txHash);

                        case 9:
                          _context69.next = 11;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 11:
                          return _context69.abrupt("return", _context69.sent);

                        case 12:
                        case "end":
                          return _context69.stop();
                      }
                    }
                  }, _callee69);
                }))();
              },

              /**
               * Withdraws earned token (Transfers a sender's delegator `bondedAmount` to their `tokenBalance`)
               * @memberof livepeer~rpc
               * @param {} [unbondlock] - an object specifying the unbondlock id, amount & withdrawRound
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {TxReceipt}
               *
               * @example
               *
               * await rpc.withdrawStakeWithUnbondLock(unbondlock)
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              withdrawStakeWithUnbondLock: function withdrawStakeWithUnbondLock(unbondlock) {
                var _arguments16 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee70() {
                  var tx, id, amount, withdrawRound, currentRound, unbondingLockId, txHash;
                  return _regenerator.default.wrap(function _callee70$(_context70) {
                    while (1) {
                      switch (_context70.prev = _context70.next) {
                        case 0:
                          tx = _arguments16.length > 1 && _arguments16[1] !== undefined ? _arguments16[1] : config.defaultTx;
                          id = unbondlock.id, amount = unbondlock.amount, withdrawRound = unbondlock.withdrawRound;
                          _context70.next = 4;
                          return rpc.getCurrentRound();

                        case 4:
                          currentRound = _context70.sent;

                          if (!(withdrawRound > currentRound)) {
                            _context70.next = 9;
                            break;
                          }

                          throw new Error('Delegator must wait through unbonding period');

                        case 9:
                          if (!(amount === '0')) {
                            _context70.next = 13;
                            break;
                          }

                          throw new Error('Delegator does not have anything to withdraw');

                        case 13:
                          if (!(amount < 0)) {
                            _context70.next = 15;
                            break;
                          }

                          throw new Error('Amount cannot be negative');

                        case 15:
                          unbondingLockId = toBN(id);
                          _context70.next = 18;
                          return BondingManager.withdrawStake(toString(unbondingLockId), tx);

                        case 18:
                          txHash = _context70.sent;

                          if (!tx.returnTxHash) {
                            _context70.next = 21;
                            break;
                          }

                          return _context70.abrupt("return", txHash);

                        case 21:
                          _context70.next = 23;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 23:
                          return _context70.abrupt("return", _context70.sent);

                        case 24:
                        case "end":
                          return _context70.stop();
                      }
                    }
                  }, _callee70);
                }))();
              },

              /**
               * Withdraws earned fees (Transfers a sender's delegator `fees` to their `ethBalance`)
               * @memberof livepeer~rpc
               * @param {TxConfig} [tx = config.defaultTx] - an object specifying the `from` and `gas` values of the transaction
               * @return {TxReceipt}
               *
               * @example
               *
               * await rpc.withdrawFees()
               * // => TxReceipt {
               * //   transactionHash: string,
               * //   transactionIndex": BN,
               * //   blockHash: string,
               * //   blockNumber: BN,
               * //   cumulativeGasUsed: BN,
               * //   gasUsed: BN,
               * //   contractAddress: string,
               * //   logs: Array<Log {
               * //     logIndex: BN,
               * //     blockNumber: BN,
               * //     blockHash: string,
               * //     transactionHash: string,
               * //     transactionIndex: string,
               * //     address: string,
               * //     data: string,
               * //     topics: Array<string>
               * //   }>
               * // }
               */
              withdrawFees: function withdrawFees() {
                var _arguments17 = arguments;
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee71() {
                  var tx, txHash;
                  return _regenerator.default.wrap(function _callee71$(_context71) {
                    while (1) {
                      switch (_context71.prev = _context71.next) {
                        case 0:
                          tx = _arguments17.length > 0 && _arguments17[0] !== undefined ? _arguments17[0] : config.defaultTx;
                          _context71.next = 3;
                          return BondingManager.withdrawFees(tx);

                        case 3:
                          txHash = _context71.sent;

                          if (!tx.returnTxHash) {
                            _context71.next = 6;
                            break;
                          }

                          return _context71.abrupt("return", txHash);

                        case 6:
                          _context71.next = 8;
                          return utils.getTxReceipt(txHash, config.eth);

                        case 8:
                          return _context71.abrupt("return", _context71.sent);

                        case 9:
                        case "end":
                          return _context71.stop();
                      }
                    }
                  }, _callee71);
                }))();
              },
              verifySnapshot: function verifySnapshot(id, proof, leafHash) {
                return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee72() {
                  return _regenerator.default.wrap(function _callee72$(_context72) {
                    while (1) {
                      switch (_context72.prev = _context72.next) {
                        case 0:
                          _context72.next = 2;
                          return MerkleSnapshot.verify(id, proof, leafHash);

                        case 2:
                          return _context72.abrupt("return", _context72.sent);

                        case 3:
                        case "end":
                          return _context72.stop();
                      }
                    }
                  }, _callee72);
                }))();
              }
            };
            return _context73.abrupt("return", {
              create: createLivepeerSDK,
              config: config,
              rpc: rpc,
              utils: utils,
              events: events,
              constants: {
                ADDRESS_PAD: ADDRESS_PAD,
                EMPTY_ADDRESS: EMPTY_ADDRESS,
                DELEGATOR_STATUS: DELEGATOR_STATUS,
                TRANSCODER_STATUS: TRANSCODER_STATUS,
                VIDEO_PROFILE_ID_SIZE: VIDEO_PROFILE_ID_SIZE,
                VIDEO_PROFILES: _video_profiles.VIDEO_PROFILES
              }
            });

          case 11:
          case "end":
            return _context73.stop();
        }
      }
    }, _callee73);
  }));
  return _createLivepeerSDK.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJFTVBUWV9BRERSRVNTIiwiQUREUkVTU19QQUQiLCJWSURFT19QUk9GSUxFX0lEX1NJWkUiLCJERUxFR0FUT1JfU1RBVFVTIiwiUGVuZGluZyIsIkJvbmRlZCIsIlVuYm9uZGVkIiwiVW5ib25kaW5nIiwiVFJBTlNDT0RFUl9TVEFUVVMiLCJOb3RSZWdpc3RlcmVkIiwiUmVnaXN0ZXJlZCIsIkRFRkFVTFRTIiwiY29udHJvbGxlckFkZHJlc3MiLCJwb2xsQ3JlYXRvckFkZHJlc3MiLCJwcm92aWRlciIsInByb2Nlc3MiLCJlbnYiLCJJTkZVUkFfRU5EUE9JTlQiLCJwcml2YXRlS2V5cyIsImFjY291bnQiLCJnYXMiLCJhcnRpZmFjdHMiLCJMaXZlcGVlclRva2VuIiwiTGl2ZXBlZXJUb2tlbkFydGlmYWN0IiwiTGl2ZXBlZXJUb2tlbkZhdWNldCIsIkxpdmVwZWVyVG9rZW5GYXVjZXRBcnRpZmFjdCIsIkNvbnRyb2xsZXIiLCJDb250cm9sbGVyQXJ0aWZhY3QiLCJSb3VuZHNNYW5hZ2VyIiwiUm91bmRzTWFuYWdlckFydGlmYWN0IiwiQm9uZGluZ01hbmFnZXIiLCJCb25kaW5nTWFuYWdlckFydGlmYWN0IiwiTWludGVyIiwiTWludGVyQXJ0aWZhY3QiLCJQb2xsQ3JlYXRvciIsIlBvbGxDcmVhdG9yQXJ0aWZhY3QiLCJQb2xsIiwiUG9sbEFydGlmYWN0IiwiTWVya2xlU25hcHNob3QiLCJNZXJrbGVTbmFwc2hvdEFydGlmYWN0IiwiZW5zUmVnaXN0cmllcyIsInV0aWxzIiwiaXNWYWxpZEFkZHJlc3MiLCJ4IiwidGVzdCIsInJlc29sdmVBZGRyZXNzIiwicmVzb2x2ZSIsImdldE1ldGhvZEhhc2giLCJpdGVtIiwiZmluZEFiaUJ5TmFtZSIsImFiaXMiLCJuYW1lIiwiZmlsdGVyIiwidHlwZSIsImFiaSIsImZpbmRBYmlCeUhhc2giLCJoYXNoIiwiZW5jb2RlTWV0aG9kUGFyYW1zIiwicGFyYW1zIiwiZGVjb2RlTWV0aG9kUGFyYW1zIiwiYnl0ZWNvZGUiLCJpbnB1dHMiLCJtYXAiLCJzdWJzdHIiLCJkZWNvZGVDb250cmFjdElucHV0IiwiY29udHJhY3RzIiwiY29udHJhY3RBZGRyZXNzIiwiaW5wdXQiLCJrZXkiLCJjb250cmFjdCIsImFkZHJlc3MiLCJzdWJzdHJpbmciLCJtZXRob2QiLCJPYmplY3QiLCJlbnRyaWVzIiwicmVkdWNlIiwib2JqIiwiayIsInYiLCJBcnJheSIsImlzQXJyYXkiLCJfdiIsIkJOIiwiaXNCTiIsInRvU3RyaW5nIiwiZ2V0VHhSZWNlaXB0IiwidHhIYXNoIiwiZXRoIiwiUHJvbWlzZSIsInJlamVjdCIsInNldFRpbWVvdXQiLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJyZWNlaXB0Iiwic3RhdHVzIiwiRXJyb3IiLCJKU09OIiwiZ2V0VHJhbnNhY3Rpb25CeUhhc2giLCJ0cmFuc2FjdGlvbkhhc2giLCJ0cmFuc2FjdGlvbiIsInN0cmluZ2lmeSIsInBvbGxGb3JSZWNlaXB0IiwicGFyc2VUcmFuc2NvZGluZ09wdGlvbnMiLCJvcHRzIiwicHJvZmlsZXMiLCJ2YWx1ZXMiLCJWSURFT19QUk9GSUxFUyIsInZhbGlkSGFzaGVzIiwiU2V0IiwiaGFzaGVzIiwiaSIsImxlbmd0aCIsInNsaWNlIiwiaGFzIiwicHVzaCIsImZpbmQiLCJzZXJpYWxpemVUcmFuc2NvZGluZ1Byb2ZpbGVzIiwibmFtZXMiLCJQMjQwcDMwZnBzNHgzIiwiam9pbiIsInBhZEFkZHJlc3MiLCJhZGRyIiwiZW5jb2RlRXZlbnRUb3BpY3MiLCJldmVudCIsImZpbHRlcnMiLCJ0b3BpY3MiLCJpbmRleGVkIiwiaGFzT3duUHJvcGVydHkiLCJvcHRpb25zIiwiZGVmYXVsdEZpbHRlck9iamVjdCIsImRlY29kZUV2ZW50IiwiZGF0YSIsIkV0aCIsInRvQk4iLCJuIiwiY29tcG9zZSIsImZucyIsImYiLCJnIiwicHJvcCIsInRvQm9vbCIsInRvTnVtYmVyIiwiTnVtYmVyIiwiaGVhZFRvQm9vbCIsImhlYWRUb1N0cmluZyIsImhlYWRUb051bWJlciIsImludmFyaWFudCIsInBvcyIsImZvcm1hdER1cmF0aW9uIiwibXMiLCJzZWNvbmRzIiwidG9GaXhlZCIsIm1pbnV0ZXMiLCJob3VycyIsImRheXMiLCJkZXBsb3lDb250cmFjdCIsImRlZmF1bHRUeCIsIm5ldyIsImdldFRyYW5zYWN0aW9uU3VjY2VzcyIsImF0IiwiZ2V0Q29udHJhY3RBdCIsImluaXRSUEMiLCJ1c2VQcml2YXRlS2V5cyIsImtleXMiLCJldGhqc1Byb3ZpZGVyIiwiU2lnbmVyUHJvdmlkZXIiLCJzaWduVHJhbnNhY3Rpb24iLCJyYXdUeCIsImNiIiwidHgiLCJFdGhlcmV1bVR4Iiwic2lnbiIsImZyb20iLCJzZXJpYWxpemUiLCJhY2NvdW50cyIsInRpbWVvdXQiLCJIdHRwUHJvdmlkZXIiLCJFTlMiLCJjdXJyZW50UHJvdmlkZXIiLCJuZXRfdmVyc2lvbiIsInJlZ2lzdHJ5QWRkcmVzcyIsImVucyIsImluaXRDb250cmFjdHMiLCJrZWNjYWsyNTYiLCJnZXRDb250cmFjdCIsImEiLCJiIiwiZXZlbnRzIiwiY3JlYXRlTGl2ZXBlZXJTREsiLCJjb25maWciLCJjYWNoZSIsInJwYyIsImdldEVOU05hbWUiLCJyZXZlcnNlIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0RU5TQWRkcmVzcyIsImxvb2t1cCIsImdldEJsb2NrIiwiaWQiLCJzdGFydHNXaXRoIiwiZ2V0QmxvY2tCeUhhc2giLCJnZXRCbG9ja0J5TnVtYmVyIiwiYmxvY2siLCJkaWZmaWN1bHR5IiwiZ2FzTGltaXQiLCJnYXNVc2VkIiwibnVtYmVyIiwic2l6ZSIsInRpbWVzdGFtcCIsInRvdGFsRGlmZmljdWx0eSIsImdldEV0aEJhbGFuY2UiLCJnZXRCYWxhbmNlIiwiZ2V0VW5ib25kaW5nUGVyaW9kIiwidW5ib25kaW5nUGVyaW9kIiwiZ2V0TnVtQWN0aXZlVHJhbnNjb2RlcnMiLCJudW1BY3RpdmVUcmFuc2NvZGVycyIsImdldE1heEVhcm5pbmdzQ2xhaW1zUm91bmRzIiwibWF4RWFybmluZ3NDbGFpbXNSb3VuZHMiLCJnZXRUb3RhbEJvbmRlZCIsImdldFRva2VuVG90YWxTdXBwbHkiLCJ0b3RhbFN1cHBseSIsImdldFRva2VuQmFsYW5jZSIsImJhbGFuY2VPZiIsImdldFRva2VuSW5mbyIsImJhbGFuY2UiLCJ0cmFuc2ZlclRva2VuIiwidG8iLCJhbW91bnQiLCJ2YWx1ZSIsImd0ZSIsInRyYW5zZmVyIiwiZ2V0RmF1Y2V0QW1vdW50IiwicmVxdWVzdEFtb3VudCIsImdldEZhdWNldFdhaXQiLCJyZXF1ZXN0V2FpdCIsImdldEZhdWNldE5leHQiLCJuZXh0VmFsaWRSZXF1ZXN0IiwiZ2V0RmF1Y2V0SW5mbyIsIndhaXQiLCJuZXh0IiwiZ2V0SW5mbGF0aW9uIiwiaW5mbGF0aW9uIiwiZ2V0SW5mbGF0aW9uQ2hhbmdlIiwiaW5mbGF0aW9uQ2hhbmdlIiwiZ2V0RGVsZWdhdG9yU3RhdHVzIiwiZGVsZWdhdG9yU3RhdHVzIiwiZ2V0RGVsZWdhdG9yIiwiYWxsb3dhbmNlIiwicG9sbENyZWF0b3JBbGxvd2FuY2UiLCJnZXRDdXJyZW50Um91bmQiLCJjdXJyZW50Um91bmQiLCJwZW5kaW5nU3Rha2UiLCJwZW5kaW5nRmVlcyIsImQiLCJib25kZWRBbW91bnQiLCJmZWVzIiwiZGVsZWdhdGVBZGRyZXNzIiwiZGVsZWdhdGVkQW1vdW50IiwibGFzdENsYWltUm91bmQiLCJzdGFydFJvdW5kIiwibmV4dFVuYm9uZGluZ0xvY2tJZCIsInVuYm9uZGluZ0xvY2tJZCIsImNtcCIsInN1YiIsImdldERlbGVnYXRvclVuYm9uZGluZ0xvY2siLCJ3aXRoZHJhd0Ftb3VudCIsIndpdGhkcmF3Um91bmQiLCJnZXREZWxlZ2F0b3JVbmJvbmRpbmdMb2NrcyIsInJlc3VsdCIsInVuYm9uZCIsImxvY2siLCJkZWxlZ2F0b3IiLCJyZWJvbmQiLCJyZXR1cm5UeEhhc2giLCJyZWJvbmRXaXRoSGludCIsIm5ld1Bvc1ByZXYiLCJuZXdQb3NOZXh0IiwicmVib25kRnJvbVVuYm9uZGVkIiwicmVib25kRnJvbVVuYm9uZGVkV2l0aEhpbnQiLCJnZXRQZW5kaW5nU3Rha2UiLCJlbmRSb3VuZCIsImdldFBlbmRpbmdGZWVzIiwiZ2V0VHJhbnNjb2RlcklzQWN0aXZlIiwiaXNBY3RpdmVUcmFuc2NvZGVyIiwiZ2V0VHJhbnNjb2RlclN0YXR1cyIsInRyYW5zY29kZXJTdGF0dXMiLCJnZXRUcmFuc2NvZGVyVG90YWxTdGFrZSIsInRyYW5zY29kZXJUb3RhbFN0YWtlIiwiZ2V0VHJhbnNjb2RlclBvb2xNYXhTaXplIiwiZ2V0VHJhbnNjb2RlciIsInRvdGFsU3Rha2UiLCJ0IiwiZmVlU2hhcmUiLCJsYXN0UmV3YXJkUm91bmQiLCJyZXdhcmRDdXQiLCJhY3RpdmF0aW9uUm91bmQiLCJkZWFjdGl2YXRpb25Sb3VuZCIsImxhc3RBY3RpdmVTdGFrZVVwZGF0ZVJvdW5kIiwiZ2V0VHJhbnNjb2RlcnMiLCJ0cmFuc2NvZGVycyIsImdldEZpcnN0VHJhbnNjb2RlckluUG9vbCIsInRyYW5zY29kZXIiLCJnZXROZXh0VHJhbnNjb2RlckluUG9vbCIsImdldFByb3RvY29sUGF1c2VkIiwicGF1c2VkIiwiZ2V0UHJvdG9jb2wiLCJ0b3RhbFRva2VuU3VwcGx5IiwidG90YWxCb25kZWRUb2tlbiIsImdldFRhcmdldEJvbmRpbmdSYXRlIiwidGFyZ2V0Qm9uZGluZ1JhdGUiLCJ0cmFuc2NvZGVyUG9vbE1heFNpemUiLCJnZXRSb3VuZExlbmd0aCIsInJvdW5kTGVuZ3RoIiwiZ2V0Um91bmRzUGVyWWVhciIsInJvdW5kc1BlclllYXIiLCJnZXRDdXJyZW50Um91bmRJc0luaXRpYWxpemVkIiwiY3VycmVudFJvdW5kSW5pdGlhbGl6ZWQiLCJnZXRDdXJyZW50Um91bmRTdGFydEJsb2NrIiwiY3VycmVudFJvdW5kU3RhcnRCbG9jayIsImdldExhc3RJbml0aWFsaXplZFJvdW5kIiwibGFzdEluaXRpYWxpemVkUm91bmQiLCJnZXRDdXJyZW50Um91bmRJbmZvIiwiaW5pdGlhbGl6ZWQiLCJzdGFydEJsb2NrIiwiZ2V0TGlwVXBncmFkZVJvdW5kIiwibGlwTnVtYmVyIiwibGlwVXBncmFkZVJvdW5kIiwidGFwRmF1Y2V0IiwicmVxdWVzdCIsImluaXRpYWxpemVSb3VuZCIsImFwcHJvdmVUb2tlblBvbGxDcmVhdGlvbkNvc3QiLCJ0b2tlbiIsImFwcHJvdmUiLCJjcmVhdGVQb2xsIiwicHJvcG9zYWwiLCJnZXRQb2xsQ3JlYXRvckFsbG93YW5jZSIsImdldEJvbmRpbmdNYW5hZ2VyQWxsb3dhbmNlIiwidm90ZSIsInBvbGxBZGRyZXNzIiwiY2hvaWNlSWQiLCJjbGFpbUVhcm5pbmdzIiwiYXBwcm92ZVRva2VuQm9uZEFtb3VudCIsImJvbmRBcHByb3ZlZFRva2VuQW1vdW50IiwiYm9uZCIsImJvbmRXaXRoSGludCIsIm9sZERlbGVnYXRlTmV3UG9zUHJldiIsIm9sZERlbGVnYXRlTmV3UG9zTmV4dCIsImN1cnJEZWxlZ2F0ZU5ld1Bvc1ByZXYiLCJjdXJyRGVsZWdhdGVOZXdQb3NOZXh0IiwiZXN0aW1hdGVHYXMiLCJjb250cmFjdE5hbWUiLCJtZXRob2ROYW1lIiwibWV0aG9kQXJncyIsImdhc1JhdGUiLCJjb250cmFjdEFCSSIsIm1ldGhvZEFCSSIsImVuY29kZWREYXRhIiwiTWF0aCIsInJvdW5kIiwiZ2V0Q2FsbGRhdGEiLCJlc3RpbWF0ZUdhc1JhdyIsInNlbmRUcmFuc2FjdGlvbiIsInVuYm9uZFdpdGhIaW50Iiwic2V0dXBUcmFuc2NvZGVyIiwicHJpY2VQZXJTZWdtZW50Iiwid2l0aGRyYXdTdGFrZSIsInVuYm9uZExvY2tJZCIsIndpdGhkcmF3U3Rha2VXaXRoVW5ib25kTG9jayIsInVuYm9uZGxvY2siLCJ3aXRoZHJhd0ZlZXMiLCJ2ZXJpZnlTbmFwc2hvdCIsInByb29mIiwibGVhZkhhc2giLCJ2ZXJpZnkiLCJjcmVhdGUiLCJjb25zdGFudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFNQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBS08sSUFBTUEsYUFBYSxHQUFHLDRDQUF0Qjs7QUFDQSxJQUFNQyxXQUFXLEdBQUcsNEJBQXBCOztBQUNBLElBQU1DLHFCQUFxQixHQUFHLENBQTlCOztBQUVQLElBQU1DLGdCQUFnQixHQUFHLENBQUMsU0FBRCxFQUFZLFFBQVosRUFBc0IsVUFBdEIsRUFBa0MsV0FBbEMsQ0FBekI7O0FBQ0FBLGdCQUFnQixDQUFDQyxPQUFqQixHQUEyQkQsZ0JBQWdCLENBQUMsQ0FBRCxDQUEzQztBQUNBQSxnQkFBZ0IsQ0FBQ0UsTUFBakIsR0FBMEJGLGdCQUFnQixDQUFDLENBQUQsQ0FBMUM7QUFDQUEsZ0JBQWdCLENBQUNHLFFBQWpCLEdBQTRCSCxnQkFBZ0IsQ0FBQyxDQUFELENBQTVDO0FBQ0FBLGdCQUFnQixDQUFDSSxTQUFqQixHQUE2QkosZ0JBQWdCLENBQUMsQ0FBRCxDQUE3QztBQUVBLElBQU1LLGlCQUFpQixHQUFHLENBQUMsZUFBRCxFQUFrQixZQUFsQixDQUExQjs7QUFDQUEsaUJBQWlCLENBQUNDLGFBQWxCLEdBQWtDRCxpQkFBaUIsQ0FBQyxDQUFELENBQW5EO0FBQ0FBLGlCQUFpQixDQUFDRSxVQUFsQixHQUErQkYsaUJBQWlCLENBQUMsQ0FBRCxDQUFoRDtBQUdBO0FBQ08sSUFBTUcsUUFBUSxHQUFHO0FBQ3RCQyxFQUFBQSxpQkFBaUIsRUFBRSw0Q0FERztBQUV0QkMsRUFBQUEsa0JBQWtCLEVBQUUsNENBRkU7QUFHdEJDLEVBQUFBLFFBQVEsRUFBRUMsT0FBTyxDQUFDQyxHQUFSLENBQVlDLGVBSEE7QUFJdEJDLEVBQUFBLFdBQVcsRUFBRSxFQUpTO0FBSUw7QUFDakJDLEVBQUFBLE9BQU8sRUFBRSxFQUxhO0FBTXRCQyxFQUFBQSxHQUFHLEVBQUUsSUFOaUI7QUFPdEJDLEVBQUFBLFNBQVMsRUFBRTtBQUNUQyxJQUFBQSxhQUFhLEVBQUVDLHNCQUROO0FBRVRDLElBQUFBLG1CQUFtQixFQUFFQyw0QkFGWjtBQUdUQyxJQUFBQSxVQUFVLEVBQUVDLG1CQUhIO0FBSVRDLElBQUFBLGFBQWEsRUFBRUMsc0JBSk47QUFLVEMsSUFBQUEsY0FBYyxFQUFFQyx1QkFMUDtBQU1UQyxJQUFBQSxNQUFNLEVBQUVDLGVBTkM7QUFPVEMsSUFBQUEsV0FBVyxFQUFFQyxvQkFQSjtBQVFUQyxJQUFBQSxJQUFJLEVBQUVDLGFBUkc7QUFTVEMsSUFBQUEsY0FBYyxFQUFFQztBQVRQLEdBUFc7QUFrQnRCQyxFQUFBQSxhQUFhLEVBQUU7QUFDYjtBQUNBLE9BQUcsNENBRlU7QUFHYjtBQUNBLE9BQUcsNENBSlU7QUFLYjtBQUNBLE9BQUc7QUFOVTtBQWxCTyxDQUFqQixDLENBNEJQOzs7QUFDTyxJQUFNQyxLQUFLLEdBQUc7QUFDbkJDLEVBQUFBLGNBQWMsRUFBRSx3QkFBQ0MsQ0FBRDtBQUFBLFdBQU8sc0JBQXNCQyxJQUF0QixDQUEyQkQsQ0FBM0IsQ0FBUDtBQUFBLEdBREc7QUFFbkJFLEVBQUFBLGNBQWM7QUFBQSxrR0FBRSxpQkFBT0MsT0FBUCxFQUFnQkgsQ0FBaEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUNkRixLQUFLLENBQUNDLGNBQU4sQ0FBcUJDLENBQXJCLENBRGM7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNEJBQ1lBLENBRFo7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxxQkFDc0JHLE9BQU8sQ0FBQ0gsQ0FBRCxDQUQ3Qjs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBRjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxLQUZLO0FBSW5CSSxFQUFBQSxhQUFhLEVBQUUsdUJBQUNDLElBQUQsRUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxXQUFPLCtCQUFnQkEsSUFBaEIsQ0FBUDtBQUNELEdBVGtCO0FBVW5CQyxFQUFBQSxhQUFhLEVBQUUsdUJBQUNDLElBQUQsRUFBT0MsSUFBUCxFQUFnQjtBQUFBLHVCQUNmRCxJQUFJLENBQUNFLE1BQUwsQ0FBWSxVQUFDSixJQUFELEVBQVU7QUFDbEMsVUFBSUEsSUFBSSxDQUFDSyxJQUFMLEtBQWMsVUFBbEIsRUFBOEIsT0FBTyxLQUFQO0FBQzlCLFVBQUlMLElBQUksQ0FBQ0csSUFBTCxLQUFjQSxJQUFsQixFQUF3QixPQUFPLElBQVA7QUFDekIsS0FIYSxDQURlO0FBQUE7QUFBQSxRQUN0QkcsR0FEc0I7O0FBSzdCLFdBQU9BLEdBQVA7QUFDRCxHQWhCa0I7QUFpQm5CQyxFQUFBQSxhQUFhLEVBQUUsdUJBQUNMLElBQUQsRUFBT00sSUFBUCxFQUFnQjtBQUFBLHdCQUNmTixJQUFJLENBQUNFLE1BQUwsQ0FBWSxVQUFDSixJQUFELEVBQVU7QUFDbEMsVUFBSUEsSUFBSSxDQUFDSyxJQUFMLEtBQWMsVUFBbEIsRUFBOEIsT0FBTyxLQUFQO0FBQzlCLGFBQU8sK0JBQWdCTCxJQUFoQixNQUEwQlEsSUFBakM7QUFDRCxLQUhhLENBRGU7QUFBQTtBQUFBLFFBQ3RCRixHQURzQjs7QUFLN0IsV0FBT0EsR0FBUDtBQUNELEdBdkJrQjtBQXdCbkJHLEVBQUFBLGtCQUFrQixFQUFFLDRCQUFDSCxHQUFELEVBQU1JLE1BQU4sRUFBaUI7QUFDbkMsV0FBTyw0QkFBYUosR0FBYixFQUFrQkksTUFBbEIsQ0FBUDtBQUNELEdBMUJrQjtBQTJCbkJDLEVBQUFBLGtCQUFrQixFQUFFLDRCQUFDTCxHQUFELEVBQU1NLFFBQU4sRUFBbUI7QUFDckMsV0FBTyw0QkFDTE4sR0FBRyxDQUFDTyxNQUFKLENBQVdDLEdBQVgsQ0FBZSxVQUFDbkIsQ0FBRDtBQUFBLGFBQU9BLENBQUMsQ0FBQ1EsSUFBVDtBQUFBLEtBQWYsQ0FESyxFQUVMRyxHQUFHLENBQUNPLE1BQUosQ0FBV0MsR0FBWCxDQUFlLFVBQUNuQixDQUFEO0FBQUEsYUFBT0EsQ0FBQyxDQUFDVSxJQUFUO0FBQUEsS0FBZixDQUZLLGNBR0FPLFFBQVEsQ0FBQ0csTUFBVCxDQUFnQixFQUFoQixDQUhBLEdBSUwsS0FKSyxDQUFQO0FBTUQsR0FsQ2tCO0FBbUNuQkMsRUFBQUEsbUJBQW1CLEVBQUUsNkJBQUNDLFNBQUQsRUFBWUMsZUFBWixFQUE2QkMsS0FBN0IsRUFBdUM7QUFDMUQsU0FBSyxJQUFNQyxHQUFYLElBQWtCSCxTQUFsQixFQUE2QjtBQUMzQixVQUFNSSxRQUFRLEdBQUdKLFNBQVMsQ0FBQ0csR0FBRCxDQUExQjtBQUNBLFVBQUlDLFFBQVEsQ0FBQ0MsT0FBVCxLQUFxQkosZUFBekIsRUFBMEM7QUFDMUMsVUFBTVYsSUFBSSxHQUFHVyxLQUFLLENBQUNJLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIsRUFBbkIsQ0FBYjtBQUNBLFVBQU1qQixHQUFHLEdBQUdiLEtBQUssQ0FBQ2MsYUFBTixDQUFvQmMsUUFBUSxDQUFDZixHQUE3QixFQUFrQ0UsSUFBbEMsQ0FBWjtBQUNBLGFBQU87QUFDTGEsUUFBQUEsUUFBUSxFQUFFRCxHQURMO0FBRUxJLFFBQUFBLE1BQU0sRUFBRWxCLEdBQUcsQ0FBQ0gsSUFGUDtBQUdMTyxRQUFBQSxNQUFNLEVBQUVlLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlakMsS0FBSyxDQUFDa0Isa0JBQU4sQ0FBeUJMLEdBQXpCLEVBQThCYSxLQUE5QixDQUFmLEVBQXFEUSxNQUFyRCxDQUNOLFVBQUNDLEdBQUQsUUFBaUI7QUFBQTtBQUFBLGNBQVZDLENBQVU7QUFBQSxjQUFQQyxDQUFPOztBQUNmLGlEQUNLRixHQURMLHlDQUVHQyxDQUZILEVBRU9FLEtBQUssQ0FBQ0MsT0FBTixDQUFjRixDQUFkLElBQ0RBLENBQUMsQ0FBQ2hCLEdBQUYsQ0FBTSxVQUFDbUIsRUFBRDtBQUFBLG1CQUFTQyxFQUFFLENBQUNDLElBQUgsQ0FBUUYsRUFBUixJQUFjRyxRQUFRLENBQUNILEVBQUQsQ0FBdEIsR0FBNkJBLEVBQXRDO0FBQUEsV0FBTixDQURDLEdBRURDLEVBQUUsQ0FBQ0MsSUFBSCxDQUFRTCxDQUFSLElBQ0FNLFFBQVEsQ0FBQ04sQ0FBRCxDQURSLEdBRUFBLENBTk47QUFRRCxTQVZLLEVBV04sRUFYTTtBQUhILE9BQVA7QUFpQkQ7O0FBQ0QsV0FBTztBQUFFVCxNQUFBQSxRQUFRLEVBQUUsRUFBWjtBQUFnQkcsTUFBQUEsTUFBTSxFQUFFLEVBQXhCO0FBQTRCZCxNQUFBQSxNQUFNLEVBQUU7QUFBcEMsS0FBUDtBQUNELEdBNURrQjs7QUE2RG5COzs7Ozs7O0FBT0EyQixFQUFBQSxZQUFZO0FBQUEsZ0dBQUUsa0JBQU9DLE1BQVAsRUFBZUMsR0FBZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFDQyxJQUFJQyxPQUFKLENBQVksVUFBQzFDLE9BQUQsRUFBVTJDLE1BQVYsRUFBcUI7QUFDNUNDLGdCQUFBQSxVQUFVO0FBQUEsZ0hBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1DQUVlSCxHQUFHLENBQUNJLHFCQUFKLENBQTBCTCxNQUExQixDQUZmOztBQUFBO0FBRURNLDRCQUFBQSxPQUZDOztBQUFBLGlDQUdIQSxPQUhHO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtDQUlFQSxPQUFPLENBQUNDLE1BQVIsS0FBbUIsS0FKckI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsMkNBS0Q7QUFDQS9DLDRCQUFBQSxPQUFPLENBQUM4QyxPQUFELENBTk47QUFBQTtBQUFBOztBQUFBO0FBQUEsMkNBUURILE1BUkM7QUFBQSwyQ0FTS0ssS0FUTDtBQUFBLDJDQVVHQyxJQVZIO0FBQUEsMkNBWU9ILE9BWlA7QUFBQTtBQUFBLG1DQWEwQkwsR0FBRyxDQUFDUyxvQkFBSixDQUNqQkosT0FBTyxDQUFDSyxlQURTLENBYjFCOztBQUFBO0FBQUE7QUFBQTtBQVlPTCw4QkFBQUEsT0FaUDtBQWFPTSw4QkFBQUEsV0FiUDtBQUFBO0FBQUEsd0RBVVFDLFNBVlIsa0NBaUJLLElBakJMLEVBa0JLLENBbEJMO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBdUJQVCw0QkFBQUEsVUFBVSxDQUFDVSxjQUFELEVBQWlCLEdBQWpCLENBQVY7QUF2Qk87QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUF5QlBYLDRCQUFBQSxNQUFNLGNBQU47O0FBekJPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUFEOztBQUFBLDJCQUFnQlcsY0FBaEI7QUFBQTtBQUFBOztBQUFBLHlCQUFnQkEsY0FBaEI7QUFBQSxxQkEyQlAsQ0EzQk8sQ0FBVjtBQTRCRCxlQTdCWSxDQUREOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBRjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxLQXBFTzs7QUFvR25COzs7Ozs7QUFNQUMsRUFBQUEsdUJBQXVCLEVBQUUsaUNBQUNDLElBQUQsRUFBVTtBQUNqQyxRQUFNQyxRQUFRLEdBQUc5QixNQUFNLENBQUMrQixNQUFQLENBQWNDLDhCQUFkLENBQWpCO0FBQ0EsUUFBTUMsV0FBVyxHQUFHLElBQUlDLEdBQUosQ0FBUUosUUFBUSxDQUFDekMsR0FBVCxDQUFhLFVBQUNuQixDQUFEO0FBQUEsYUFBT0EsQ0FBQyxDQUFDYSxJQUFUO0FBQUEsS0FBYixDQUFSLENBQXBCO0FBQ0EsUUFBSW9ELE1BQU0sR0FBRyxFQUFiOztBQUNBLFNBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR1AsSUFBSSxDQUFDUSxNQUF6QixFQUFpQ0QsQ0FBQyxJQUFJM0cscUJBQXRDLEVBQTZEO0FBQzNELFVBQU1zRCxJQUFJLEdBQUc4QyxJQUFJLENBQUNTLEtBQUwsQ0FBV0YsQ0FBWCxFQUFjQSxDQUFDLEdBQUczRyxxQkFBbEIsQ0FBYjtBQUNBLFVBQUksQ0FBQ3dHLFdBQVcsQ0FBQ00sR0FBWixDQUFnQnhELElBQWhCLENBQUwsRUFBNEI7QUFDNUJvRCxNQUFBQSxNQUFNLENBQUNLLElBQVAsQ0FBWXpELElBQVo7QUFDRDs7QUFDRCxXQUFPb0QsTUFBTSxDQUFDOUMsR0FBUCxDQUFXLFVBQUNuQixDQUFEO0FBQUEsYUFBTzRELFFBQVEsQ0FBQ1csSUFBVCxDQUFjO0FBQUEsWUFBRzFELElBQUgsU0FBR0EsSUFBSDtBQUFBLGVBQWNiLENBQUMsS0FBS2EsSUFBcEI7QUFBQSxPQUFkLENBQVA7QUFBQSxLQUFYLENBQVA7QUFDRCxHQXBIa0I7O0FBcUhuQjs7Ozs7O0FBTUEyRCxFQUFBQSw0QkFBNEIsRUFBRSxzQ0FBQ0MsS0FBRCxFQUFXO0FBQ3ZDLFdBQU8saUNBQ0YsSUFBSVQsR0FBSixFQUFTO0FBQ1ZTLElBQUFBLEtBQUssQ0FBQ3RELEdBQU4sQ0FBVSxVQUFDbkIsQ0FBRDtBQUFBLGFBQ1I4RCwrQkFBZTlELENBQWYsSUFDSThELCtCQUFlOUQsQ0FBZixFQUFrQmEsSUFEdEIsR0FFSWlELCtCQUFlWSxhQUFmLENBQTZCN0QsSUFIekI7QUFBQSxLQUFWLENBREMsQ0FERSxFQVFMOEQsSUFSSyxDQVFBLEVBUkEsQ0FBUDtBQVNELEdBcklrQjs7QUFzSW5COzs7Ozs7QUFNQUMsRUFBQUEsVUFBVSxFQUFFLG9CQUFDQyxJQUFEO0FBQUEsV0FBVXZILFdBQVcsR0FBR3VILElBQUksQ0FBQ3pELE1BQUwsQ0FBWSxDQUFaLENBQXhCO0FBQUEsR0E1SU87O0FBNkluQjs7Ozs7OztBQU9BMEQsRUFBQUEsaUJBQWlCLEVBQUUsMkJBQUNDLEtBQUQsRUFBUUMsT0FBUixFQUFvQjtBQUNyQyxXQUFPRCxLQUFLLENBQUNwRSxHQUFOLENBQVVPLE1BQVYsQ0FBaUJjLE1BQWpCLENBQ0wsVUFBQ2lELE1BQUQsU0FBa0NmLENBQWxDLEVBQXdDO0FBQUEsVUFBN0JnQixPQUE2QixTQUE3QkEsT0FBNkI7QUFBQSxVQUFwQjFFLElBQW9CLFNBQXBCQSxJQUFvQjtBQUFBLFVBQWRFLElBQWMsU0FBZEEsSUFBYztBQUN0QyxVQUFJLENBQUN3RSxPQUFMLEVBQWMsT0FBT0QsTUFBUDtBQUNkLFVBQUksQ0FBQ0QsT0FBTyxDQUFDRyxjQUFSLENBQXVCM0UsSUFBdkIsQ0FBTCxFQUFtQyxrREFBV3lFLE1BQVgsSUFBbUIsSUFBbkI7QUFDbkMsVUFBSXZFLElBQUksS0FBSyxTQUFULElBQXNCLGFBQWEsT0FBT3NFLE9BQU8sQ0FBQ3hFLElBQUQsQ0FBckQsRUFDRSxrREFBV3lFLE1BQVgsSUFBbUJuRixLQUFLLENBQUM4RSxVQUFOLENBQWlCSSxPQUFPLENBQUN4RSxJQUFELENBQXhCLENBQW5CO0FBQ0Ysd0RBQVd5RSxNQUFYLElBQW1CRCxPQUFPLENBQUN4RSxJQUFELENBQTFCO0FBQ0QsS0FQSSxFQVFMLENBQUN1RSxLQUFLLEdBQUdLLE9BQVIsQ0FBZ0JDLG1CQUFoQixDQUFvQ0osTUFBcEMsQ0FBMkMsQ0FBM0MsQ0FBRCxDQVJLLENBQVA7QUFVRCxHQS9Ka0I7O0FBZ0tuQjs7Ozs7Ozs7QUFRQUssRUFBQUEsV0FBVyxFQUFFLHFCQUFDUCxLQUFEO0FBQUEsV0FBVyxpQkFBc0I7QUFBQSxVQUFuQlEsSUFBbUIsU0FBbkJBLElBQW1CO0FBQUEsVUFBYk4sTUFBYSxTQUFiQSxNQUFhO0FBQzVDLGFBQU8sMkJBQVlGLEtBQUssQ0FBQ3BFLEdBQWxCLEVBQXVCNEUsSUFBdkIsRUFBNkJOLE1BQTdCLEVBQXFDLEtBQXJDLENBQVA7QUFDRCxLQUZZO0FBQUE7QUF4S00sQ0FBZCxDLENBNktQO0FBQ0E7QUFDQTs7O0lBQ1ExQyxFLEdBQU9pRCxjLENBQVBqRCxFOztBQUNSLElBQU1rRCxJQUFJLEdBQUcsU0FBUEEsSUFBTyxDQUFDQyxDQUFEO0FBQUEsU0FBUW5ELEVBQUUsQ0FBQ0MsSUFBSCxDQUFRa0QsQ0FBUixJQUFhQSxDQUFiLEdBQWlCLElBQUluRCxFQUFKLENBQU9tRCxDQUFDLENBQUNqRCxRQUFGLENBQVcsRUFBWCxDQUFQLEVBQXVCLEVBQXZCLENBQXpCO0FBQUEsQ0FBYjs7QUFDQSxJQUFNa0QsT0FBTyxHQUFHLFNBQVZBLE9BQVU7QUFBQSxvQ0FBSUMsR0FBSjtBQUFJQSxJQUFBQSxHQUFKO0FBQUE7O0FBQUEsU0FBWUEsR0FBRyxDQUFDNUQsTUFBSixDQUFXLFVBQUM2RCxDQUFELEVBQUlDLENBQUo7QUFBQSxXQUFVO0FBQUEsYUFBYUQsQ0FBQyxDQUFDQyxDQUFDLE1BQUQsbUJBQUQsQ0FBZDtBQUFBLEtBQVY7QUFBQSxHQUFYLENBQVo7QUFBQSxDQUFoQjs7QUFDQSxJQUFNQyxJQUFJLEdBQUcsU0FBUEEsSUFBTyxDQUFDN0QsQ0FBRDtBQUFBLFNBQXdCLFVBQUNsQyxDQUFEO0FBQUEsV0FBWUEsQ0FBQyxDQUFDa0MsQ0FBRCxDQUFiO0FBQUEsR0FBeEI7QUFBQSxDQUFiOztBQUNBLElBQU04RCxNQUFNLEdBQUcsU0FBVEEsTUFBUyxDQUFDaEcsQ0FBRDtBQUFBLFNBQXFCLENBQUMsQ0FBQ0EsQ0FBdkI7QUFBQSxDQUFmOztBQUNBLElBQU15QyxRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFDekMsQ0FBRDtBQUFBLFNBQXVCQSxDQUFDLENBQUN5QyxRQUFGLENBQVcsRUFBWCxDQUF2QjtBQUFBLENBQWpCOztBQUNBLElBQU13RCxRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFDakcsQ0FBRDtBQUFBLFNBQXVCa0csTUFBTSxDQUFDbEcsQ0FBQyxDQUFDeUMsUUFBRixDQUFXLEVBQVgsQ0FBRCxDQUE3QjtBQUFBLENBQWpCOztBQUNBLElBQU0wRCxVQUFVLEdBQUdSLE9BQU8sQ0FBQ0ssTUFBRCxFQUFTRCxJQUFJLENBQUMsQ0FBRCxDQUFiLENBQTFCO0FBQ0EsSUFBTUssWUFBWSxHQUFHVCxPQUFPLENBQUNsRCxRQUFELEVBQVdzRCxJQUFJLENBQUMsQ0FBRCxDQUFmLENBQTVCO0FBQ0EsSUFBTU0sWUFBWSxHQUFHVixPQUFPLENBQUNNLFFBQUQsRUFBV0YsSUFBSSxDQUFDLENBQUQsQ0FBZixDQUE1Qjs7QUFDQSxJQUFNTyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFDOUYsSUFBRCxFQUFPK0YsR0FBUCxFQUFZN0YsSUFBWixFQUFxQjtBQUNyQyxRQUFNLElBQUl5QyxLQUFKLDhCQUErQjNDLElBQS9CLGlCQUF5Q0UsSUFBekMsMkJBQThENkYsR0FBOUQsRUFBTjtBQUNELENBRkQ7O0FBR0EsSUFBTUMsY0FBYyxHQUFHLFNBQWpCQSxjQUFpQixDQUFDQyxFQUFELEVBQVE7QUFDN0IsTUFBTUMsT0FBTyxHQUFHLENBQUNELEVBQUUsR0FBRyxJQUFOLEVBQVlFLE9BQVosQ0FBb0IsQ0FBcEIsQ0FBaEI7QUFDQSxNQUFNQyxPQUFPLEdBQUcsQ0FBQ0gsRUFBRSxJQUFJLE9BQU8sRUFBWCxDQUFILEVBQW1CRSxPQUFuQixDQUEyQixDQUEzQixDQUFoQjtBQUNBLE1BQU1FLEtBQUssR0FBRyxDQUFDSixFQUFFLElBQUksT0FBTyxFQUFQLEdBQVksRUFBaEIsQ0FBSCxFQUF3QkUsT0FBeEIsQ0FBZ0MsQ0FBaEMsQ0FBZDtBQUNBLE1BQU1HLElBQUksR0FBRyxDQUFDTCxFQUFFLElBQUksT0FBTyxFQUFQLEdBQVksRUFBWixHQUFpQixFQUFyQixDQUFILEVBQTZCRSxPQUE3QixDQUFxQyxDQUFyQyxDQUFiO0FBQ0EsTUFBSUQsT0FBTyxHQUFHLEVBQWQsRUFBa0IsT0FBT0EsT0FBTyxHQUFHLE1BQWpCLENBQWxCLEtBQ0ssSUFBSUUsT0FBTyxHQUFHLEVBQWQsRUFBa0IsT0FBT0EsT0FBTyxHQUFHLE1BQWpCLENBQWxCLEtBQ0EsSUFBSUMsS0FBSyxHQUFHLEVBQVosRUFBZ0IsT0FBT0EsS0FBSyxHQUFHLFFBQWY7QUFDckIsU0FBT0MsSUFBSSxHQUFHLE9BQWQ7QUFDRCxDQVREO0FBV0E7Ozs7Ozs7O1NBTXNCQyxjOzs7QUFVdEI7Ozs7Ozs7Ozs7NEZBVk8sa0JBQ0xuRSxHQURLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVIakMsWUFBQUEsR0FGRyxTQUVIQSxHQUZHLEVBRUVNLFFBRkYsU0FFRUEsUUFGRixFQUVZK0YsU0FGWixTQUVZQSxTQUZaO0FBSUN0RixZQUFBQSxRQUpELEdBSVlrQixHQUFHLENBQUNsQixRQUFKLENBQWFmLEdBQWIsRUFBa0JNLFFBQWxCLEVBQTRCK0YsU0FBNUIsQ0FKWjtBQUFBO0FBQUEsbUJBS2dCdEYsUUFBUSxDQUFDdUYsR0FBVCxFQUxoQjs7QUFBQTtBQUtDdEUsWUFBQUEsTUFMRDtBQUFBO0FBQUEsbUJBTWlCQyxHQUFHLENBQUNzRSxxQkFBSixDQUEwQnZFLE1BQTFCLENBTmpCOztBQUFBO0FBTUNNLFlBQUFBLE9BTkQ7QUFBQSw4Q0FPRXZCLFFBQVEsQ0FBQ3lGLEVBQVQsQ0FBWWxFLE9BQU8sQ0FBQzFCLGVBQXBCLENBUEY7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztBQWlCQSxTQUFTNkYsYUFBVCxDQUNMeEUsR0FESyxTQUdLO0FBQUEsTUFEUmpDLEdBQ1EsU0FEUkEsR0FDUTtBQUFBLE1BREhNLFFBQ0csU0FESEEsUUFDRztBQUFBLE1BRE9VLE9BQ1AsU0FET0EsT0FDUDtBQUFBLE1BRGdCcUYsU0FDaEIsU0FEZ0JBLFNBQ2hCO0FBQ1YsU0FBT3BFLEdBQUcsQ0FBQ2xCLFFBQUosQ0FBYWYsR0FBYixFQUFrQk0sUUFBbEIsRUFBNEIrRixTQUE1QixFQUF1Q0csRUFBdkMsQ0FBMEN4RixPQUExQyxDQUFQO0FBQ0Q7QUFFRDs7Ozs7OztTQUtzQjBGLE87OztBQW9EdEI7Ozs7Ozs7OztxRkFwRE87QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNMN0ksWUFBQUEsT0FESyxTQUNMQSxPQURLLEVBRUxELFdBRkssU0FFTEEsV0FGSyxFQUdMRSxHQUhLLFNBR0xBLEdBSEssRUFJTE4sUUFKSyxTQUlMQSxRQUpLO0FBU0NtSixZQUFBQSxjQVRELEdBU2tCLElBQUl4RixNQUFNLENBQUN5RixJQUFQLENBQVloSixXQUFaLEVBQXlCNEYsTUFUL0M7QUFVQ3FELFlBQUFBLGFBVkQsR0FXSCxtQ0FBb0JySixRQUFwQixLQUFnQ0EsUUFBaEMsR0FDSUEsUUFESixHQUVJbUosY0FBYyxHQUNkO0FBQ0EsZ0JBQUlHLDRCQUFKLENBQW1CdEosUUFBbkIsRUFBNkI7QUFDM0J1SixjQUFBQSxlQUFlLEVBQUUseUJBQUNDLEtBQUQsRUFBUUMsRUFBUixFQUFlO0FBQzlCLG9CQUFNQyxFQUFFLEdBQUcsSUFBSUMscUJBQUosQ0FBZUgsS0FBZixDQUFYO0FBQ0FFLGdCQUFBQSxFQUFFLENBQUNFLElBQUgsQ0FBUXhKLFdBQVcsQ0FBQ3lKLElBQUQsQ0FBbkI7QUFDQUosZ0JBQUFBLEVBQUUsQ0FBQyxJQUFELEVBQU8sT0FBT0MsRUFBRSxDQUFDSSxTQUFILEdBQWV4RixRQUFmLENBQXdCLEtBQXhCLENBQWQsQ0FBRjtBQUNELGVBTDBCO0FBTTNCeUYsY0FBQUEsUUFBUSxFQUFFLGtCQUFDTixFQUFEO0FBQUEsdUJBQVFBLEVBQUUsQ0FBQyxJQUFELEVBQU9NLFNBQVAsQ0FBVjtBQUFBLGVBTmlCO0FBTzNCQyxjQUFBQSxPQUFPLEVBQUUsS0FBSztBQVBhLGFBQTdCLENBRmMsR0FXZDtBQUNBLGdCQUFJM0MsZUFBSTRDLFlBQVIsQ0FBcUJqSyxRQUFRLElBQUlILFFBQVEsQ0FBQ0csUUFBMUMsQ0F6QkQ7QUEwQkN5RSxZQUFBQSxHQTFCRCxHQTBCTyxJQUFJNEMsY0FBSixDQUFRZ0MsYUFBUixDQTFCUDtBQUFBLDJCQTJCV2EsaUJBM0JYO0FBQUEsMkJBNEJPekYsR0FBRyxDQUFDMEYsZUE1Qlg7QUFBQTtBQUFBLG1CQTZCMkMxRixHQUFHLENBQUMyRixXQUFKLEVBN0IzQzs7QUFBQTtBQUFBO0FBQUEsMkJBNkJjdkssUUFBUSxDQUFDNkIsYUE3QnZCO0FBQUE7QUE0QkgxQixjQUFBQSxRQTVCRztBQTZCSHFLLGNBQUFBLGVBN0JHO0FBQUE7QUEyQkNDLFlBQUFBLEdBM0JEOztBQUFBLGlCQStCWW5CLGNBL0JaO0FBQUE7QUFBQTtBQUFBOztBQUFBLDJCQWdDRHhGLE1BQU0sQ0FBQ3lGLElBQVAsQ0FBWWhKLFdBQVosQ0FoQ0M7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxtQkFpQ0txRSxHQUFHLENBQUNzRixRQUFKLEVBakNMOztBQUFBO0FBQUE7O0FBQUE7QUErQkNBLFlBQUFBLFNBL0JEO0FBa0NDRixZQUFBQSxJQWxDRCxHQW1DSDtBQUNBO0FBQ0EsZ0JBQUloRSxHQUFKLENBQVFrRSxTQUFSLEVBQWtCN0QsR0FBbEIsQ0FBc0I3RixPQUF0QixJQUNJQSxPQURKLEdBRUkwSixTQUFRLENBQUMxSixPQUFELENBQVIsSUFBcUJuQixhQXZDdEI7QUFBQSw4Q0F3Q0U7QUFDTHVGLGNBQUFBLEdBQUcsRUFBSEEsR0FESztBQUVMNkYsY0FBQUEsR0FBRyxFQUFIQSxHQUZLO0FBR0x0SyxjQUFBQSxRQUFRLEVBQVJBLFFBSEs7QUFJTCtKLGNBQUFBLFFBQVEsRUFBUkEsU0FKSztBQUtMbEIsY0FBQUEsU0FBUyxFQUFFO0FBQ1RnQixnQkFBQUEsSUFBSSxFQUFKQSxJQURTO0FBRVR2SixnQkFBQUEsR0FBRyxFQUFIQTtBQUZTO0FBTE4sYUF4Q0Y7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztTQTBEZWlLLGE7OztBQWdIdEI7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyRkFySE87QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDTC9FLFlBQUFBLElBREssOERBQ0UsRUFERjtBQUdMO0FBSEssNEJBWURBLElBWkMsQ0FLSG5GLE9BTEcsRUFLSEEsT0FMRyw4QkFLT1IsUUFBUSxDQUFDUSxPQUxoQixvQ0FZRG1GLElBWkMsQ0FNSGpGLFNBTkcsRUFNSEEsU0FORyxnQ0FNU1YsUUFBUSxDQUFDVSxTQU5sQiw0Q0FZRGlGLElBWkMsQ0FPSDFGLGlCQVBHLEVBT0hBLGlCQVBHLHNDQU9pQkQsUUFBUSxDQUFDQyxpQkFQMUIsa0RBWUQwRixJQVpDLENBUUh6RixrQkFSRyxFQVFIQSxrQkFSRyxzQ0FRa0JGLFFBQVEsQ0FBQ0Usa0JBUjNCLHNDQVlEeUYsSUFaQyxDQVNIbEYsR0FURyxFQVNIQSxHQVRHLDBCQVNHVCxRQUFRLENBQUNTLEdBVFosa0NBWURrRixJQVpDLENBVUhwRixXQVZHLEVBVUhBLFdBVkcsa0NBVVdQLFFBQVEsQ0FBQ08sV0FWcEIsdUNBWURvRixJQVpDLENBV0h4RixRQVhHLEVBV0hBLFFBWEcsK0JBV1FILFFBQVEsQ0FBQ0csUUFYakIsbUJBYUw7O0FBYks7QUFBQSxtQkFjMkNrSixPQUFPLENBQUM7QUFDdEQ3SSxjQUFBQSxPQUFPLEVBQVBBLE9BRHNEO0FBRXREQyxjQUFBQSxHQUFHLEVBQUhBLEdBRnNEO0FBR3RERixjQUFBQSxXQUFXLEVBQVhBLFdBSHNEO0FBSXRESixjQUFBQSxRQUFRLEVBQVJBO0FBSnNELGFBQUQsQ0FkbEQ7O0FBQUE7QUFBQTtBQWNHK0osWUFBQUEsUUFkSCxrQkFjR0EsUUFkSDtBQWNhbEIsWUFBQUEsU0FkYixrQkFjYUEsU0FkYjtBQWN3QnlCLFlBQUFBLEdBZHhCLGtCQWN3QkEsR0FkeEI7QUFjNkI3RixZQUFBQSxHQWQ3QixrQkFjNkJBLEdBZDdCO0FBb0JDdEIsWUFBQUEsU0FwQkQsR0FvQmE7QUFDaEIzQyxjQUFBQSxhQUFhLEVBQUUsSUFEQztBQUVoQkUsY0FBQUEsbUJBQW1CLEVBQUUsSUFGTDtBQUdoQk0sY0FBQUEsY0FBYyxFQUFFLElBSEE7QUFJaEJGLGNBQUFBLGFBQWEsRUFBRSxJQUpDO0FBS2hCSSxjQUFBQSxNQUFNLEVBQUUsSUFMUTtBQU1oQk0sY0FBQUEsY0FBYyxFQUFFO0FBTkEsYUFwQmI7QUE0QkNzRSxZQUFBQSxNQTVCRCxHQTRCVTtBQUNidEYsY0FBQUEsYUFBYSxFQUFFLEVBREY7QUFFYkUsY0FBQUEsbUJBQW1CLEVBQUUsRUFGUjtBQUdiTSxjQUFBQSxjQUFjLEVBQUUsRUFISDtBQUliRixjQUFBQSxhQUFhLEVBQUUsRUFKRjtBQUtiSSxjQUFBQSxNQUFNLEVBQUUsRUFMSztBQU1iTSxjQUFBQSxjQUFjLEVBQUU7QUFOSCxhQTVCVixFQW9DTDs7QUFwQ0s7QUFBQSxtQkFxQ29CeUgsYUFBYSxDQUFDeEUsR0FBRCxrQ0FDakNsRSxTQUFTLENBQUNLLFVBRHVCO0FBRXBDaUksY0FBQUEsU0FBUyxFQUFUQSxTQUZvQztBQUdwQ3JGLGNBQUFBLE9BQU8sRUFBRTFEO0FBSDJCLGVBckNqQzs7QUFBQTtBQXFDQ2MsWUFBQUEsVUFyQ0Q7QUFBQTtBQUFBLG1CQTJDcUJxSSxhQUFhLENBQUN4RSxHQUFELGtDQUNsQ2xFLFNBQVMsQ0FBQ2EsV0FEd0I7QUFFckN5SCxjQUFBQSxTQUFTLEVBQVRBLFNBRnFDO0FBR3JDckYsY0FBQUEsT0FBTyxFQUFFekQ7QUFINEIsZUEzQ2xDOztBQUFBO0FBMkNDcUIsWUFBQUEsV0EzQ0Q7QUFBQTtBQUFBLG1CQWdEYzZILGFBQWEsQ0FBQ3hFLEdBQUQsa0NBQzNCbEUsU0FBUyxDQUFDZSxJQURpQjtBQUU5QnVILGNBQUFBLFNBQVMsRUFBVEEsU0FGOEI7QUFHOUJyRixjQUFBQSxPQUFPLEVBQUV0RTtBQUhxQixlQWhEM0I7O0FBQUE7QUFnRENvQyxZQUFBQSxJQWhERDtBQUFBLG1DQXFEY3FDLE1BQU0sQ0FBQ3lGLElBQVAsQ0FBWWpHLFNBQVosQ0FyRGQ7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFxRE1kLFlBQUFBLElBckROO0FBc0RIO0FBQ01LLFlBQUFBLElBdkRILEdBdURVMkUsZUFBSW1ELFNBQUosQ0FBY25JLElBQWQsQ0F2RFY7QUFBQTtBQUFBLG1CQXdEb0J6QixVQUFVLENBQUM2SixXQUFYLENBQXVCL0gsSUFBdkIsQ0F4RHBCOztBQUFBO0FBd0RHYyxZQUFBQSxPQXhESCxrQkF3RGtELENBeERsRDtBQUFBO0FBQUEsbUJBMERxQnlGLGFBQWEsQ0FBQ3hFLEdBQUQsa0NBQ2hDbEUsU0FBUyxDQUFDOEIsSUFBRCxDQUR1QjtBQUVuQ3dHLGNBQUFBLFNBQVMsRUFBVEEsU0FGbUM7QUFHbkNyRixjQUFBQSxPQUFPLEVBQVBBO0FBSG1DLGVBMURsQzs7QUFBQTtBQTBESEwsWUFBQUEsU0FBUyxDQUFDZCxJQUFELENBMUROO0FBQUEsbURBK0RnQmMsU0FBUyxDQUFDZCxJQUFELENBQVQsQ0FBZ0JHLEdBL0RoQzs7QUFBQTtBQStESCxrRUFBd0M7QUFBN0JOLGdCQUFBQSxJQUE2QjtBQUN0QzRELGdCQUFBQSxNQUFNLENBQUN6RCxJQUFELENBQU4sQ0FBYVYsS0FBSyxDQUFDTSxhQUFOLENBQW9CQyxJQUFwQixDQUFiLElBQTBDQSxJQUFJLENBQUNHLElBQS9DO0FBQ0Q7QUFqRUU7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQW1FTDtBQUNBYyxZQUFBQSxTQUFTLENBQUN2QyxVQUFWLEdBQXVCQSxVQUF2QixDQXBFSyxDQXFFTDs7QUFDQXVDLFlBQUFBLFNBQVMsQ0FBQy9CLFdBQVYsR0FBd0JBLFdBQXhCLENBdEVLLENBdUVMOztBQUNBK0IsWUFBQUEsU0FBUyxDQUFDN0IsSUFBVixHQUFpQkEsSUFBakIsQ0F4RUssQ0EwRUw7O0FBQ01jLFlBQUFBLElBM0VELEdBMkVRdUIsTUFBTSxDQUFDQyxPQUFQLENBQWVyRCxTQUFmLEVBQ1Z5QyxHQURVLENBQ047QUFBQTtBQUFBLGtCQUFFZSxDQUFGO0FBQUEsa0JBQUtDLENBQUw7O0FBQUEsdURBQWdCRCxDQUFoQixFQUFvQkMsQ0FBQyxDQUFDeEIsR0FBdEI7QUFBQSxhQURNLEVBRVZxQixNQUZVLENBRUgsVUFBQzZHLENBQUQsRUFBSUMsQ0FBSjtBQUFBLHFEQUFnQkQsQ0FBaEIsR0FBc0JDLENBQXRCO0FBQUEsYUFGRyxFQUV5QixFQUZ6QixDQTNFUixFQThFTDs7QUFDTUMsWUFBQUEsTUEvRUQsR0ErRVVqSCxNQUFNLENBQUNDLE9BQVAsQ0FBZXhCLElBQWYsRUFDWlksR0FEWSxDQUNSLGtCQUFxQjtBQUFBO0FBQUEsa0JBQW5CTyxRQUFtQjtBQUFBLGtCQUFUZixHQUFTOztBQUN4QixxQkFBT0EsR0FBRyxDQUNQRixNQURJLENBQ0csVUFBQ1QsQ0FBRDtBQUFBLHVCQUFPQSxDQUFDLENBQUNVLElBQUYsS0FBVyxPQUFsQjtBQUFBLGVBREgsRUFFSlMsR0FGSSxDQUVBLFVBQUNSLEdBQUQ7QUFBQSx1QkFBVTtBQUNiQSxrQkFBQUEsR0FBRyxFQUFIQSxHQURhO0FBRWJlLGtCQUFBQSxRQUFRLEVBQVJBLFFBRmE7QUFHYnFELGtCQUFBQSxLQUFLLEVBQUV6RCxTQUFTLENBQUNJLFFBQUQsQ0FBVCxDQUFvQmYsR0FBRyxDQUFDSCxJQUF4QixDQUhNO0FBSWJBLGtCQUFBQSxJQUFJLEVBQUVHLEdBQUcsQ0FBQ0g7QUFKRyxpQkFBVjtBQUFBLGVBRkEsQ0FBUDtBQVFELGFBVlksRUFXWndCLE1BWFksQ0FZWCxVQUFDNkcsQ0FBRCxFQUFJQyxDQUFKO0FBQUEscUJBQ0VBLENBQUMsQ0FBQzlHLE1BQUYsQ0FBUyxVQUFDK0csTUFBRCxVQUE0QztBQUFBLG9CQUFqQ3ZJLElBQWlDLFVBQWpDQSxJQUFpQztBQUFBLG9CQUEzQnVFLEtBQTJCLFVBQTNCQSxLQUEyQjtBQUFBLG9CQUFwQnBFLEdBQW9CLFVBQXBCQSxHQUFvQjtBQUFBLG9CQUFmZSxRQUFlLFVBQWZBLFFBQWU7QUFDbkRxRCxnQkFBQUEsS0FBSyxDQUFDcEUsR0FBTixHQUFZQSxHQUFaO0FBQ0FvRSxnQkFBQUEsS0FBSyxDQUFDckQsUUFBTixHQUFpQkEsUUFBakI7QUFDQSx1REFBWXFILE1BQVoseUNBQXFCdkksSUFBckIsRUFBNEJ1RSxLQUE1QjtBQUNELGVBSkQsRUFJRzhELENBSkgsQ0FERjtBQUFBLGFBWlcsRUFrQlgsRUFsQlcsQ0EvRVY7QUFBQSw4Q0FvR0U7QUFDTHRJLGNBQUFBLElBQUksRUFBSkEsSUFESztBQUVMMkgsY0FBQUEsUUFBUSxFQUFSQSxRQUZLO0FBR0w1RyxjQUFBQSxTQUFTLEVBQVRBLFNBSEs7QUFJTDBGLGNBQUFBLFNBQVMsRUFBVEEsU0FKSztBQUtMeUIsY0FBQUEsR0FBRyxFQUFIQSxHQUxLO0FBTUw3RixjQUFBQSxHQUFHLEVBQUhBLEdBTks7QUFPTG1HLGNBQUFBLE1BQU0sRUFBTkEsTUFQSztBQVFMOUUsY0FBQUEsTUFBTSxFQUFOQTtBQVJLLGFBcEdGOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEc7Ozs7U0F1SWUrRSxpQjs7Ozs7K0ZBQWYsbUJBQ0xyRixJQURLO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUdvQytFLGFBQWEsQ0FBQy9FLElBQUQsQ0FIakQ7O0FBQUE7QUFBQTtBQUdHOEUsWUFBQUEsR0FISCx3QkFHR0EsR0FISDtBQUdRTSxZQUFBQSxNQUhSLHdCQUdRQSxNQUhSO0FBR21CRSxZQUFBQSxNQUhuQjtBQUFBLGdDQWFEQSxNQUFNLENBQUMzSCxTQWJOLEVBS0huQyxjQUxHLHFCQUtIQSxjQUxHLEVBTUhKLFVBTkcscUJBTUhBLFVBTkcsRUFPSEosYUFQRyxxQkFPSEEsYUFQRyxFQVFIRSxtQkFSRyxxQkFRSEEsbUJBUkcsRUFTSEksYUFURyxxQkFTSEEsYUFURyxFQVVISSxNQVZHLHFCQVVIQSxNQVZHLEVBV0hFLFdBWEcscUJBV0hBLFdBWEcsRUFZSEksY0FaRyxxQkFZSEEsY0FaRztBQWNHTyxZQUFBQSxjQWRILEdBY3NCSixLQWR0QixDQWNHSSxjQWRILEVBZ0JMOztBQUNNZ0osWUFBQUEsS0FqQkQsR0FpQlMsQ0FDWjtBQURZLGFBakJUO0FBb0JMOzs7Ozs7Ozs7Ozs7Ozs7O0FBZU1DLFlBQUFBLEdBbkNELEdBbUNPO0FBQ1Y7Ozs7Ozs7Ozs7Ozs7OztBQWVNQyxjQUFBQSxVQWhCSSxzQkFnQk96SCxPQWhCUCxFQWdCeUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlDQUVsQzhHLEdBQUcsQ0FBQ1ksT0FBSixDQUFZMUgsT0FBWixDQUZrQzs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFJL0M7QUFDQSw4QkFBSSxhQUFJMkgsT0FBSixLQUFnQix1QkFBcEIsRUFBNkM7QUFDM0NDLDRCQUFBQSxPQUFPLENBQUNDLElBQVIsZ0RBQ3lDN0gsT0FEekMsVUFFRSxhQUFJMkgsT0FGTjtBQUlELDJCQVY4QyxDQVcvQzs7O0FBWCtDLDREQVl4QyxFQVp3Qzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNsRCxlQTlCUzs7QUFnQ1Y7Ozs7Ozs7Ozs7O0FBV01HLGNBQUFBLGFBM0NJLHlCQTJDVWpKLElBM0NWLEVBMkN5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUNBRWxDaUksR0FBRyxDQUFDaUIsTUFBSixDQUFXbEosSUFBWCxDQUZrQzs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFJL0M7QUFDQSw4QkFBSSxhQUFJOEksT0FBSixLQUFnQix1QkFBcEIsRUFBNkM7QUFDM0NDLDRCQUFBQSxPQUFPLENBQUNDLElBQVIsZ0RBQ3lDaEosSUFEekMsVUFFRSxhQUFJOEksT0FGTjtBQUlELDJCQVY4QyxDQVcvQzs7O0FBWCtDLDREQVl4QyxFQVp3Qzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNsRCxlQXpEUzs7QUEyRFY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NNSyxjQUFBQSxRQTNGSSxvQkEyRktDLEVBM0ZMLEVBMkZpQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLCtCQUMzQkEsRUFBRSxDQUFDbkgsUUFBSCxHQUFjb0gsVUFBZCxDQUF5QixJQUF6QixDQUQyQjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLGlDQUUvQlosTUFBTSxDQUFDckcsR0FBUCxDQUFXa0gsY0FBWCxDQUEwQkYsRUFBMUIsRUFBOEIsSUFBOUIsQ0FGK0I7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLGlDQUcvQlgsTUFBTSxDQUFDckcsR0FBUCxDQUFXbUgsZ0JBQVgsQ0FBNEJILEVBQTVCLEVBQWdDLElBQWhDLENBSCtCOztBQUFBO0FBQUE7O0FBQUE7QUFDbkNJLDBCQUFBQSxLQURtQztBQUFBLDRGQUtwQ0EsS0FMb0M7QUFNdkNDLDRCQUFBQSxVQUFVLEVBQUV4SCxRQUFRLENBQUN1SCxLQUFLLENBQUNDLFVBQVAsQ0FObUI7QUFPdkNDLDRCQUFBQSxRQUFRLEVBQUV6SCxRQUFRLENBQUN1SCxLQUFLLENBQUNFLFFBQVAsQ0FQcUI7QUFRdkNDLDRCQUFBQSxPQUFPLEVBQUUxSCxRQUFRLENBQUN1SCxLQUFLLENBQUNHLE9BQVAsQ0FSc0I7QUFTdkNDLDRCQUFBQSxNQUFNLEVBQUUzSCxRQUFRLENBQUN1SCxLQUFLLENBQUNJLE1BQVAsQ0FUdUI7QUFVdkNDLDRCQUFBQSxJQUFJLEVBQUU1SCxRQUFRLENBQUN1SCxLQUFLLENBQUNLLElBQVAsQ0FWeUI7QUFXdkNDLDRCQUFBQSxTQUFTLEVBQUVwRSxNQUFNLENBQUN6RCxRQUFRLENBQUN1SCxLQUFLLENBQUNNLFNBQVAsQ0FBVCxDQVhzQjtBQVl2Q0MsNEJBQUFBLGVBQWUsRUFBRTlILFFBQVEsQ0FBQ3VILEtBQUssQ0FBQ08sZUFBUDtBQVpjOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYzFDLGVBekdTOztBQTJHVjs7Ozs7Ozs7Ozs7O0FBWU1DLGNBQUFBLGFBdkhJLHlCQXVIVTNGLElBdkhWLEVBdUh5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQ0FDMUNwQyxRQUQwQztBQUFBLDBDQUV6Q3dHLE1BQU0sQ0FBQ3JHLEdBRmtDO0FBQUE7QUFBQSxpQ0FHdkMxQyxjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0I1RSxJQUFwQixDQUh5Qjs7QUFBQTtBQUFBO0FBQUE7QUFBQSwrQ0FFOUI0RixVQUY4Qjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNbEQsZUE3SFM7O0FBK0hWOzs7Ozs7Ozs7O0FBVU1DLGNBQUFBLGtCQXpJSSxnQ0F5SWtDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBDQUNuQ3RFLFlBRG1DO0FBQUE7QUFBQSxpQ0FDaEJqSCxjQUFjLENBQUN3TCxlQUFmLEVBRGdCOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUUzQyxlQTNJUzs7QUE2SVY7Ozs7Ozs7Ozs7QUFVTUMsY0FBQUEsdUJBdkpJLHFDQXVKdUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQ3hDeEUsWUFEd0M7QUFBQTtBQUFBLGlDQUNyQmpILGNBQWMsQ0FBQzBMLG9CQUFmLEVBRHFCOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVoRCxlQXpKUzs7QUEySlY7Ozs7Ozs7Ozs7QUFVTUMsY0FBQUEsMEJBcktJLHdDQXFLMEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQzNDMUUsWUFEMkM7QUFBQTtBQUFBLGlDQUN4QmpILGNBQWMsQ0FBQzRMLHVCQUFmLEVBRHdCOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVuRCxlQXZLUzs7QUF5S1Y7Ozs7Ozs7Ozs7QUFVTUMsY0FBQUEsY0FuTEksNEJBbUw4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQ0FDL0I1RSxZQUQrQjtBQUFBO0FBQUEsaUNBQ1pqSCxjQUFjLENBQUM2TCxjQUFmLEVBRFk7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRXZDLGVBckxTOztBQXVMVjs7Ozs7Ozs7OztBQVVNQyxjQUFBQSxtQkFqTUksaUNBaU1tQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQ0FDcEM3RSxZQURvQztBQUFBO0FBQUEsaUNBQ2pCekgsYUFBYSxDQUFDdU0sV0FBZCxFQURpQjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFNUMsZUFuTVM7O0FBcU1WOzs7Ozs7Ozs7OztBQVdNQyxjQUFBQSxlQWhOSSwyQkFnTll0RyxJQWhOWixFQWdOMkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQzVDdUIsWUFENEM7QUFBQSwwQ0FFM0N6SCxhQUYyQztBQUFBO0FBQUEsaUNBR3pDdUIsY0FBYyxDQUFDaUosR0FBRyxDQUFDTSxhQUFMLEVBQW9CNUUsSUFBcEIsQ0FIMkI7O0FBQUE7QUFBQTtBQUFBO0FBQUEsK0NBRTdCdUcsU0FGNkI7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTXBELGVBdE5TOztBQXdOVjs7Ozs7Ozs7Ozs7QUFXTUMsY0FBQUEsWUFuT0ksd0JBbU9TeEcsSUFuT1QsRUFtTzJDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUNBRTlCc0UsR0FBRyxDQUFDOEIsbUJBQUosRUFGOEI7O0FBQUE7QUFBQTtBQUFBLDBDQUdsQzlCLEdBSGtDO0FBQUE7QUFBQSxpQ0FJekNqSixjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0I1RSxJQUFwQixDQUoyQjs7QUFBQTtBQUFBO0FBQUE7QUFBQSwrQ0FHOUJzRyxlQUg4Qjs7QUFBQTtBQUFBO0FBQUE7QUFFakRELDRCQUFBQSxXQUZpRDtBQUdqREksNEJBQUFBLE9BSGlEO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPcEQsZUExT1M7O0FBNE9WOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JNQyxjQUFBQSxhQTNRSSx5QkE0UVJDLEVBNVFRLEVBNlFSQyxNQTdRUSxFQStRWTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRHBCNUQsMEJBQUFBLEVBQ29CLDBFQURmb0IsTUFBTSxDQUFDakMsU0FDUTtBQUNkMEUsMEJBQUFBLEtBRGMsR0FDTmpHLElBQUksQ0FBQ2dHLE1BQUQsQ0FERSxFQUVwQjs7QUFGb0I7QUFBQSxpQ0FHRzlNLGFBQWEsQ0FBQ3lNLFNBQWQsQ0FBd0J2RCxFQUFFLENBQUNHLElBQTNCLENBSEg7O0FBQUE7QUFHZHNELDBCQUFBQSxPQUhjLG1CQUdxQyxDQUhyQzs7QUFBQSw4QkFJZkEsT0FBTyxDQUFDSyxHQUFSLENBQVlELEtBQVosQ0FKZTtBQUFBO0FBQUE7QUFBQTs7QUFBQSxnQ0FLWixJQUFJdkksS0FBSiwyQkFDZVYsUUFBUSxDQUN6QmlKLEtBRHlCLENBRHZCLG1FQUdzREosT0FIdEQsWUFMWTs7QUFBQTtBQUFBLDBDQVlQeEwsS0FaTztBQUFBLDBDQWFabkIsYUFiWTtBQUFBO0FBQUEsaUNBY1Z1QixjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0IrQixFQUFwQixDQWRKOztBQUFBO0FBQUE7QUFBQSwwQ0FlaEJFLEtBZmdCO0FBQUEsMENBZ0JoQjdELEVBaEJnQjtBQUFBO0FBQUEsK0NBYUUrRCxRQWJGOztBQUFBO0FBQUE7QUFBQSwwQ0FrQmxCM0MsTUFBTSxDQUFDckcsR0FsQlc7QUFBQTtBQUFBLCtDQVlERixZQVpDOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFvQnJCLGVBblNTOztBQXFTVjs7Ozs7Ozs7OztBQVVNbUosY0FBQUEsZUEvU0ksNkJBK1MrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQ0FDaEN6RixZQURnQztBQUFBO0FBQUEsaUNBQ2J2SCxtQkFBbUIsQ0FBQ2lOLGFBQXBCLEVBRGE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRXhDLGVBalRTOztBQW1UVjs7Ozs7Ozs7OztBQVVNQyxjQUFBQSxhQTdUSSwyQkE2VDZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBDQUM5QjNGLFlBRDhCO0FBQUE7QUFBQSxpQ0FDWHZILG1CQUFtQixDQUFDbU4sV0FBcEIsRUFEVzs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFdEMsZUEvVFM7O0FBaVVWOzs7Ozs7Ozs7OztBQVdNQyxjQUFBQSxhQTVVSSx5QkE0VVVwSCxJQTVVVixFQTRVeUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQzFDdUIsWUFEMEM7QUFBQSwwQ0FFekN2SCxtQkFGeUM7QUFBQTtBQUFBLGlDQUd2Q3FCLGNBQWMsQ0FBQ2lKLEdBQUcsQ0FBQ00sYUFBTCxFQUFvQjVFLElBQXBCLENBSHlCOztBQUFBO0FBQUE7QUFBQTtBQUFBLCtDQUVyQnFILGdCQUZxQjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNbEQsZUFsVlM7O0FBb1ZWOzs7Ozs7Ozs7Ozs7Ozs7QUFlTUMsY0FBQUEsYUFuV0kseUJBbVdVdEgsSUFuV1YsRUFtVzZDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUNBRXJDc0UsR0FBRyxDQUFDMEMsZUFBSixFQUZxQzs7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FHdkMxQyxHQUFHLENBQUM0QyxhQUFKLEVBSHVDOztBQUFBO0FBQUE7QUFBQSwwQ0FJdkM1QyxHQUp1QztBQUFBO0FBQUEsaUNBSzNDakosY0FBYyxDQUFDaUosR0FBRyxDQUFDTSxhQUFMLEVBQW9CNUUsSUFBcEIsQ0FMNkI7O0FBQUE7QUFBQTtBQUFBO0FBQUEsK0NBSW5Db0gsYUFKbUM7O0FBQUE7QUFBQTtBQUFBO0FBRW5EUiw0QkFBQUEsTUFGbUQ7QUFHbkRXLDRCQUFBQSxJQUhtRDtBQUluREMsNEJBQUFBLElBSm1EO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRdEQsZUEzV1M7O0FBNldWOzs7Ozs7Ozs7O0FBVU1DLGNBQUFBLFlBdlhJLDBCQXVYNEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQzdCbEcsWUFENkI7QUFBQTtBQUFBLGlDQUNWL0csTUFBTSxDQUFDa04sU0FBUCxFQURVOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVyQyxlQXpYUzs7QUEyWFY7Ozs7Ozs7Ozs7QUFVTUMsY0FBQUEsa0JBcllJLGdDQXFZa0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQ25DcEcsWUFEbUM7QUFBQTtBQUFBLGlDQUNoQi9HLE1BQU0sQ0FBQ29OLGVBQVAsRUFEZ0I7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTNDLGVBdllTOztBQXlZVjs7Ozs7Ozs7Ozs7QUFXTUMsY0FBQUEsa0JBcFpJLDhCQW9aZTdILElBcFpmLEVBb1o4QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBDQUN2Q3VCLFlBRHVDO0FBQUEsMENBRTlDakgsY0FGOEM7QUFBQTtBQUFBLGlDQUc1Q2UsY0FBYyxDQUFDaUosR0FBRyxDQUFDTSxhQUFMLEVBQW9CNUUsSUFBcEIsQ0FIOEI7O0FBQUE7QUFBQTtBQUFBO0FBQUEsK0NBRS9COEgsZUFGK0I7O0FBQUE7QUFBQTtBQUNoRHpKLDBCQUFBQSxNQURnRDtBQUFBLDZEQU0vQzFGLGdCQUFnQixDQUFDMEYsTUFBRCxDQU4rQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU92RCxlQTNaUzs7QUE2WlY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Qk0wSixjQUFBQSxZQXRiSSx3QkFzYlMvSCxJQXRiVCxFQXNiMkM7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FDN0IzRSxjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0I1RSxJQUFwQixDQURlOztBQUFBO0FBQzdDbEQsMEJBQUFBLE9BRDZDO0FBQUEsMENBRWpDeUUsWUFGaUM7QUFBQTtBQUFBLGlDQUczQ3pILGFBQWEsQ0FBQ2tPLFNBQWQsQ0FBd0JsTCxPQUF4QixFQUFpQ3hDLGNBQWMsQ0FBQ3dDLE9BQWhELENBSDJDOztBQUFBO0FBQUE7QUFFN0NrTCwwQkFBQUEsU0FGNkM7QUFBQSwwQ0FLdEJ6RyxZQUxzQjtBQUFBO0FBQUEsaUNBTTNDekgsYUFBYSxDQUFDa08sU0FBZCxDQUF3QmxMLE9BQXhCLEVBQWlDcEMsV0FBVyxDQUFDb0MsT0FBN0MsQ0FOMkM7O0FBQUE7QUFBQTtBQUs3Q21MLDBCQUFBQSxvQkFMNkM7QUFBQTtBQUFBLGlDQVF4QjNELEdBQUcsQ0FBQzRELGVBQUosRUFSd0I7O0FBQUE7QUFRN0NDLDBCQUFBQSxZQVI2QztBQUFBLDBDQVM5QjVHLFlBVDhCO0FBQUE7QUFBQSxpQ0FVM0NqSCxjQUFjLENBQUM4TixZQUFmLENBQTRCdEwsT0FBNUIsRUFBcUNxTCxZQUFyQyxDQVYyQzs7QUFBQTtBQUFBO0FBUzdDQywwQkFBQUEsWUFUNkM7QUFBQSwwQ0FZL0I3RyxZQVorQjtBQUFBO0FBQUEsaUNBYTNDakgsY0FBYyxDQUFDK04sV0FBZixDQUEyQnZMLE9BQTNCLEVBQW9DcUwsWUFBcEMsQ0FiMkM7O0FBQUE7QUFBQTtBQVk3Q0UsMEJBQUFBLFdBWjZDO0FBQUE7QUFBQSxpQ0FlbkMvTixjQUFjLENBQUN5TixZQUFmLENBQTRCakwsT0FBNUIsQ0FmbUM7O0FBQUE7QUFlN0N3TCwwQkFBQUEsQ0FmNkM7QUFnQjdDQywwQkFBQUEsWUFoQjZDLEdBZ0I5QjNLLFFBQVEsQ0FBQzBLLENBQUMsQ0FBQ0MsWUFBSCxDQWhCc0I7QUFpQjdDQywwQkFBQUEsSUFqQjZDLEdBaUJ0QzVLLFFBQVEsQ0FBQzBLLENBQUMsQ0FBQ0UsSUFBSCxDQWpCOEI7QUFrQjdDQywwQkFBQUEsZUFsQjZDLEdBbUJqREgsQ0FBQyxDQUFDRyxlQUFGLEtBQXNCalEsYUFBdEIsR0FBc0MsRUFBdEMsR0FBMkM4UCxDQUFDLENBQUNHLGVBbkJJO0FBb0I3Q0MsMEJBQUFBLGVBcEI2QyxHQW9CM0I5SyxRQUFRLENBQUMwSyxDQUFDLENBQUNJLGVBQUgsQ0FwQm1CO0FBcUI3Q0MsMEJBQUFBLGNBckI2QyxHQXFCNUIvSyxRQUFRLENBQUMwSyxDQUFDLENBQUNLLGNBQUgsQ0FyQm9CO0FBc0I3Q0MsMEJBQUFBLFVBdEI2QyxHQXNCaENoTCxRQUFRLENBQUMwSyxDQUFDLENBQUNNLFVBQUgsQ0F0QndCO0FBdUI3Q0MsMEJBQUFBLG1CQXZCNkMsR0F1QnZCakwsUUFBUSxDQUFDMEssQ0FBQyxDQUFDTyxtQkFBSCxDQXZCZTtBQXlCL0NDLDBCQUFBQSxlQXpCK0MsR0F5QjdCbEksSUFBSSxDQUFDaUksbUJBQUQsQ0F6QnlCOztBQTBCbkQsOEJBQUlDLGVBQWUsQ0FBQ0MsR0FBaEIsQ0FBb0IsSUFBSXJMLEVBQUosQ0FBTyxDQUFQLENBQXBCLElBQWlDLENBQXJDLEVBQXdDO0FBQ3RDb0wsNEJBQUFBLGVBQWUsR0FBR0EsZUFBZSxDQUFDRSxHQUFoQixDQUFvQixJQUFJdEwsRUFBSixDQUFPLENBQVAsQ0FBcEIsQ0FBbEI7QUFDRDs7QUE1QmtEO0FBQUEsaUNBZ0N6QzRHLEdBQUcsQ0FBQzJFLHlCQUFKLENBQ1JuTSxPQURRLEVBRVJjLFFBQVEsQ0FBQ2tMLGVBQUQsQ0FGQSxDQWhDeUM7O0FBQUE7QUFBQTtBQThCekNJLDBCQUFBQSxjQTlCeUMseUJBOEJqRHRDLE1BOUJpRDtBQStCakR1QywwQkFBQUEsYUEvQmlELHlCQStCakRBLGFBL0JpRDs7QUFBQSxnQ0FxQ2pEQSxhQUFhLEtBQUssR0FBbEIsSUFBeUJ2SSxJQUFJLENBQUN1SCxZQUFELENBQUosQ0FBbUJZLEdBQW5CLENBQXVCbkksSUFBSSxDQUFDdUksYUFBRCxDQUEzQixJQUE4QyxDQXJDdEI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsMENBc0M3Q3hRLGdCQUFnQixDQUFDSSxTQXRDNEI7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxpQ0F1Q3ZDdUwsR0FBRyxDQUFDdUQsa0JBQUosQ0FBdUIvSyxPQUF2QixDQXZDdUM7O0FBQUE7QUFBQTs7QUFBQTtBQW9DN0N1QiwwQkFBQUEsTUFwQzZDO0FBQUEsNkRBeUM1QztBQUNMdkIsNEJBQUFBLE9BQU8sRUFBUEEsT0FESztBQUVMa0wsNEJBQUFBLFNBQVMsRUFBVEEsU0FGSztBQUdMQyw0QkFBQUEsb0JBQW9CLEVBQXBCQSxvQkFISztBQUlMTSw0QkFBQUEsWUFBWSxFQUFaQSxZQUpLO0FBS0xFLDRCQUFBQSxlQUFlLEVBQWZBLGVBTEs7QUFNTEMsNEJBQUFBLGVBQWUsRUFBZkEsZUFOSztBQU9MRiw0QkFBQUEsSUFBSSxFQUFKQSxJQVBLO0FBUUxHLDRCQUFBQSxjQUFjLEVBQWRBLGNBUks7QUFTTE4sNEJBQUFBLFdBQVcsRUFBWEEsV0FUSztBQVVMRCw0QkFBQUEsWUFBWSxFQUFaQSxZQVZLO0FBV0xRLDRCQUFBQSxVQUFVLEVBQVZBLFVBWEs7QUFZTHZLLDRCQUFBQSxNQUFNLEVBQU5BLE1BWks7QUFhTDhLLDRCQUFBQSxhQUFhLEVBQWJBLGFBYks7QUFjTEQsNEJBQUFBLGNBQWMsRUFBZEEsY0FkSztBQWVMTCw0QkFBQUEsbUJBQW1CLEVBQW5CQTtBQWZLLDJCQXpDNEM7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUEwRHBELGVBaGZTOztBQWtmVjs7Ozs7Ozs7Ozs7Ozs7O0FBZU1PLGNBQUFBLDBCQWpnQkksc0NBa2dCUnBKLElBbGdCUSxFQW1nQnVCO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUNBQ0tzRSxHQUFHLENBQUN5RCxZQUFKLENBQWlCL0gsSUFBakIsQ0FETDs7QUFBQTtBQUFBO0FBQ3pCNkksMEJBQUFBLG1CQUR5QiwwQkFDekJBLG1CQUR5QjtBQUczQkMsMEJBQUFBLGVBSDJCLEdBR1QxSCxRQUFRLENBQUN5SCxtQkFBRCxDQUhDOztBQUkvQiw4QkFBSUMsZUFBZSxHQUFHLENBQXRCLEVBQXlCO0FBQ3ZCQSw0QkFBQUEsZUFBZSxJQUFJLENBQW5CO0FBQ0Q7O0FBRUdPLDBCQUFBQSxNQVIyQixHQVFsQixFQVJrQjs7QUFBQTtBQUFBLGdDQVV4QlAsZUFBZSxJQUFJLENBVks7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxpQ0FXUnhFLEdBQUcsQ0FBQzJFLHlCQUFKLENBQ25CakosSUFEbUIsRUFFbkJwQyxRQUFRLENBQUNrTCxlQUFELENBRlcsQ0FYUTs7QUFBQTtBQVd2QlEsMEJBQUFBLE1BWHVCO0FBZTdCRCwwQkFBQUEsTUFBTSxDQUFDNUosSUFBUCxDQUFZNkosTUFBWjtBQUNBUiwwQkFBQUEsZUFBZSxJQUFJLENBQW5CO0FBaEI2QjtBQUFBOztBQUFBO0FBQUEsNkRBbUJ4Qk8sTUFuQndCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBb0JoQyxlQXZoQlM7O0FBeWhCVjs7Ozs7Ozs7Ozs7Ozs7O0FBZU1KLGNBQUFBLHlCQXhpQkkscUNBeWlCUmpKLElBemlCUSxFQTBpQlI4SSxlQTFpQlEsRUEyaUJnQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUNBQ0x4TyxjQUFjLENBQUMyTyx5QkFBZixDQUNqQmpKLElBRGlCLEVBRWpCOEksZUFGaUIsQ0FESzs7QUFBQTtBQUNsQlMsMEJBQUFBLElBRGtCO0FBS2xCM0MsMEJBQUFBLE1BTGtCLEdBS1RoSixRQUFRLENBQUMyTCxJQUFJLENBQUMzQyxNQUFOLENBTEM7QUFNbEJ1QywwQkFBQUEsYUFOa0IsR0FNRnZMLFFBQVEsQ0FBQzJMLElBQUksQ0FBQ0osYUFBTixDQU5OO0FBQUEsNkRBT2pCO0FBQ0xwRSw0QkFBQUEsRUFBRSxFQUFFK0QsZUFEQztBQUVMVSw0QkFBQUEsU0FBUyxFQUFFeEosSUFGTjtBQUdMNEcsNEJBQUFBLE1BQU0sRUFBTkEsTUFISztBQUlMdUMsNEJBQUFBLGFBQWEsRUFBYkE7QUFKSywyQkFQaUI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFhekIsZUF4akJTOztBQTBqQlY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCTU0sY0FBQUEsTUF4bEJJLGtCQXlsQlJYLGVBemxCUSxFQTJsQlk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURwQjlGLDBCQUFBQSxFQUNvQiw2RUFEZm9CLE1BQU0sQ0FBQ2pDLFNBQ1E7QUFBQTtBQUFBLGlDQUNDN0gsY0FBYyxDQUFDbVAsTUFBZixDQUFzQlgsZUFBdEIsa0NBQ2hCMUUsTUFBTSxDQUFDakMsU0FEUyxHQUVoQmEsRUFGZ0IsRUFERDs7QUFBQTtBQUNkbEYsMEJBQUFBLE1BRGM7O0FBQUEsK0JBS2hCa0YsRUFBRSxDQUFDMEcsWUFMYTtBQUFBO0FBQUE7QUFBQTs7QUFBQSw2REFNWDVMLE1BTlc7O0FBQUE7QUFBQTtBQUFBLGlDQVNQN0MsS0FBSyxDQUFDNEMsWUFBTixDQUFtQkMsTUFBbkIsRUFBMkJzRyxNQUFNLENBQUNyRyxHQUFsQyxDQVRPOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVckIsZUFybUJTOztBQXVtQlY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NNNEwsY0FBQUEsY0F2b0JJLDBCQXdvQlJiLGVBeG9CUSxFQXlvQlJjLFVBem9CUSxFQTBvQlJDLFVBMW9CUSxFQTJvQlI3RyxFQTNvQlEsRUE0b0JZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FDQzFJLGNBQWMsQ0FBQ3FQLGNBQWYsQ0FDbkJiLGVBRG1CLEVBRW5CYyxVQUZtQixFQUduQkMsVUFIbUIsa0NBS2R6RixNQUFNLENBQUNqQyxTQUxPLEdBTWRhLEVBTmMsRUFERDs7QUFBQTtBQUNkbEYsMEJBQUFBLE1BRGM7O0FBQUEsK0JBVWhCa0YsRUFBRSxDQUFDMEcsWUFWYTtBQUFBO0FBQUE7QUFBQTs7QUFBQSw2REFXWDVMLE1BWFc7O0FBQUE7QUFBQTtBQUFBLGlDQWNQN0MsS0FBSyxDQUFDNEMsWUFBTixDQUFtQkMsTUFBbkIsRUFBMkJzRyxNQUFNLENBQUNyRyxHQUFsQyxDQWRPOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFlckIsZUEzcEJTOztBQTZwQlY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQk0rTCxjQUFBQSxrQkE1ckJJLDhCQTZyQlJuRCxFQTdyQlEsRUE4ckJSbUMsZUE5ckJRLEVBZ3NCWTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRHBCOUYsMEJBQUFBLEVBQ29CLDZFQURmb0IsTUFBTSxDQUFDakMsU0FDUTtBQUFBO0FBQUEsaUNBQ0M3SCxjQUFjLENBQUN3UCxrQkFBZixDQUNuQm5ELEVBRG1CLEVBRW5CbUMsZUFGbUIsa0NBSWQxRSxNQUFNLENBQUNqQyxTQUpPLEdBS2RhLEVBTGMsRUFERDs7QUFBQTtBQUNkbEYsMEJBQUFBLE1BRGM7O0FBQUEsK0JBVWhCa0YsRUFBRSxDQUFDMEcsWUFWYTtBQUFBO0FBQUE7QUFBQTs7QUFBQSw2REFXWDVMLE1BWFc7O0FBQUE7QUFBQTtBQUFBLGlDQWNQN0MsS0FBSyxDQUFDNEMsWUFBTixDQUFtQkMsTUFBbkIsRUFBMkJzRyxNQUFNLENBQUNyRyxHQUFsQyxDQWRPOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFlckIsZUEvc0JTOztBQWl0QlY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDTWdNLGNBQUFBLDBCQWx2Qkksc0NBbXZCUnBELEVBbnZCUSxFQW92QlJtQyxlQXB2QlEsRUFxdkJSYyxVQXJ2QlEsRUFzdkJSQyxVQXR2QlEsRUF3dkJZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEcEI3RywwQkFBQUEsRUFDb0IsNkVBRGZvQixNQUFNLENBQUNqQyxTQUNRO0FBQUE7QUFBQSxpQ0FDQzdILGNBQWMsQ0FBQ3lQLDBCQUFmLENBQ25CcEQsRUFEbUIsRUFFbkJtQyxlQUZtQixFQUduQmMsVUFIbUIsRUFJbkJDLFVBSm1CLGtDQU1kekYsTUFBTSxDQUFDakMsU0FOTyxHQU9kYSxFQVBjLEVBREQ7O0FBQUE7QUFDZGxGLDBCQUFBQSxNQURjOztBQUFBLCtCQVloQmtGLEVBQUUsQ0FBQzBHLFlBWmE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkRBYVg1TCxNQWJXOztBQUFBO0FBQUE7QUFBQSxpQ0FnQlA3QyxLQUFLLENBQUM0QyxZQUFOLENBQW1CQyxNQUFuQixFQUEyQnNHLE1BQU0sQ0FBQ3JHLEdBQWxDLENBaEJPOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFpQnJCLGVBendCUzs7QUEyd0JWOzs7Ozs7Ozs7Ozs7QUFZTWlNLGNBQUFBLGVBdnhCSSwyQkF1eEJZaEssSUF2eEJaLEVBdXhCMEJpSyxRQXZ4QjFCLEVBdXhCNkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUNBRTdDNU8sY0FBYyxDQUFDaUosR0FBRyxDQUFDTSxhQUFMLEVBQW9CNUUsSUFBcEIsQ0FGK0I7O0FBQUE7QUFFN0RsRCwwQkFBQUEsT0FGNkQ7O0FBQUEsOEJBRzlEbU4sUUFIOEQ7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxpQ0FJdEMzRixHQUFHLENBQUM0RCxlQUFKLEVBSnNDOztBQUFBO0FBSTNEQywwQkFBQUEsWUFKMkQ7QUFBQSwwQ0FLMUQ1RyxZQUwwRDtBQUFBO0FBQUEsaUNBTXpEakgsY0FBYyxDQUFDOE4sWUFBZixDQUE0QnRMLE9BQTVCLEVBQXFDcUwsWUFBckMsQ0FOeUQ7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsMENBUzVENUcsWUFUNEQ7QUFBQTtBQUFBLGlDQVUzRGpILGNBQWMsQ0FBQzhOLFlBQWYsQ0FBNEJ0TCxPQUE1QixFQUFxQ21OLFFBQXJDLENBVjJEOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFhbkUsd0NBQUl4RixPQUFKLEdBQWMsNkJBQTZCLGNBQUlBLE9BQS9DO0FBYm1FOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0J0RSxlQXZ5QlM7O0FBeXlCVjs7Ozs7Ozs7Ozs7O0FBWU15RixjQUFBQSxjQXJ6QkksMEJBcXpCV2xLLElBcnpCWCxFQXF6QnlCaUssUUFyekJ6QixFQXF6QjREO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlDQUU1QzVPLGNBQWMsQ0FBQ2lKLEdBQUcsQ0FBQ00sYUFBTCxFQUFvQjVFLElBQXBCLENBRjhCOztBQUFBO0FBRTVEbEQsMEJBQUFBLE9BRjREOztBQUFBLDhCQUc3RG1OLFFBSDZEO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsaUNBSXJDM0YsR0FBRyxDQUFDNEQsZUFBSixFQUpxQzs7QUFBQTtBQUkxREMsMEJBQUFBLFlBSjBEO0FBQUEsMENBS3pENUcsWUFMeUQ7QUFBQTtBQUFBLGlDQU14RGpILGNBQWMsQ0FBQytOLFdBQWYsQ0FBMkJ2TCxPQUEzQixFQUFvQ3FMLFlBQXBDLENBTndEOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDBDQVMzRDVHLFlBVDJEO0FBQUE7QUFBQSxpQ0FTeENqSCxjQUFjLENBQUMrTixXQUFmLENBQTJCdkwsT0FBM0IsRUFBb0NtTixRQUFwQyxDQVR3Qzs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBV2xFLHdDQUFJeEYsT0FBSixHQUFjLDRCQUE0QixjQUFJQSxPQUE5QztBQVhrRTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNyRSxlQW4wQlM7O0FBcTBCVjs7Ozs7Ozs7Ozs7QUFXTTBGLGNBQUFBLHFCQWgxQkksaUNBZzFCa0JuSyxJQWgxQmxCLEVBZzFCa0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQ25Ec0IsVUFEbUQ7QUFBQSwwQ0FFbERoSCxjQUZrRDtBQUFBO0FBQUEsaUNBR2hEZSxjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0I1RSxJQUFwQixDQUhrQzs7QUFBQTtBQUFBO0FBQUE7QUFBQSwrQ0FFbkNvSyxrQkFGbUM7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTTNELGVBdDFCUzs7QUF3MUJWOzs7Ozs7Ozs7OztBQVdNQyxjQUFBQSxtQkFuMkJJLCtCQW0yQmdCckssSUFuMkJoQixFQW0yQitDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQ3hDdUIsWUFEd0M7QUFBQSwwQ0FFL0NqSCxjQUYrQztBQUFBO0FBQUEsaUNBRzdDZSxjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0I1RSxJQUFwQixDQUgrQjs7QUFBQTtBQUFBO0FBQUE7QUFBQSwrQ0FFaENzSyxnQkFGZ0M7O0FBQUE7QUFBQTtBQUNqRGpNLDBCQUFBQSxNQURpRDtBQUFBLDZEQU1oRHJGLGlCQUFpQixDQUFDcUYsTUFBRCxDQU4rQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU94RCxlQTEyQlM7O0FBNDJCVjs7Ozs7Ozs7Ozs7QUFXTWtNLGNBQUFBLHVCQXYzQkksbUNBdTNCb0J2SyxJQXYzQnBCLEVBdTNCbUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQ3BEdUIsWUFEb0Q7QUFBQSwwQ0FFbkRqSCxjQUZtRDtBQUFBO0FBQUEsaUNBR2pEZSxjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0I1RSxJQUFwQixDQUhtQzs7QUFBQTtBQUFBO0FBQUE7QUFBQSwrQ0FFcEN3SyxvQkFGb0M7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTTVELGVBNzNCUzs7QUErM0JWOzs7Ozs7Ozs7O0FBVU1DLGNBQUFBLHdCQXo0Qkksc0NBeTRCd0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQ3pDbEosWUFEeUM7QUFBQTtBQUFBLGlDQUN0QmpILGNBQWMsQ0FBQ21RLHdCQUFmLEVBRHNCOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVqRCxlQTM0QlM7O0FBNjRCVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Qk1DLGNBQUFBLGFBcDZCSSx5QkFvNkJVMUssSUFwNkJWLEVBbzZCNkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlDQUMvQjNFLGNBQWMsQ0FBQ2lKLEdBQUcsQ0FBQ00sYUFBTCxFQUFvQjVFLElBQXBCLENBRGlCOztBQUFBO0FBQy9DbEQsMEJBQUFBLE9BRCtDO0FBQUE7QUFBQSxpQ0FFNUJ3SCxHQUFHLENBQUNpRyx1QkFBSixDQUE0QnpOLE9BQTVCLENBRjRCOztBQUFBO0FBRS9DNk4sMEJBQUFBLFVBRitDO0FBQUE7QUFBQSxpQ0FHckNyUSxjQUFjLENBQUNvUSxhQUFmLENBQTZCNU4sT0FBN0IsQ0FIcUM7O0FBQUE7QUFHL0M4TiwwQkFBQUEsQ0FIK0M7QUFJL0NDLDBCQUFBQSxRQUorQyxHQUlwQ2pOLFFBQVEsQ0FBQ2dOLENBQUMsQ0FBQ0MsUUFBSCxDQUo0QjtBQUsvQ0MsMEJBQUFBLGVBTCtDLEdBSzdCbE4sUUFBUSxDQUFDZ04sQ0FBQyxDQUFDRSxlQUFILENBTHFCO0FBTS9DQywwQkFBQUEsU0FOK0MsR0FNbkNuTixRQUFRLENBQUNnTixDQUFDLENBQUNHLFNBQUgsQ0FOMkI7QUFPL0NDLDBCQUFBQSxlQVArQyxHQU83QnBOLFFBQVEsQ0FBQ2dOLENBQUMsQ0FBQ0ksZUFBSCxDQVBxQjtBQVEvQ0MsMEJBQUFBLGlCQVIrQyxHQVEzQnJOLFFBQVEsQ0FBQ2dOLENBQUMsQ0FBQ0ssaUJBQUgsQ0FSbUI7QUFTL0NDLDBCQUFBQSwwQkFUK0MsR0FTbEJ0TixRQUFRLENBQUNnTixDQUFDLENBQUNNLDBCQUFILENBVFU7QUFBQSw2REFVOUM7QUFDTHBPLDRCQUFBQSxPQUFPLEVBQVBBLE9BREs7QUFFTCtOLDRCQUFBQSxRQUFRLEVBQVJBLFFBRks7QUFHTEMsNEJBQUFBLGVBQWUsRUFBZkEsZUFISztBQUlMRSw0QkFBQUEsZUFBZSxFQUFmQSxlQUpLO0FBS0xDLDRCQUFBQSxpQkFBaUIsRUFBakJBLGlCQUxLO0FBTUxGLDRCQUFBQSxTQUFTLEVBQVRBLFNBTks7QUFPTEosNEJBQUFBLFVBQVUsRUFBVkEsVUFQSztBQVFMTyw0QkFBQUEsMEJBQTBCLEVBQTFCQTtBQVJLLDJCQVY4Qzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQW9CdEQsZUF4N0JTOztBQTA3QlY7Ozs7Ozs7Ozs7QUFVTUMsY0FBQUEsY0FwOEJJLDRCQW84QnlDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQzNDQywwQkFBQUEsV0FEMkMsR0FDN0IsRUFENkI7QUFBQSwwQ0FFdEM3SixZQUZzQztBQUFBO0FBQUEsaUNBRW5CakgsY0FBYyxDQUFDK1Esd0JBQWYsRUFGbUI7O0FBQUE7QUFBQTtBQUU3Q3JMLDBCQUFBQSxJQUY2Qzs7QUFBQTtBQUFBLGdDQUcxQ0EsSUFBSSxLQUFLeEgsYUFIaUM7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxpQ0FJdEI4TCxHQUFHLENBQUNvRyxhQUFKLENBQWtCMUssSUFBbEIsQ0FKc0I7O0FBQUE7QUFJekNzTCwwQkFBQUEsVUFKeUM7QUFLL0NGLDBCQUFBQSxXQUFXLENBQUMzTCxJQUFaLENBQWlCNkwsVUFBakI7QUFMK0MsMENBTXhDL0osWUFOd0M7QUFBQTtBQUFBLGlDQU1yQmpILGNBQWMsQ0FBQ2lSLHVCQUFmLENBQXVDdkwsSUFBdkMsQ0FOcUI7O0FBQUE7QUFBQTtBQU0vQ0EsMEJBQUFBLElBTitDO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDZEQVExQ29MLFdBUjBDOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU2xELGVBNzhCUzs7QUErOEJWOzs7Ozs7Ozs7O0FBVU1JLGNBQUFBLGlCQXo5QkksK0JBeTlCbUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQ3BDbEssVUFEb0M7QUFBQTtBQUFBLGlDQUNuQnBILFVBQVUsQ0FBQ3VSLE1BQVgsRUFEbUI7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRTVDLGVBMzlCUzs7QUE2OUJWOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCTUMsY0FBQUEsV0E5K0JJLHlCQTgrQjZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FDaEJwSCxHQUFHLENBQUNrSCxpQkFBSixFQURnQjs7QUFBQTtBQUMvQkMsMEJBQUFBLE1BRCtCO0FBQUE7QUFBQSxpQ0FFTm5ILEdBQUcsQ0FBQzhCLG1CQUFKLEVBRk07O0FBQUE7QUFFL0J1RiwwQkFBQUEsZ0JBRitCO0FBQUE7QUFBQSxpQ0FHTnJILEdBQUcsQ0FBQzZCLGNBQUosRUFITTs7QUFBQTtBQUcvQnlGLDBCQUFBQSxnQkFIK0I7QUFBQTtBQUFBLGlDQUlMdEgsR0FBRyxDQUFDdUgsb0JBQUosRUFKSzs7QUFBQTtBQUkvQkMsMEJBQUFBLGlCQUorQjtBQUFBO0FBQUEsaUNBS0R4SCxHQUFHLENBQUNtRyx3QkFBSixFQUxDOztBQUFBO0FBSy9Cc0IsMEJBQUFBLHFCQUwrQjtBQUFBO0FBQUEsaUNBTUN6SCxHQUFHLENBQUMyQiwwQkFBSixFQU5EOztBQUFBO0FBTS9CQywwQkFBQUEsdUJBTitCO0FBQUEsNkRBTzlCO0FBQ0x1Riw0QkFBQUEsTUFBTSxFQUFOQSxNQURLO0FBRUxFLDRCQUFBQSxnQkFBZ0IsRUFBaEJBLGdCQUZLO0FBR0xDLDRCQUFBQSxnQkFBZ0IsRUFBaEJBLGdCQUhLO0FBSUxFLDRCQUFBQSxpQkFBaUIsRUFBakJBLGlCQUpLO0FBS0xDLDRCQUFBQSxxQkFBcUIsRUFBckJBLHFCQUxLO0FBTUw3Riw0QkFBQUEsdUJBQXVCLEVBQXZCQTtBQU5LLDJCQVA4Qjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWV0QyxlQTcvQlM7O0FBKy9CVjs7Ozs7Ozs7OztBQVVNOEYsY0FBQUEsY0F6Z0NJLDRCQXlnQzhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBDQUMvQnpLLFlBRCtCO0FBQUE7QUFBQSxpQ0FDWm5ILGFBQWEsQ0FBQzZSLFdBQWQsRUFEWTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFdkMsZUEzZ0NTOztBQTZnQ1Y7Ozs7Ozs7Ozs7QUFVTUMsY0FBQUEsZ0JBdmhDSSw4QkF1aENnQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQ0FDakMzSyxZQURpQztBQUFBO0FBQUEsaUNBQ2RuSCxhQUFhLENBQUMrUixhQUFkLEVBRGM7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRXpDLGVBemhDUzs7QUEyaENWOzs7Ozs7Ozs7O0FBVU1qRSxjQUFBQSxlQXJpQ0ksNkJBcWlDK0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQ2hDM0csWUFEZ0M7QUFBQTtBQUFBLGlDQUNibkgsYUFBYSxDQUFDK04sWUFBZCxFQURhOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUV4QyxlQXZpQ1M7O0FBeWlDVjs7Ozs7Ozs7OztBQVVNaUUsY0FBQUEsNEJBbmpDSSwwQ0FtakM2QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQ0FDOUM5SyxVQUQ4QztBQUFBO0FBQUEsaUNBQzdCbEgsYUFBYSxDQUFDaVMsdUJBQWQsRUFENkI7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRXRELGVBcmpDUzs7QUF1akNWOzs7Ozs7Ozs7O0FBVU1DLGNBQUFBLHlCQWprQ0ksdUNBaWtDeUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQzFDL0ssWUFEMEM7QUFBQTtBQUFBLGlDQUN2Qm5ILGFBQWEsQ0FBQ21TLHNCQUFkLEVBRHVCOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVsRCxlQW5rQ1M7O0FBcWtDVjs7Ozs7Ozs7OztBQVVNQyxjQUFBQSx1QkEva0NJLHFDQStrQ3VDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBDQUN4Q2pMLFlBRHdDO0FBQUE7QUFBQSxpQ0FDckJuSCxhQUFhLENBQUNxUyxvQkFBZCxFQURxQjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFaEQsZUFqbENTOztBQW1sQ1Y7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQk1DLGNBQUFBLG1CQW5tQ0ksaUNBbW1Dc0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlDQUN6QnBJLEdBQUcsQ0FBQzBILGNBQUosRUFEeUI7O0FBQUE7QUFDeEMxTSwwQkFBQUEsTUFEd0M7QUFBQTtBQUFBLGlDQUU3QmdGLEdBQUcsQ0FBQzRELGVBQUosRUFGNkI7O0FBQUE7QUFFeENuRCwwQkFBQUEsRUFGd0M7QUFBQTtBQUFBLGlDQUdwQlQsR0FBRyxDQUFDOEgsNEJBQUosRUFIb0I7O0FBQUE7QUFHeENPLDBCQUFBQSxXQUh3QztBQUFBO0FBQUEsaUNBSVhySSxHQUFHLENBQUNrSSx1QkFBSixFQUpXOztBQUFBO0FBSXhDQywwQkFBQUEsb0JBSndDO0FBQUE7QUFBQSxpQ0FLckJuSSxHQUFHLENBQUNnSSx5QkFBSixFQUxxQjs7QUFBQTtBQUt4Q00sMEJBQUFBLFVBTHdDO0FBQUEsNkRBTXZDO0FBQ0w3SCw0QkFBQUEsRUFBRSxFQUFGQSxFQURLO0FBRUw0SCw0QkFBQUEsV0FBVyxFQUFYQSxXQUZLO0FBR0xGLDRCQUFBQSxvQkFBb0IsRUFBcEJBLG9CQUhLO0FBSUxuTiw0QkFBQUEsTUFBTSxFQUFOQSxNQUpLO0FBS0xzTiw0QkFBQUEsVUFBVSxFQUFWQTtBQUxLLDJCQU51Qzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWEvQyxlQWhuQ1M7QUFrbkNKQyxjQUFBQSxrQkFsbkNJLDhCQWtuQ2VDLFNBbG5DZixFQWtuQzBCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUNBQ3BCMVMsYUFBYSxDQUFDMlMsZUFBZCxDQUE4QkQsU0FBOUIsQ0FEb0I7O0FBQUE7QUFBQSw2RUFDc0IsQ0FEdEI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFbkMsZUFwbkNTOztBQXNuQ1Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJNRSxjQUFBQSxTQW5wQ0ksdUJBbXBDaUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEzQ2hLLDBCQUFBQSxFQUEyQyw2RUFBdENvQixNQUFNLENBQUNqQyxTQUErQjtBQUFBLDBDQVM1Q2xILEtBVDRDO0FBQUE7QUFBQSxpQ0FVakRqQixtQkFBbUIsQ0FBQ2lULE9BQXBCLENBQTRCakssRUFBNUIsQ0FWaUQ7O0FBQUE7QUFBQTtBQUFBLDBDQVd2RG9CLE1BQU0sQ0FBQ3JHLEdBWGdEO0FBQUE7QUFBQSwrQ0FTdENGLFlBVHNDOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFhMUQsZUFocUNTOztBQWtxQ1Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJNcVAsY0FBQUEsZUEvckNJLDZCQStyQ3VEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBM0NsSywwQkFBQUEsRUFBMkMsNkVBQXRDb0IsTUFBTSxDQUFDakMsU0FBK0I7QUFBQTtBQUFBO0FBQUEsaUNBRXhDL0gsYUFBYSxDQUFDOFMsZUFBZCxDQUE4QmxLLEVBQTlCLENBRndDOztBQUFBO0FBRXZEbEYsMEJBQUFBLE1BRnVEOztBQUFBLCtCQUd6RGtGLEVBQUUsQ0FBQzBHLFlBSHNEO0FBQUE7QUFBQTtBQUFBOztBQUFBLDZEQUlwRDVMLE1BSm9EOztBQUFBO0FBQUE7QUFBQSxpQ0FNaEQ3QyxLQUFLLENBQUM0QyxZQUFOLENBQW1CQyxNQUFuQixFQUEyQnNHLE1BQU0sQ0FBQ3JHLEdBQWxDLENBTmdEOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBUTdELHdDQUFJMEcsT0FBSixHQUFjLDZCQUE2QixjQUFJQSxPQUEvQztBQVI2RDs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdoRSxlQTFzQ1M7QUE0c0NKMEksY0FBQUEsNEJBNXNDSSx3Q0E2c0NSdkcsTUE3c0NRLEVBOHNDUjVELEVBOXNDUSxFQStzQ1k7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDZG9LLDBCQUFBQSxLQURjLEdBQ054TSxJQUFJLENBQUNnRyxNQUFELENBREU7QUFBQTtBQUFBLGlDQUVDOU0sYUFBYSxDQUFDdVQsT0FBZCxDQUFzQjNTLFdBQVcsQ0FBQ29DLE9BQWxDLEVBQTJDc1EsS0FBM0Msa0NBQ2hCaEosTUFBTSxDQUFDakMsU0FEUyxHQUVoQmEsRUFGZ0IsRUFGRDs7QUFBQTtBQUVkbEYsMEJBQUFBLE1BRmM7O0FBQUEsK0JBTWhCa0YsRUFBRSxDQUFDMEcsWUFOYTtBQUFBO0FBQUE7QUFBQTs7QUFBQSw2REFPWDVMLE1BUFc7O0FBQUE7QUFBQTtBQUFBLGlDQVVQN0MsS0FBSyxDQUFDNEMsWUFBTixDQUFtQkMsTUFBbkIsRUFBMkJzRyxNQUFNLENBQUNyRyxHQUFsQyxDQVZPOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXckIsZUExdENTOztBQTR0Q1Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCTXVQLGNBQUFBLFVBMXZDSSxzQkEwdkNPQyxRQTF2Q1AsRUEwdkM0RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTNDdkssMEJBQUFBLEVBQTJDLDZFQUF0Q29CLE1BQU0sQ0FBQ2pDLFNBQStCO0FBQUE7QUFBQTtBQUFBLGlDQUU3Q3pILFdBQVcsQ0FBQzRTLFVBQVosQ0FBdUJDLFFBQXZCLGtDQUNoQm5KLE1BQU0sQ0FBQ2pDLFNBRFMsR0FFaEJhLEVBRmdCLEVBRjZDOztBQUFBO0FBRTVEbEYsMEJBQUFBLE1BRjREOztBQUFBLCtCQU05RGtGLEVBQUUsQ0FBQzBHLFlBTjJEO0FBQUE7QUFBQTtBQUFBOztBQUFBLDZEQU96RDVMLE1BUHlEOztBQUFBO0FBQUE7QUFBQSxpQ0FTckQ3QyxLQUFLLENBQUM0QyxZQUFOLENBQW1CQyxNQUFuQixFQUEyQnNHLE1BQU0sQ0FBQ3JHLEdBQWxDLENBVHFEOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBV2xFLHdDQUFJMEcsT0FBSixHQUFjLHdCQUF3QixjQUFJQSxPQUExQztBQVhrRTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNyRSxlQXh3Q1M7O0FBMHdDVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJNK0ksY0FBQUEsdUJBeHlDSSxtQ0F3eUNvQnhOLElBeHlDcEIsRUF3eUM4QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FFOUIzRSxjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0I1RSxJQUFwQixDQUZnQjs7QUFBQTtBQUU5Q2xELDBCQUFBQSxPQUY4QztBQUFBLDBDQUc3Q3lFLFlBSDZDO0FBQUE7QUFBQSxpQ0FJNUN6SCxhQUFhLENBQUNrTyxTQUFkLENBQXdCbEwsT0FBeEIsRUFBaUNwQyxXQUFXLENBQUNvQyxPQUE3QyxDQUo0Qzs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBT3BELHdDQUFJMkgsT0FBSixHQUFjLHFDQUFxQyxjQUFJQSxPQUF2RDtBQVBvRDs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVV2RCxlQWx6Q1M7O0FBb3pDVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJNZ0osY0FBQUEsMEJBbDFDSSxzQ0FrMUN1QnpOLElBbDFDdkIsRUFrMUNpRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FFakMzRSxjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0I1RSxJQUFwQixDQUZtQjs7QUFBQTtBQUVqRGxELDBCQUFBQSxPQUZpRDtBQUFBLDBDQUdoRHlFLFlBSGdEO0FBQUE7QUFBQSxpQ0FJL0N6SCxhQUFhLENBQUNrTyxTQUFkLENBQXdCbEwsT0FBeEIsRUFBaUN4QyxjQUFjLENBQUN3QyxPQUFoRCxDQUorQzs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBT3ZELHdDQUFJMkgsT0FBSixHQUFjLHdDQUF3QyxjQUFJQSxPQUExRDtBQVB1RDs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVUxRCxlQTUxQ1M7O0FBODFDVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCTWlKLGNBQUFBLElBNzNDSSxnQkE4M0NSQyxXQTkzQ1EsRUErM0NSQyxRQS8zQ1EsRUFpNENZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEcEI1SywwQkFBQUEsRUFDb0IsNkVBRGZvQixNQUFNLENBQUNqQyxTQUNRO0FBQUE7QUFBQTtBQUFBLGlDQUVDSSxhQUFhLENBQUM2QixNQUFNLENBQUNyRyxHQUFSLGtDQUMzQmxELGFBRDJCO0FBRTlCc0gsNEJBQUFBLFNBQVMsRUFBRWlDLE1BQU0sQ0FBQ2pDLFNBRlk7QUFHOUJyRiw0QkFBQUEsT0FBTyxFQUFFNlE7QUFIcUIsNkJBRmQ7O0FBQUE7QUFFWi9TLDBCQUFBQSxJQUZZO0FBQUE7QUFBQSxpQ0FPR0EsSUFBSSxDQUFDOFMsSUFBTCxDQUFVRSxRQUFWLGtDQUNoQnhKLE1BQU0sQ0FBQ2pDLFNBRFMsR0FFaEJhLEVBRmdCLEVBUEg7O0FBQUE7QUFPWmxGLDBCQUFBQSxNQVBZOztBQUFBLCtCQVdka0YsRUFBRSxDQUFDMEcsWUFYVztBQUFBO0FBQUE7QUFBQTs7QUFBQSw2REFZVDVMLE1BWlM7O0FBQUE7QUFBQTtBQUFBLGlDQWNMN0MsS0FBSyxDQUFDNEMsWUFBTixDQUFtQkMsTUFBbkIsRUFBMkJzRyxNQUFNLENBQUNyRyxHQUFsQyxDQWRLOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBZ0JsQix3Q0FBSTBHLE9BQUosR0FBYyxrQkFBa0IsY0FBSUEsT0FBcEM7QUFoQmtCOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBbUJyQixlQXA1Q1M7O0FBczVDVjs7Ozs7Ozs7Ozs7O0FBWU1vSixjQUFBQSxhQWw2Q0kseUJBbTZDUjVELFFBbjZDUSxFQXE2Q1M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURqQmpILDBCQUFBQSxFQUNpQiw2RUFEWm9CLE1BQU0sQ0FBQ2pDLFNBQ0s7QUFBQTtBQUFBLGlDQUNKN0gsY0FBYyxDQUFDdVQsYUFBZixDQUE2QjVELFFBQTdCLGtDQUNSN0YsTUFBTSxDQUFDakMsU0FEQyxHQUVSYSxFQUZRLEVBREk7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtsQixlQTE2Q1M7QUE0NkNKOEssY0FBQUEsc0JBNTZDSSxrQ0E2NkNSbEgsTUE3NkNRLEVBODZDUjVELEVBOTZDUSxFQSs2Q1k7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDZG9LLDBCQUFBQSxLQURjLEdBQ054TSxJQUFJLENBQUNnRyxNQUFELENBREU7QUFBQTtBQUFBLGlDQUVDOU0sYUFBYSxDQUFDdVQsT0FBZCxDQUNuQi9TLGNBQWMsQ0FBQ3dDLE9BREksRUFFbkJzUSxLQUZtQixrQ0FJZGhKLE1BQU0sQ0FBQ2pDLFNBSk8sR0FLZGEsRUFMYyxFQUZEOztBQUFBO0FBRWRsRiwwQkFBQUEsTUFGYzs7QUFBQSwrQkFVaEJrRixFQUFFLENBQUMwRyxZQVZhO0FBQUE7QUFBQTtBQUFBOztBQUFBLDZEQVdYNUwsTUFYVzs7QUFBQTtBQUFBO0FBQUEsaUNBY1A3QyxLQUFLLENBQUM0QyxZQUFOLENBQW1CQyxNQUFuQixFQUEyQnNHLE1BQU0sQ0FBQ3JHLEdBQWxDLENBZE87O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWVyQixlQTk3Q1M7QUFnOENKZ1EsY0FBQUEsdUJBaDhDSSxtQ0FpOENScEgsRUFqOENRLEVBazhDUkMsTUFsOENRLEVBbThDUjVELEVBbjhDUSxFQW84Q1k7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDZG9LLDBCQUFBQSxLQURjLEdBQ054TSxJQUFJLENBQUNnRyxNQUFELENBREU7QUFBQSwwQ0FFQ3RNLGNBRkQ7QUFBQSwwQ0FHbEI4UyxLQUhrQjtBQUFBO0FBQUEsaUNBSVovUixjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0IrQixFQUFwQixDQUpGOztBQUFBO0FBQUE7QUFBQSwwRUFNYnZDLE1BQU0sQ0FBQ2pDLFNBTk0sR0FPYmEsRUFQYTtBQUFBO0FBQUEsK0NBRWdCZ0wsSUFGaEI7O0FBQUE7QUFFZGxRLDBCQUFBQSxNQUZjOztBQUFBLCtCQVdoQmtGLEVBQUUsQ0FBQzBHLFlBWGE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkRBWVg1TCxNQVpXOztBQUFBO0FBQUE7QUFBQSxpQ0FlUDdDLEtBQUssQ0FBQzRDLFlBQU4sQ0FBbUJDLE1BQW5CLEVBQTJCc0csTUFBTSxDQUFDckcsR0FBbEMsQ0FmTzs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0JyQixlQXA5Q1M7O0FBczlDVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ01rUSxjQUFBQSxZQXovQ0ksd0JBMC9DUnJILE1BMS9DUSxFQTIvQ1JELEVBMy9DUSxFQTQvQ1J1SCxxQkE1L0NRLEVBNi9DUkMscUJBNy9DUSxFQTgvQ1JDLHNCQTkvQ1EsRUErL0NSQyxzQkEvL0NRLEVBZ2dEUnJMLEVBaGdEUSxFQWlnRFk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDZG9LLDBCQUFBQSxLQURjLEdBQ054TSxJQUFJLENBQUNnRyxNQUFELENBREU7QUFBQSwwQ0FFQ3RNLGNBRkQ7QUFBQSwwQ0FHbEI4UyxLQUhrQjtBQUFBO0FBQUEsaUNBSVovUixjQUFjLENBQUNpSixHQUFHLENBQUNNLGFBQUwsRUFBb0IrQixFQUFwQixDQUpGOztBQUFBO0FBQUE7QUFBQSwwQ0FLbEJ1SCxxQkFMa0I7QUFBQSwwQ0FNbEJDLHFCQU5rQjtBQUFBLDBDQU9sQkMsc0JBUGtCO0FBQUEsMENBUWxCQyxzQkFSa0I7QUFBQSwwRUFVYmpLLE1BQU0sQ0FBQ2pDLFNBVk0sR0FXYmEsRUFYYTtBQUFBO0FBQUEsK0NBRWdCaUwsWUFGaEI7O0FBQUE7QUFFZG5RLDBCQUFBQSxNQUZjOztBQUFBLCtCQWVoQmtGLEVBQUUsQ0FBQzBHLFlBZmE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkRBZ0JYNUwsTUFoQlc7O0FBQUE7QUFBQTtBQUFBLGlDQW1CUDdDLEtBQUssQ0FBQzRDLFlBQU4sQ0FBbUJDLE1BQW5CLEVBQTJCc0csTUFBTSxDQUFDckcsR0FBbEMsQ0FuQk87O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQW9CckIsZUFyaERTOztBQXVoRFY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Qk11USxjQUFBQSxXQWhqREksdUJBaWpEUkMsWUFqakRRLEVBa2pEUkMsVUFsakRRLEVBbWpEUkMsVUFuakRRLEVBcWpEUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRGpCekwsMEJBQUFBLEVBQ2lCLGdGQURab0IsTUFBTSxDQUFDakMsU0FDSztBQUNqQmEsMEJBQUFBLEVBQUUsQ0FBQzZELEtBQUgsR0FBVzdELEVBQUUsQ0FBQzZELEtBQUgsR0FBVzdELEVBQUUsQ0FBQzZELEtBQWQsR0FBc0IsR0FBakM7QUFDTTZILDBCQUFBQSxPQUZXLEdBRUQsR0FGQztBQUdYQywwQkFBQUEsV0FIVyxHQUdHdkssTUFBTSxDQUFDMUksSUFBUCxDQUFZNlMsWUFBWixDQUhIO0FBSVhLLDBCQUFBQSxTQUpXLEdBSUMzVCxLQUFLLENBQUNRLGFBQU4sQ0FBb0JrVCxXQUFwQixFQUFpQ0gsVUFBakMsQ0FKRDtBQUtYSywwQkFBQUEsV0FMVyxHQUtHNVQsS0FBSyxDQUFDZ0Isa0JBQU4sQ0FBeUIyUyxTQUF6QixFQUFvQ0gsVUFBcEMsQ0FMSDtBQUFBLDBDQU1WSyxJQU5VO0FBQUEsMENBT2YxTixRQVBlO0FBQUE7QUFBQSxpQ0FRUGdELE1BQU0sQ0FBQ3JHLEdBQVAsQ0FBV3VRLFdBQVgsQ0FBdUI7QUFDM0IzSCw0QkFBQUEsRUFBRSxFQUFFdkMsTUFBTSxDQUFDM0gsU0FBUCxDQUFpQjhSLFlBQWpCLEVBQStCelIsT0FEUjtBQUUzQnFHLDRCQUFBQSxJQUFJLEVBQUVpQixNQUFNLENBQUNqQyxTQUFQLENBQWlCZ0IsSUFGSTtBQUczQjBELDRCQUFBQSxLQUFLLEVBQUU3RCxFQUFFLENBQUM2RCxLQUhpQjtBQUkzQm5HLDRCQUFBQSxJQUFJLEVBQUVtTztBQUpxQiwyQkFBdkIsQ0FSTzs7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQ0FjWEgsT0FkVztBQUFBO0FBQUEsMkVBTUxLLEtBTks7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFnQmxCLGVBcmtEUztBQXVrRFZDLGNBQUFBLFdBdmtEVSx1QkF3a0RSVCxZQXhrRFEsRUF5a0RSQyxVQXprRFEsRUEwa0RSQyxVQTFrRFEsRUEya0RBO0FBQ1Isb0JBQU1FLFdBQVcsR0FBR3ZLLE1BQU0sQ0FBQzFJLElBQVAsQ0FBWTZTLFlBQVosQ0FBcEI7QUFDQSxvQkFBTUssU0FBUyxHQUFHM1QsS0FBSyxDQUFDUSxhQUFOLENBQW9Ca1QsV0FBcEIsRUFBaUNILFVBQWpDLENBQWxCO0FBQ0EsdUJBQU92VCxLQUFLLENBQUNnQixrQkFBTixDQUF5QjJTLFNBQXpCLEVBQW9DSCxVQUFwQyxDQUFQO0FBQ0QsZUEva0RTO0FBaWxESlEsY0FBQUEsY0FqbERJLDBCQWlsRFdqTSxFQWpsRFgsRUFpbERlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ2pCMEwsMEJBQUFBLE9BRGlCLEdBQ1AsR0FETztBQUFBLDBDQUVoQkksSUFGZ0I7QUFBQSwwQ0FHckIxTixRQUhxQjtBQUFBO0FBQUEsaUNBSWJnRCxNQUFNLENBQUNyRyxHQUFQLENBQVd1USxXQUFYLG1CQUNEdEwsRUFEQyxFQUphOztBQUFBO0FBQUE7QUFBQTtBQUFBLDBDQU9qQjBMLE9BUGlCO0FBQUE7QUFBQSwyRUFFWEssS0FGVzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVN4QixlQTFsRFM7QUE0bERKRyxjQUFBQSxlQTVsREksNkJBNGxEdUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEzQ2xNLDBCQUFBQSxFQUEyQyxnRkFBdENvQixNQUFNLENBQUNqQyxTQUErQjtBQUFBO0FBQUEsaUNBQzFDaUMsTUFBTSxDQUFDckcsR0FBUCxDQUFXbVIsZUFBWCxpQ0FDaEI5SyxNQUFNLENBQUNqQyxTQURTLEdBRWhCYSxFQUZnQixFQUQwQzs7QUFBQTtBQUN6RGxGLDBCQUFBQSxNQUR5RDs7QUFBQSwrQkFNM0RrRixFQUFFLENBQUMwRyxZQU53RDtBQUFBO0FBQUE7QUFBQTs7QUFBQSw2REFPdEQ1TCxNQVBzRDs7QUFBQTtBQUFBO0FBQUEsaUNBVWxEN0MsS0FBSyxDQUFDNEMsWUFBTixDQUFtQkMsTUFBbkIsRUFBMkJzRyxNQUFNLENBQUNyRyxHQUFsQyxDQVZrRDs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBV2hFLGVBdm1EUzs7QUF5bURWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCTXVMLGNBQUFBLE1BdG9ESSxrQkFzb0RHMUMsTUF0b0RILEVBc29EOEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEzQzVELDBCQUFBQSxFQUEyQyxnRkFBdENvQixNQUFNLENBQUNqQyxTQUErQjtBQUFBO0FBQUEsaUNBQ2pEN0gsY0FBYyxDQUFDZ1AsTUFBZixDQUFzQjFDLE1BQXRCLGtDQUNoQnhDLE1BQU0sQ0FBQ2pDLFNBRFMsR0FFaEJhLEVBRmdCLEVBRGlEOztBQUFBO0FBQ2hFbEYsMEJBQUFBLE1BRGdFOztBQUFBLCtCQU1sRWtGLEVBQUUsQ0FBQzBHLFlBTitEO0FBQUE7QUFBQTtBQUFBOztBQUFBLDZEQU83RDVMLE1BUDZEOztBQUFBO0FBQUE7QUFBQSxpQ0FVekQ3QyxLQUFLLENBQUM0QyxZQUFOLENBQW1CQyxNQUFuQixFQUEyQnNHLE1BQU0sQ0FBQ3JHLEdBQWxDLENBVnlEOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXdkUsZUFqcERTOztBQW1wRFY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NNb1IsY0FBQUEsY0FuckRJLDBCQW9yRFJ2SSxNQXByRFEsRUFxckRSZ0QsVUFyckRRLEVBc3JEUkMsVUF0ckRRLEVBd3JEWTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRHBCN0csMEJBQUFBLEVBQ29CLGdGQURmb0IsTUFBTSxDQUFDakMsU0FDUTtBQUFBO0FBQUEsaUNBQ0M3SCxjQUFjLENBQUM2VSxjQUFmLENBQ25CdkksTUFEbUIsRUFFbkJnRCxVQUZtQixFQUduQkMsVUFIbUIsa0NBS2R6RixNQUFNLENBQUNqQyxTQUxPLEdBTWRhLEVBTmMsRUFERDs7QUFBQTtBQUNkbEYsMEJBQUFBLE1BRGM7O0FBQUEsK0JBV2hCa0YsRUFBRSxDQUFDMEcsWUFYYTtBQUFBO0FBQUE7QUFBQTs7QUFBQSw2REFZWDVMLE1BWlc7O0FBQUE7QUFBQTtBQUFBLGlDQWVQN0MsS0FBSyxDQUFDNEMsWUFBTixDQUFtQkMsTUFBbkIsRUFBMkJzRyxNQUFNLENBQUNyRyxHQUFsQyxDQWZPOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFnQnJCLGVBeHNEUzs7QUEwc0RWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDTXFSLGNBQUFBLGVBMXVESSwyQkEydURSckUsU0EzdURRLEVBMnVEVztBQUNuQkYsY0FBQUEsUUE1dURRLEVBNHVEVTtBQUNsQndFLGNBQUFBLGVBN3VEUSxFQSt1RFk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURwQnJNLDBCQUFBQSxFQUNvQixnRkFEZm9CLE1BQU0sQ0FBQ2pDLFNBQ1E7QUFBQSwwQ0FFUGxILEtBRk87QUFBQTtBQUFBLGlDQUdaWCxjQUFjLENBQUNnUixVQUFmLENBQ0oxSyxJQUFJLENBQUNtSyxTQUFELENBREEsRUFFSm5LLElBQUksQ0FBQ2lLLFFBQUQsQ0FGQSxFQUdKakssSUFBSSxDQUFDeU8sZUFBRCxDQUhBLEVBSUpyTSxFQUpJLENBSFk7O0FBQUE7QUFBQTtBQUFBLDBDQVNsQm9CLE1BQU0sQ0FBQ3JHLEdBVFc7QUFBQTtBQUFBLCtDQUVERixZQUZDOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXckIsZUExdkRTOztBQTR2RFY7Ozs7Ozs7Ozs7QUFVTWdPLGNBQUFBLG9CQXR3REksa0NBc3dEb0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBQ3JDdEssWUFEcUM7QUFBQTtBQUFBLGlDQUNsQi9HLE1BQU0sQ0FBQ3NSLGlCQUFQLEVBRGtCOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUU3QyxlQXh3RFM7O0FBMHdEVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJNd0QsY0FBQUEsYUF4eURJLHlCQXl5RFJDLFlBenlEUSxFQTJ5RFk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURwQnZNLDBCQUFBQSxFQUNvQixnRkFEZm9CLE1BQU0sQ0FBQ2pDLFNBQ1E7O0FBQUEsZ0NBQ2hCLE9BQU9vTixZQUFQLEtBQXdCLFdBRFI7QUFBQTtBQUFBO0FBQUE7O0FBQUEsZ0NBRVosSUFBSWpSLEtBQUosQ0FBVSxrQ0FBVixDQUZZOztBQUFBO0FBSWhCeUcsMEJBQUFBLEVBSmdCLEdBSVhuRSxJQUFJLENBQUMyTyxZQUFELENBSk87QUFBQTtBQUFBLGlDQUtEalYsY0FBYyxDQUFDZ1YsYUFBZixDQUE2QjFSLFFBQVEsQ0FBQ21ILEVBQUQsQ0FBckMsRUFBMkMvQixFQUEzQyxDQUxDOztBQUFBO0FBS2hCbEYsMEJBQUFBLE1BTGdCOztBQUFBLCtCQU9oQmtGLEVBQUUsQ0FBQzBHLFlBUGE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkRBUVg1TCxNQVJXOztBQUFBO0FBQUE7QUFBQSxpQ0FXUDdDLEtBQUssQ0FBQzRDLFlBQU4sQ0FBbUJDLE1BQW5CLEVBQTJCc0csTUFBTSxDQUFDckcsR0FBbEMsQ0FYTzs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWXJCLGVBdnpEUzs7QUF5ekRWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQk15UixjQUFBQSwyQkF4MURJLHVDQXkxRFJDLFVBejFEUSxFQTIxRFk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURwQnpNLDBCQUFBQSxFQUNvQixnRkFEZm9CLE1BQU0sQ0FBQ2pDLFNBQ1E7QUFDWjRDLDBCQUFBQSxFQURZLEdBQ2tCMEssVUFEbEIsQ0FDWjFLLEVBRFksRUFDUjZCLE1BRFEsR0FDa0I2SSxVQURsQixDQUNSN0ksTUFEUSxFQUNBdUMsYUFEQSxHQUNrQnNHLFVBRGxCLENBQ0F0RyxhQURBO0FBQUE7QUFBQSxpQ0FHTzdFLEdBQUcsQ0FBQzRELGVBQUosRUFIUDs7QUFBQTtBQUdkQywwQkFBQUEsWUFIYzs7QUFBQSxnQ0FNaEJnQixhQUFhLEdBQUdoQixZQU5BO0FBQUE7QUFBQTtBQUFBOztBQUFBLGdDQU9aLElBQUk3SixLQUFKLENBQVUsOENBQVYsQ0FQWTs7QUFBQTtBQUFBLGdDQVFUc0ksTUFBTSxLQUFLLEdBUkY7QUFBQTtBQUFBO0FBQUE7O0FBQUEsZ0NBU1osSUFBSXRJLEtBQUosQ0FBVSw4Q0FBVixDQVRZOztBQUFBO0FBQUEsZ0NBVVRzSSxNQUFNLEdBQUcsQ0FWQTtBQUFBO0FBQUE7QUFBQTs7QUFBQSxnQ0FXWixJQUFJdEksS0FBSixDQUFVLDJCQUFWLENBWFk7O0FBQUE7QUFjaEJ3SywwQkFBQUEsZUFkZ0IsR0FjRWxJLElBQUksQ0FBQ21FLEVBQUQsQ0FkTjtBQUFBO0FBQUEsaUNBZUN6SyxjQUFjLENBQUNnVixhQUFmLENBQ25CMVIsUUFBUSxDQUFDa0wsZUFBRCxDQURXLEVBRW5COUYsRUFGbUIsQ0FmRDs7QUFBQTtBQWVkbEYsMEJBQUFBLE1BZmM7O0FBQUEsK0JBbUJoQmtGLEVBQUUsQ0FBQzBHLFlBbkJhO0FBQUE7QUFBQTtBQUFBOztBQUFBLDZEQW9CWDVMLE1BcEJXOztBQUFBO0FBQUE7QUFBQSxpQ0FzQlA3QyxLQUFLLENBQUM0QyxZQUFOLENBQW1CQyxNQUFuQixFQUEyQnNHLE1BQU0sQ0FBQ3JHLEdBQWxDLENBdEJPOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1QnJCLGVBbDNEUzs7QUFvM0RWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCTTJSLGNBQUFBLFlBajVESSwwQkFpNURvRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTNDMU0sMEJBQUFBLEVBQTJDLGdGQUF0Q29CLE1BQU0sQ0FBQ2pDLFNBQStCO0FBQUE7QUFBQSxpQ0FDekM3SCxjQUFjLENBQUNvVixZQUFmLENBQTRCMU0sRUFBNUIsQ0FEeUM7O0FBQUE7QUFDeERsRiwwQkFBQUEsTUFEd0Q7O0FBQUEsK0JBRXhEa0YsRUFBRSxDQUFDMEcsWUFGcUQ7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkRBR25ENUwsTUFIbUQ7O0FBQUE7QUFBQTtBQUFBLGlDQUsvQzdDLEtBQUssQ0FBQzRDLFlBQU4sQ0FBbUJDLE1BQW5CLEVBQTJCc0csTUFBTSxDQUFDckcsR0FBbEMsQ0FMK0M7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU03RCxlQXY1RFM7QUF5NURKNFIsY0FBQUEsY0F6NURJLDBCQXk1RFc1SyxFQXo1RFgsRUF5NURlNkssS0F6NURmLEVBeTVEc0JDLFFBejVEdEIsRUF5NURnQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlDQUMzQi9VLGNBQWMsQ0FBQ2dWLE1BQWYsQ0FBc0IvSyxFQUF0QixFQUEwQjZLLEtBQTFCLEVBQWlDQyxRQUFqQyxDQUQyQjs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRXpDO0FBMzVEUyxhQW5DUDtBQUFBLCtDQWk4REU7QUFDTEUsY0FBQUEsTUFBTSxFQUFFNUwsaUJBREg7QUFFTEMsY0FBQUEsTUFBTSxFQUFOQSxNQUZLO0FBR0xFLGNBQUFBLEdBQUcsRUFBSEEsR0FISztBQUlMckosY0FBQUEsS0FBSyxFQUFMQSxLQUpLO0FBS0xpSixjQUFBQSxNQUFNLEVBQU5BLE1BTEs7QUFNTDhMLGNBQUFBLFNBQVMsRUFBRTtBQUNUdlgsZ0JBQUFBLFdBQVcsRUFBWEEsV0FEUztBQUVURCxnQkFBQUEsYUFBYSxFQUFiQSxhQUZTO0FBR1RHLGdCQUFBQSxnQkFBZ0IsRUFBaEJBLGdCQUhTO0FBSVRLLGdCQUFBQSxpQkFBaUIsRUFBakJBLGlCQUpTO0FBS1ROLGdCQUFBQSxxQkFBcUIsRUFBckJBLHFCQUxTO0FBTVR1RyxnQkFBQUEsY0FBYyxFQUFkQTtBQU5TO0FBTk4sYUFqOERGOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXRoIGZyb20gJ2V0aGpzJ1xuaW1wb3J0IFNpZ25lclByb3ZpZGVyIGZyb20gJ2V0aGpzLXByb3ZpZGVyLXNpZ25lcidcbmltcG9ydCBFdGhlcmV1bVR4IGZyb20gJ2V0aGVyZXVtanMtdHgnXG5pbXBvcnQge1xuICBkZWNvZGVQYXJhbXMsXG4gIGRlY29kZUV2ZW50LFxuICBlbmNvZGVNZXRob2QsXG4gIGVuY29kZVNpZ25hdHVyZSxcbn0gZnJvbSAnZXRoanMtYWJpJ1xuaW1wb3J0IEVOUyBmcm9tICdldGhqcy1lbnMnXG5cbmltcG9ydCBMaXZlcGVlclRva2VuQXJ0aWZhY3QgZnJvbSAnLi4vZXRjL0xpdmVwZWVyVG9rZW4nXG5pbXBvcnQgTGl2ZXBlZXJUb2tlbkZhdWNldEFydGlmYWN0IGZyb20gJy4uL2V0Yy9MaXZlcGVlclRva2VuRmF1Y2V0J1xuaW1wb3J0IENvbnRyb2xsZXJBcnRpZmFjdCBmcm9tICcuLi9ldGMvQ29udHJvbGxlcidcbmltcG9ydCBSb3VuZHNNYW5hZ2VyQXJ0aWZhY3QgZnJvbSAnLi4vZXRjL1JvdW5kc01hbmFnZXInXG5pbXBvcnQgQm9uZGluZ01hbmFnZXJBcnRpZmFjdCBmcm9tICcuLi9ldGMvQm9uZGluZ01hbmFnZXInXG5pbXBvcnQgTWludGVyQXJ0aWZhY3QgZnJvbSAnLi4vZXRjL01pbnRlcidcbmltcG9ydCBQb2xsQ3JlYXRvckFydGlmYWN0IGZyb20gJy4uL2V0Yy9Qb2xsQ3JlYXRvcidcbmltcG9ydCBQb2xsQXJ0aWZhY3QgZnJvbSAnLi4vZXRjL1BvbGwnXG5pbXBvcnQgTWVya2xlU25hcHNob3RBcnRpZmFjdCBmcm9tICcuLi9ldGMvTWVya2xlU25hcHNob3QnXG5pbXBvcnQgeyBWSURFT19QUk9GSUxFUyB9IGZyb20gJy4vdmlkZW9fcHJvZmlsZXMuanMnXG5cbi8vIENvbnN0YW50c1xuXG5leHBvcnQgeyBWSURFT19QUk9GSUxFUyB9XG5leHBvcnQgY29uc3QgRU1QVFlfQUREUkVTUyA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG5leHBvcnQgY29uc3QgQUREUkVTU19QQUQgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG5leHBvcnQgY29uc3QgVklERU9fUFJPRklMRV9JRF9TSVpFID0gOFxuXG5jb25zdCBERUxFR0FUT1JfU1RBVFVTID0gWydQZW5kaW5nJywgJ0JvbmRlZCcsICdVbmJvbmRlZCcsICdVbmJvbmRpbmcnXVxuREVMRUdBVE9SX1NUQVRVUy5QZW5kaW5nID0gREVMRUdBVE9SX1NUQVRVU1swXVxuREVMRUdBVE9SX1NUQVRVUy5Cb25kZWQgPSBERUxFR0FUT1JfU1RBVFVTWzFdXG5ERUxFR0FUT1JfU1RBVFVTLlVuYm9uZGVkID0gREVMRUdBVE9SX1NUQVRVU1syXVxuREVMRUdBVE9SX1NUQVRVUy5VbmJvbmRpbmcgPSBERUxFR0FUT1JfU1RBVFVTWzNdXG5leHBvcnQgeyBERUxFR0FUT1JfU1RBVFVTIH1cbmNvbnN0IFRSQU5TQ09ERVJfU1RBVFVTID0gWydOb3RSZWdpc3RlcmVkJywgJ1JlZ2lzdGVyZWQnXVxuVFJBTlNDT0RFUl9TVEFUVVMuTm90UmVnaXN0ZXJlZCA9IFRSQU5TQ09ERVJfU1RBVFVTWzBdXG5UUkFOU0NPREVSX1NUQVRVUy5SZWdpc3RlcmVkID0gVFJBTlNDT0RFUl9TVEFUVVNbMV1cbmV4cG9ydCB7IFRSQU5TQ09ERVJfU1RBVFVTIH1cblxuLy8gRGVmYXVsdHNcbmV4cG9ydCBjb25zdCBERUZBVUxUUyA9IHtcbiAgY29udHJvbGxlckFkZHJlc3M6ICcweGY5NmQ1NGU0OTAzMTdjNTU3YTk2N2FiZmE1ZDZlMzMwMDZiZTY5YjMnLFxuICBwb2xsQ3JlYXRvckFkZHJlc3M6ICcweGJmODI0ZWRiNmI5NGQ5YjUyZDk3MmQ1YjI1YmNjMTliNGU2ZTNmM2MnLFxuICBwcm92aWRlcjogcHJvY2Vzcy5lbnYuSU5GVVJBX0VORFBPSU5ULFxuICBwcml2YXRlS2V5czoge30sIC8vIHsgW3B1YmxpY0tleTogc3RyaW5nXTogcHJpdmF0ZUtleSB9XG4gIGFjY291bnQ6ICcnLFxuICBnYXM6IG51bGwsXG4gIGFydGlmYWN0czoge1xuICAgIExpdmVwZWVyVG9rZW46IExpdmVwZWVyVG9rZW5BcnRpZmFjdCxcbiAgICBMaXZlcGVlclRva2VuRmF1Y2V0OiBMaXZlcGVlclRva2VuRmF1Y2V0QXJ0aWZhY3QsXG4gICAgQ29udHJvbGxlcjogQ29udHJvbGxlckFydGlmYWN0LFxuICAgIFJvdW5kc01hbmFnZXI6IFJvdW5kc01hbmFnZXJBcnRpZmFjdCxcbiAgICBCb25kaW5nTWFuYWdlcjogQm9uZGluZ01hbmFnZXJBcnRpZmFjdCxcbiAgICBNaW50ZXI6IE1pbnRlckFydGlmYWN0LFxuICAgIFBvbGxDcmVhdG9yOiBQb2xsQ3JlYXRvckFydGlmYWN0LFxuICAgIFBvbGw6IFBvbGxBcnRpZmFjdCxcbiAgICBNZXJrbGVTbmFwc2hvdDogTWVya2xlU25hcHNob3RBcnRpZmFjdCxcbiAgfSxcbiAgZW5zUmVnaXN0cmllczoge1xuICAgIC8vIE1haW5uZXRcbiAgICAxOiAnMHgzMTQxNTkyNjVkZDhkYmIzMTA2NDJmOThmNTBjMDY2MTczYzEyNTliJyxcbiAgICAvLyBSb3BzdGVuXG4gICAgMzogJzB4MTEyMjM0NDU1YzNhMzJmZDExMjMwYzQyZTdiY2NkNGE4NGUwMjAxMCcsXG4gICAgLy8gUmlua2VieVxuICAgIDQ6ICcweGU3NDEwMTcwZjg3MTAyZGYwMDU1ZWIxOTUxNjNhMDNiN2YyYmZmNGEnLFxuICB9LFxufVxuXG4vLyBVdGlsc1xuZXhwb3J0IGNvbnN0IHV0aWxzID0ge1xuICBpc1ZhbGlkQWRkcmVzczogKHgpID0+IC9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KHgpLFxuICByZXNvbHZlQWRkcmVzczogYXN5bmMgKHJlc29sdmUsIHgpID0+XG4gICAgdXRpbHMuaXNWYWxpZEFkZHJlc3MoeCkgPyB4IDogYXdhaXQgcmVzb2x2ZSh4KSxcbiAgZ2V0TWV0aG9kSGFzaDogKGl0ZW0pID0+IHtcbiAgICAvLyBjb25zdCBzaWcgPSBgJHtpdGVtLm5hbWV9KCR7aXRlbS5pbnB1dHMubWFwKHggPT4geC50eXBlKS5qb2luKCcsJyl9KWBcbiAgICAvLyBjb25zdCBoYXNoID0gRXRoLmtlY2NhazI1NihzaWcpXG4gICAgLy8gcmV0dXJuIGhhc2hcbiAgICByZXR1cm4gZW5jb2RlU2lnbmF0dXJlKGl0ZW0pXG4gIH0sXG4gIGZpbmRBYmlCeU5hbWU6IChhYmlzLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgW2FiaV0gPSBhYmlzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0udHlwZSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoaXRlbS5uYW1lID09PSBuYW1lKSByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgcmV0dXJuIGFiaVxuICB9LFxuICBmaW5kQWJpQnlIYXNoOiAoYWJpcywgaGFzaCkgPT4ge1xuICAgIGNvbnN0IFthYmldID0gYWJpcy5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnR5cGUgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZVxuICAgICAgcmV0dXJuIGVuY29kZVNpZ25hdHVyZShpdGVtKSA9PT0gaGFzaFxuICAgIH0pXG4gICAgcmV0dXJuIGFiaVxuICB9LFxuICBlbmNvZGVNZXRob2RQYXJhbXM6IChhYmksIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBlbmNvZGVNZXRob2QoYWJpLCBwYXJhbXMpXG4gIH0sXG4gIGRlY29kZU1ldGhvZFBhcmFtczogKGFiaSwgYnl0ZWNvZGUpID0+IHtcbiAgICByZXR1cm4gZGVjb2RlUGFyYW1zKFxuICAgICAgYWJpLmlucHV0cy5tYXAoKHgpID0+IHgubmFtZSksXG4gICAgICBhYmkuaW5wdXRzLm1hcCgoeCkgPT4geC50eXBlKSxcbiAgICAgIGAweCR7Ynl0ZWNvZGUuc3Vic3RyKDEwKX1gLFxuICAgICAgZmFsc2UsXG4gICAgKVxuICB9LFxuICBkZWNvZGVDb250cmFjdElucHV0OiAoY29udHJhY3RzLCBjb250cmFjdEFkZHJlc3MsIGlucHV0KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29udHJhY3RzKSB7XG4gICAgICBjb25zdCBjb250cmFjdCA9IGNvbnRyYWN0c1trZXldXG4gICAgICBpZiAoY29udHJhY3QuYWRkcmVzcyAhPT0gY29udHJhY3RBZGRyZXNzKSBjb250aW51ZVxuICAgICAgY29uc3QgaGFzaCA9IGlucHV0LnN1YnN0cmluZygwLCAxMClcbiAgICAgIGNvbnN0IGFiaSA9IHV0aWxzLmZpbmRBYmlCeUhhc2goY29udHJhY3QuYWJpLCBoYXNoKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3Q6IGtleSxcbiAgICAgICAgbWV0aG9kOiBhYmkubmFtZSxcbiAgICAgICAgcGFyYW1zOiBPYmplY3QuZW50cmllcyh1dGlscy5kZWNvZGVNZXRob2RQYXJhbXMoYWJpLCBpbnB1dCkpLnJlZHVjZShcbiAgICAgICAgICAob2JqLCBbaywgdl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm9iaixcbiAgICAgICAgICAgICAgW2tdOiBBcnJheS5pc0FycmF5KHYpXG4gICAgICAgICAgICAgICAgPyB2Lm1hcCgoX3YpID0+IChCTi5pc0JOKF92KSA/IHRvU3RyaW5nKF92KSA6IF92KSlcbiAgICAgICAgICAgICAgICA6IEJOLmlzQk4odilcbiAgICAgICAgICAgICAgICA/IHRvU3RyaW5nKHYpXG4gICAgICAgICAgICAgICAgOiB2LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge30sXG4gICAgICAgICksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnRyYWN0OiAnJywgbWV0aG9kOiAnJywgcGFyYW1zOiB7fSB9XG4gIH0sXG4gIC8qKlxuICAgKiBQb2xscyBmb3IgYSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAqIEBpZ25vcmVcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgdHhIYXNoIC0gdGhlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICogQHBhcmFtIHtFdGh9ICAgICAgZXRoICAgIC0gYW4gaW5zdGFuY2Ugb2YgRXRoanNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0VHhSZWNlaXB0OiBhc3luYyAodHhIYXNoLCBldGgpID0+IHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc2V0VGltZW91dChhc3luYyBmdW5jdGlvbiBwb2xsRm9yUmVjZWlwdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgZXRoLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpXG4gICAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNlaXB0LnN0YXR1cyA9PT0gJzB4MSdcbiAgICAgICAgICAgICAgPyAvLyBzdWNjZXNzXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KVxuICAgICAgICAgICAgICA6IC8vIGZhaWxcbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogYXdhaXQgZXRoLmdldFRyYW5zYWN0aW9uQnlIYXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0LnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0VGltZW91dChwb2xsRm9yUmVjZWlwdCwgMzAwKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICB9LCAwKVxuICAgIH0pXG4gIH0sXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gZW5jb2RlZCBzdHJpbmcgb2YgdHJhbnNjb2Rpbmcgb3B0aW9uc1xuICAgKiBAaWdub3JlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gb3B0cyAtIHRyYW5zY29kaW5nIG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBwYXJzZVRyYW5zY29kaW5nT3B0aW9uczogKG9wdHMpID0+IHtcbiAgICBjb25zdCBwcm9maWxlcyA9IE9iamVjdC52YWx1ZXMoVklERU9fUFJPRklMRVMpXG4gICAgY29uc3QgdmFsaWRIYXNoZXMgPSBuZXcgU2V0KHByb2ZpbGVzLm1hcCgoeCkgPT4geC5oYXNoKSlcbiAgICBsZXQgaGFzaGVzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdHMubGVuZ3RoOyBpICs9IFZJREVPX1BST0ZJTEVfSURfU0laRSkge1xuICAgICAgY29uc3QgaGFzaCA9IG9wdHMuc2xpY2UoaSwgaSArIFZJREVPX1BST0ZJTEVfSURfU0laRSlcbiAgICAgIGlmICghdmFsaWRIYXNoZXMuaGFzKGhhc2gpKSBjb250aW51ZVxuICAgICAgaGFzaGVzLnB1c2goaGFzaClcbiAgICB9XG4gICAgcmV0dXJuIGhhc2hlcy5tYXAoKHgpID0+IHByb2ZpbGVzLmZpbmQoKHsgaGFzaCB9KSA9PiB4ID09PSBoYXNoKSlcbiAgfSxcbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYSBsaXN0IG9mIHRyYW5zY29kaW5nIHByb2ZpbGVzIG5hbWUgaW50byBhIGhhc2hcbiAgICogQGlnbm9yZVxuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gbmFtZSAtIHRyYW5zY29kaW5nIHByb2ZpbGUgbmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBzZXJpYWxpemVUcmFuc2NvZGluZ1Byb2ZpbGVzOiAobmFtZXMpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4ubmV3IFNldCggLy8gZGVkdXBlIHByb2ZpbGVzXG4gICAgICAgIG5hbWVzLm1hcCgoeCkgPT5cbiAgICAgICAgICBWSURFT19QUk9GSUxFU1t4XVxuICAgICAgICAgICAgPyBWSURFT19QUk9GSUxFU1t4XS5oYXNoXG4gICAgICAgICAgICA6IFZJREVPX1BST0ZJTEVTLlAyNDBwMzBmcHM0eDMuaGFzaCxcbiAgICAgICAgKSxcbiAgICAgICksXG4gICAgXS5qb2luKCcnKVxuICB9LFxuICAvKipcbiAgICogUGFkcyBhbiBhZGRyZXNzIHdpdGggMHMgb24gdGhlIGxlZnQgKGZvciB0b3BpYyBlbmNvZGluZylcbiAgICogQGlnbm9yZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFkZHIgLSBhbiBFVEggYWRkcmVzc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBwYWRBZGRyZXNzOiAoYWRkcikgPT4gQUREUkVTU19QQUQgKyBhZGRyLnN1YnN0cigyKSxcbiAgLyoqXG4gICAqIEVuY29kZXMgYW4gZXZlbnQgZmlsdGVyIG9iamVjdCBpbnRvIGEgdG9waWMgbGlzdFxuICAgKiBAaWdub3JlXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBldmVudCAgIC0gYSBjb250cmFjdCBldmVudCBtZXRob2RcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIGZpbHRlcnMgLSBrZXkvdmFsdWUgbWFwIG9mIGluZGV4ZWQgZXZlbnQgcGFyYW1zXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICAgKi9cbiAgZW5jb2RlRXZlbnRUb3BpY3M6IChldmVudCwgZmlsdGVycykgPT4ge1xuICAgIHJldHVybiBldmVudC5hYmkuaW5wdXRzLnJlZHVjZShcbiAgICAgICh0b3BpY3MsIHsgaW5kZXhlZCwgbmFtZSwgdHlwZSB9LCBpKSA9PiB7XG4gICAgICAgIGlmICghaW5kZXhlZCkgcmV0dXJuIHRvcGljc1xuICAgICAgICBpZiAoIWZpbHRlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHJldHVybiBbLi4udG9waWNzLCBudWxsXVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnICYmICdzdHJpbmcnID09PSB0eXBlb2YgZmlsdGVyc1tuYW1lXSlcbiAgICAgICAgICByZXR1cm4gWy4uLnRvcGljcywgdXRpbHMucGFkQWRkcmVzcyhmaWx0ZXJzW25hbWVdKV1cbiAgICAgICAgcmV0dXJuIFsuLi50b3BpY3MsIGZpbHRlcnNbbmFtZV1dXG4gICAgICB9LFxuICAgICAgW2V2ZW50KCkub3B0aW9ucy5kZWZhdWx0RmlsdGVyT2JqZWN0LnRvcGljc1swXV0sXG4gICAgKVxuICB9LFxuICAvKipcbiAgICogVHVybnMgYSByYXcgZXZlbnQgbG9nIGludG8gYSByZXN1bHQgb2JqZWN0XG4gICAqIEBpZ25vcmVcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGV2ZW50ICAtIGEgY29udHJhY3QgZXZlbnQgbWV0aG9kXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBkYXRhICAgLSBieXRlY29kZSBmcm9tIGxvZ1xuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gdG9waWNzIC0gbGlzdCBvZiB0b3BpY3MgZm9yIGxvZyBxdWVyeVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBkZWNvZGVFdmVudDogKGV2ZW50KSA9PiAoeyBkYXRhLCB0b3BpY3MgfSkgPT4ge1xuICAgIHJldHVybiBkZWNvZGVFdmVudChldmVudC5hYmksIGRhdGEsIHRvcGljcywgZmFsc2UpXG4gIH0sXG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbi8vIGV0aGpzIHJldHVybnMgYSBSZXN1bHQgdHlwZSBmcm9tIHJwYyByZXF1ZXN0c1xuLy8gdGhlc2UgZnVuY3Rpb25zIGhlbHAgd2l0aCBmb3JtYXR0aW5nIHRob3NlIHZhbHVlc1xuY29uc3QgeyBCTiB9ID0gRXRoXG5jb25zdCB0b0JOID0gKG4pID0+IChCTi5pc0JOKG4pID8gbiA6IG5ldyBCTihuLnRvU3RyaW5nKDEwKSwgMTApKVxuY29uc3QgY29tcG9zZSA9ICguLi5mbnMpID0+IGZucy5yZWR1Y2UoKGYsIGcpID0+ICguLi5hcmdzKSA9PiBmKGcoLi4uYXJncykpKVxuY29uc3QgcHJvcCA9IChrOiBzdHJpbmcgfCBudW1iZXIpID0+ICh4KTogYW55ID0+IHhba11cbmNvbnN0IHRvQm9vbCA9ICh4OiBhbnkpOiBib29sZWFuID0+ICEheFxuY29uc3QgdG9TdHJpbmcgPSAoeDogRXRoLkJOKTogc3RyaW5nID0+IHgudG9TdHJpbmcoMTApXG5jb25zdCB0b051bWJlciA9ICh4OiBFdGguQk4pOiBzdHJpbmcgPT4gTnVtYmVyKHgudG9TdHJpbmcoMTApKVxuY29uc3QgaGVhZFRvQm9vbCA9IGNvbXBvc2UodG9Cb29sLCBwcm9wKDApKVxuY29uc3QgaGVhZFRvU3RyaW5nID0gY29tcG9zZSh0b1N0cmluZywgcHJvcCgwKSlcbmNvbnN0IGhlYWRUb051bWJlciA9IGNvbXBvc2UodG9OdW1iZXIsIHByb3AoMCkpXG5jb25zdCBpbnZhcmlhbnQgPSAobmFtZSwgcG9zLCB0eXBlKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBhcmd1bWVudCBcIiR7bmFtZX1cIiAoJHt0eXBlfSkgYXQgcG9zaXRpb24gJHtwb3N9YClcbn1cbmNvbnN0IGZvcm1hdER1cmF0aW9uID0gKG1zKSA9PiB7XG4gIGNvbnN0IHNlY29uZHMgPSAobXMgLyAxMDAwKS50b0ZpeGVkKDEpXG4gIGNvbnN0IG1pbnV0ZXMgPSAobXMgLyAoMTAwMCAqIDYwKSkudG9GaXhlZCgxKVxuICBjb25zdCBob3VycyA9IChtcyAvICgxMDAwICogNjAgKiA2MCkpLnRvRml4ZWQoMSlcbiAgY29uc3QgZGF5cyA9IChtcyAvICgxMDAwICogNjAgKiA2MCAqIDI0KSkudG9GaXhlZCgxKVxuICBpZiAoc2Vjb25kcyA8IDYwKSByZXR1cm4gc2Vjb25kcyArICcgc2VjJ1xuICBlbHNlIGlmIChtaW51dGVzIDwgNjApIHJldHVybiBtaW51dGVzICsgJyBtaW4nXG4gIGVsc2UgaWYgKGhvdXJzIDwgMjQpIHJldHVybiBob3VycyArICcgaG91cnMnXG4gIHJldHVybiBkYXlzICsgJyBkYXlzJ1xufVxuXG4vKipcbiAqIERlcGxveXMgY29udHJhY3QgYW5kIHJldHVybiBpbnN0YW5jZSBhdCBkZXBsb3llZCBhZGRyZXNzXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0geyp9IGV0aFxuICogQHBhcmFtIHsqfSBhcmdzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXBsb3lDb250cmFjdChcbiAgZXRoLFxuICB7IGFiaSwgYnl0ZWNvZGUsIGRlZmF1bHRUeCB9LFxuKTogUHJvbWlzZTxDb250cmFjdD4ge1xuICBjb25zdCBjb250cmFjdCA9IGV0aC5jb250cmFjdChhYmksIGJ5dGVjb2RlLCBkZWZhdWx0VHgpXG4gIGNvbnN0IHR4SGFzaCA9IGF3YWl0IGNvbnRyYWN0Lm5ldygpXG4gIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBldGguZ2V0VHJhbnNhY3Rpb25TdWNjZXNzKHR4SGFzaClcbiAgcmV0dXJuIGNvbnRyYWN0LmF0KHJlY2VpcHQuY29udHJhY3RBZGRyZXNzKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb250cmFjdCBpbnN0YW5jZSBmcm9tIGEgc3BlY2lmaWMgYWRkcmVzc1xuICogQGlnbm9yZVxuICogQHBhcmFtIHtFdGh9ICAgIGV0aCAgICAgLSBldGhqcyBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLVxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NbMF0gLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgcmVsZXZhbnQgTGl2ZXBlZXIgQXJ0aWZhY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFjdEF0KFxuICBldGgsXG4gIHsgYWJpLCBieXRlY29kZSwgYWRkcmVzcywgZGVmYXVsdFR4IH0sXG4pOiBDb250cmFjdCB7XG4gIHJldHVybiBldGguY29udHJhY3QoYWJpLCBieXRlY29kZSwgZGVmYXVsdFR4KS5hdChhZGRyZXNzKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgRXRoIGFuZCBhIGRlZmF1bHQgdHJhbnNhY3Rpb24gb2JqZWN0XG4gKiBAaWdub3JlXG4gKiBAcmV0dXJuIHt7IGV0LCBnYXM6IEV0aCwgZGVmYXVsdFR4OiB7IGZyb206IHN0cmluZywgZ2FzOiBudW1iZXIgfSB9fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdFJQQyh7XG4gIGFjY291bnQsXG4gIHByaXZhdGVLZXlzLFxuICBnYXMsXG4gIHByb3ZpZGVyLFxufSk6IFByb21pc2U8e1xuICBldGg6IEV0aCxcbiAgZGVmYXVsdFR4OiB7IGZyb206IHN0cmluZywgZ2FzOiBudW1iZXIgfSxcbn0+IHtcbiAgY29uc3QgdXNlUHJpdmF0ZUtleXMgPSAwIDwgT2JqZWN0LmtleXMocHJpdmF0ZUtleXMpLmxlbmd0aFxuICBjb25zdCBldGhqc1Byb3ZpZGVyID1cbiAgICAnb2JqZWN0JyA9PT0gdHlwZW9mIHByb3ZpZGVyICYmIHByb3ZpZGVyXG4gICAgICA/IHByb3ZpZGVyXG4gICAgICA6IHVzZVByaXZhdGVLZXlzXG4gICAgICA/IC8vIFVzZSBwcm92aWRlci1zaWduZXIgdG8gbG9jYWxseSBzaWduIHRyYW5zYWN0aW9uc1xuICAgICAgICBuZXcgU2lnbmVyUHJvdmlkZXIocHJvdmlkZXIsIHtcbiAgICAgICAgICBzaWduVHJhbnNhY3Rpb246IChyYXdUeCwgY2IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gbmV3IEV0aGVyZXVtVHgocmF3VHgpXG4gICAgICAgICAgICB0eC5zaWduKHByaXZhdGVLZXlzW2Zyb21dKVxuICAgICAgICAgICAgY2IobnVsbCwgJzB4JyArIHR4LnNlcmlhbGl6ZSgpLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFjY291bnRzOiAoY2IpID0+IGNiKG51bGwsIGFjY291bnRzKSxcbiAgICAgICAgICB0aW1lb3V0OiAxMCAqIDEwMDAsXG4gICAgICAgIH0pXG4gICAgICA6IC8vIFVzZSBkZWZhdWx0IHNpZ25lclxuICAgICAgICBuZXcgRXRoLkh0dHBQcm92aWRlcihwcm92aWRlciB8fCBERUZBVUxUUy5wcm92aWRlcilcbiAgY29uc3QgZXRoID0gbmV3IEV0aChldGhqc1Byb3ZpZGVyKVxuICBjb25zdCBlbnMgPSBuZXcgRU5TKHtcbiAgICBwcm92aWRlcjogZXRoLmN1cnJlbnRQcm92aWRlcixcbiAgICByZWdpc3RyeUFkZHJlc3M6IERFRkFVTFRTLmVuc1JlZ2lzdHJpZXNbYXdhaXQgZXRoLm5ldF92ZXJzaW9uKCldLFxuICB9KVxuICBjb25zdCBhY2NvdW50cyA9IHVzZVByaXZhdGVLZXlzXG4gICAgPyBPYmplY3Qua2V5cyhwcml2YXRlS2V5cylcbiAgICA6IGF3YWl0IGV0aC5hY2NvdW50cygpXG4gIGNvbnN0IGZyb20gPVxuICAgIC8vIHNlbGVjdCBhY2NvdW50IGJ5IGFkZHJlc3Mgb3IgaW5kZXhcbiAgICAvLyBkZWZhdWx0IHRvIEVNUFRZX0FERFJFU1MgKHJlYWQtb25seTsgY2Fubm90IHRyYW5zYWN0KVxuICAgIG5ldyBTZXQoYWNjb3VudHMpLmhhcyhhY2NvdW50KVxuICAgICAgPyBhY2NvdW50XG4gICAgICA6IGFjY291bnRzW2FjY291bnRdIHx8IEVNUFRZX0FERFJFU1NcbiAgcmV0dXJuIHtcbiAgICBldGgsXG4gICAgZW5zLFxuICAgIHByb3ZpZGVyLFxuICAgIGFjY291bnRzLFxuICAgIGRlZmF1bHRUeDoge1xuICAgICAgZnJvbSxcbiAgICAgIGdhcyxcbiAgICB9LFxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBpbnN0YW5jZXMgb2YgYWxsIG1haW4gTGl2ZXBlZXIgY29udHJhY3RzXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5wcm92aWRlciAgLSB0aGUgaHR0cFByb3ZpZGVyIGZvciBjb250cmFjdCBSUENcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmFydGlmYWN0cyAtIC4uLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdENvbnRyYWN0cyhcbiAgb3B0cyA9IHt9LFxuKTogUHJvbWlzZTxPYmplY3Q8c3RyaW5nLCBDb250cmFjdD4+IHtcbiAgLy8gTWVyZ2UgcGFzcyBvcHRpb25zIHdpdGggZGVmYXVsdHNcbiAgY29uc3Qge1xuICAgIGFjY291bnQgPSBERUZBVUxUUy5hY2NvdW50LFxuICAgIGFydGlmYWN0cyA9IERFRkFVTFRTLmFydGlmYWN0cyxcbiAgICBjb250cm9sbGVyQWRkcmVzcyA9IERFRkFVTFRTLmNvbnRyb2xsZXJBZGRyZXNzLFxuICAgIHBvbGxDcmVhdG9yQWRkcmVzcyA9IERFRkFVTFRTLnBvbGxDcmVhdG9yQWRkcmVzcyxcbiAgICBnYXMgPSBERUZBVUxUUy5nYXMsXG4gICAgcHJpdmF0ZUtleXMgPSBERUZBVUxUUy5wcml2YXRlS2V5cyxcbiAgICBwcm92aWRlciA9IERFRkFVTFRTLnByb3ZpZGVyLFxuICB9ID0gb3B0c1xuICAvLyBJbnN0YW5zdGlhdGUgbmV3IGV0aGpzIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHByb3ZpZGVyXG4gIGNvbnN0IHsgYWNjb3VudHMsIGRlZmF1bHRUeCwgZW5zLCBldGggfSA9IGF3YWl0IGluaXRSUEMoe1xuICAgIGFjY291bnQsXG4gICAgZ2FzLFxuICAgIHByaXZhdGVLZXlzLFxuICAgIHByb3ZpZGVyLFxuICB9KVxuICBjb25zdCBjb250cmFjdHMgPSB7XG4gICAgTGl2ZXBlZXJUb2tlbjogbnVsbCxcbiAgICBMaXZlcGVlclRva2VuRmF1Y2V0OiBudWxsLFxuICAgIEJvbmRpbmdNYW5hZ2VyOiBudWxsLFxuICAgIFJvdW5kc01hbmFnZXI6IG51bGwsXG4gICAgTWludGVyOiBudWxsLFxuICAgIE1lcmtsZVNuYXBzaG90OiBudWxsLFxuICB9XG4gIGNvbnN0IGhhc2hlcyA9IHtcbiAgICBMaXZlcGVlclRva2VuOiB7fSxcbiAgICBMaXZlcGVlclRva2VuRmF1Y2V0OiB7fSxcbiAgICBCb25kaW5nTWFuYWdlcjoge30sXG4gICAgUm91bmRzTWFuYWdlcjoge30sXG4gICAgTWludGVyOiB7fSxcbiAgICBNZXJrbGVTbmFwc2hvdDoge30sXG4gIH1cbiAgLy8gQ3JlYXRlIGEgQ29udHJvbGxlciBjb250cmFjdCBpbnN0YW5jZVxuICBjb25zdCBDb250cm9sbGVyID0gYXdhaXQgZ2V0Q29udHJhY3RBdChldGgsIHtcbiAgICAuLi5hcnRpZmFjdHMuQ29udHJvbGxlcixcbiAgICBkZWZhdWx0VHgsXG4gICAgYWRkcmVzczogY29udHJvbGxlckFkZHJlc3MsXG4gIH0pXG4gIC8vIENyZWF0ZSBhIFBvbGxDcmVhdG9yIGNvbnRyYWN0IGluc3RhbmNlXG4gIGNvbnN0IFBvbGxDcmVhdG9yID0gYXdhaXQgZ2V0Q29udHJhY3RBdChldGgsIHtcbiAgICAuLi5hcnRpZmFjdHMuUG9sbENyZWF0b3IsXG4gICAgZGVmYXVsdFR4LFxuICAgIGFkZHJlc3M6IHBvbGxDcmVhdG9yQWRkcmVzcyxcbiAgfSlcbiAgY29uc3QgUG9sbCA9IGF3YWl0IGdldENvbnRyYWN0QXQoZXRoLCB7XG4gICAgLi4uYXJ0aWZhY3RzLlBvbGwsXG4gICAgZGVmYXVsdFR4LFxuICAgIGFkZHJlc3M6IEVNUFRZX0FERFJFU1MsXG4gIH0pXG4gIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhjb250cmFjdHMpKSB7XG4gICAgLy8gR2V0IGNvbnRyYWN0IGFkZHJlc3MgZnJvbSBDb250cm9sbGVyXG4gICAgY29uc3QgaGFzaCA9IEV0aC5rZWNjYWsyNTYobmFtZSlcbiAgICBjb25zdCBhZGRyZXNzID0gKGF3YWl0IENvbnRyb2xsZXIuZ2V0Q29udHJhY3QoaGFzaCkpWzBdXG4gICAgLy8gQ3JlYXRlIGNvbnRyYWN0IGluc3RhbmNlXG4gICAgY29udHJhY3RzW25hbWVdID0gYXdhaXQgZ2V0Q29udHJhY3RBdChldGgsIHtcbiAgICAgIC4uLmFydGlmYWN0c1tuYW1lXSxcbiAgICAgIGRlZmF1bHRUeCxcbiAgICAgIGFkZHJlc3MsXG4gICAgfSlcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29udHJhY3RzW25hbWVdLmFiaSkge1xuICAgICAgaGFzaGVzW25hbWVdW3V0aWxzLmdldE1ldGhvZEhhc2goaXRlbSldID0gaXRlbS5uYW1lXG4gICAgfVxuICB9XG4gIC8vIEFkZCB0aGUgQ29udHJvbGxlciBjb250cmFjdCB0byB0aGUgY29udHJhY3RzIG9iamVjdFxuICBjb250cmFjdHMuQ29udHJvbGxlciA9IENvbnRyb2xsZXJcbiAgLy8gQWRkIHRoZSBQb2xsQ3JlYXRvciBjb250cmFjdCB0byB0aGUgY29udHJhY3RzIG9iamVjdFxuICBjb250cmFjdHMuUG9sbENyZWF0b3IgPSBQb2xsQ3JlYXRvclxuICAvLyBBZGQgdGhlIFBvbGxDcmVhdG9yIGNvbnRyYWN0IHRvIHRoZSBjb250cmFjdHMgb2JqZWN0XG4gIGNvbnRyYWN0cy5Qb2xsID0gUG9sbFxuXG4gIC8vIEtleSBBQklzIGJ5IGNvbnRyYWN0IG5hbWVcbiAgY29uc3QgYWJpcyA9IE9iamVjdC5lbnRyaWVzKGFydGlmYWN0cylcbiAgICAubWFwKChbaywgdl0pID0+ICh7IFtrXTogdi5hYmkgfSkpXG4gICAgLnJlZHVjZSgoYSwgYikgPT4gKHsgLi4uYSwgLi4uYiB9KSwge30pXG4gIC8vIENyZWF0ZSBhIGxpc3Qgb2YgZXZlbnRzIGluIGVhY2ggY29udHJhY3RcbiAgY29uc3QgZXZlbnRzID0gT2JqZWN0LmVudHJpZXMoYWJpcylcbiAgICAubWFwKChbY29udHJhY3QsIGFiaV0pID0+IHtcbiAgICAgIHJldHVybiBhYmlcbiAgICAgICAgLmZpbHRlcigoeCkgPT4geC50eXBlID09PSAnZXZlbnQnKVxuICAgICAgICAubWFwKChhYmkpID0+ICh7XG4gICAgICAgICAgYWJpLFxuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIGV2ZW50OiBjb250cmFjdHNbY29udHJhY3RdW2FiaS5uYW1lXSxcbiAgICAgICAgICBuYW1lOiBhYmkubmFtZSxcbiAgICAgICAgfSkpXG4gICAgfSlcbiAgICAucmVkdWNlKFxuICAgICAgKGEsIGIpID0+XG4gICAgICAgIGIucmVkdWNlKChldmVudHMsIHsgbmFtZSwgZXZlbnQsIGFiaSwgY29udHJhY3QgfSkgPT4ge1xuICAgICAgICAgIGV2ZW50LmFiaSA9IGFiaVxuICAgICAgICAgIGV2ZW50LmNvbnRyYWN0ID0gY29udHJhY3RcbiAgICAgICAgICByZXR1cm4geyAuLi5ldmVudHMsIFtuYW1lXTogZXZlbnQgfVxuICAgICAgICB9LCBhKSxcbiAgICAgIHt9LFxuICAgIClcblxuICByZXR1cm4ge1xuICAgIGFiaXMsXG4gICAgYWNjb3VudHMsXG4gICAgY29udHJhY3RzLFxuICAgIGRlZmF1bHRUeCxcbiAgICBlbnMsXG4gICAgZXRoLFxuICAgIGV2ZW50cyxcbiAgICBoYXNoZXMsXG4gIH1cbn1cblxuLyoqXG4gKiBMaXZlcGVlciBTREsgbWFpbiBtb2R1bGUgZXhwb3J0c1xuICogQG5hbWVzcGFjZSBtb2R1bGV+ZXhwb3J0c1xuICovXG5cbi8qKlxuICogTGl2ZXBlZXIgU0RLIGZhY3RvcnkgZnVuY3Rpb24uIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIExpdmVwZWVyIFNESyAtLSBhbiBvYmplY3Qgd2l0aCB1c2VmdWwgbWV0aG9kcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBMaXZlcGVlciBwcm90b2NvbCBzbWFydCBjb250cmFjdHNcbiAqIEBtZW1iZXJvZiBtb2R1bGV+ZXhwb3J0c1xuICogQG5hbWUgZGVmYXVsdFxuICogQHBhcmFtIHtMaXZlcGVlclNES09wdGlvbnN9IG9wdHMgLSBTREsgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlPExpdmVwZWVyU0RLPn1cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEhlcmUgd2UncmUgbmFtaW5nIHRoZSBkZWZhdWx0IGV4cG9ydCBcIkxpdmVwZWVyU0RLXCJcbiAqIGltcG9ydCBMaXZlcGVlclNESyBmcm9tICdAbGl2ZXBlZXIvc2RrJ1xuICpcbiAqIC8vIENhbGwgdGhlIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGF3YWl0IGl0cyBQcm9taXNlXG4gKiBMaXZlcGVlclNESygpLnRoZW4oc2RrID0+IHtcbiAqICAgLy8gWW91ciBMaXZlcGVlciBTREsgaW5zdGFuY2UgaXMgbm93IHJlYWR5IHRvIHVzZVxuICogfSlcbiAqXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVMaXZlcGVlclNESyhcbiAgb3B0czogTGl2ZXBlZXJTREtPcHRpb25zLFxuKTogUHJvbWlzZTxMaXZlcGVlclNESz4ge1xuICBjb25zdCB7IGVucywgZXZlbnRzLCAuLi5jb25maWcgfSA9IGF3YWl0IGluaXRDb250cmFjdHMob3B0cylcbiAgY29uc3Qge1xuICAgIEJvbmRpbmdNYW5hZ2VyLFxuICAgIENvbnRyb2xsZXIsXG4gICAgTGl2ZXBlZXJUb2tlbixcbiAgICBMaXZlcGVlclRva2VuRmF1Y2V0LFxuICAgIFJvdW5kc01hbmFnZXIsXG4gICAgTWludGVyLFxuICAgIFBvbGxDcmVhdG9yLFxuICAgIE1lcmtsZVNuYXBzaG90LFxuICB9ID0gY29uZmlnLmNvbnRyYWN0c1xuICBjb25zdCB7IHJlc29sdmVBZGRyZXNzIH0gPSB1dGlsc1xuXG4gIC8vIENhY2hlXG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIC8vIHByZXZpb3VzIGxvZyBxdWVyaWVzIGFyZSBoZWxkIGhlcmUgdG8gaW1wcm92ZSBwZXJmXG4gIH1cbiAgLyoqXG4gICAqIFwicnBjXCIgbmFtZXNwYWNlIG9mIGEgTGl2ZXBlZXIgU0RLIGluc3RhbmNlXG4gICAqIEBuYW1lc3BhY2UgbGl2ZXBlZXJ+cnBjXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGltcG9ydCBMaXZlcGVlclNESyBmcm9tICdAbGl2ZXBlZXIvc2RrJ1xuICAgKlxuICAgKiBMaXZlcGVlclNESygpLnRoZW4oKHsgcnBjIH0pID0+IHtcbiAgICogICAvLyBIZXJlLCB3ZSdyZSBkZXN0cnVjdHVyaW5nIHRoZSBzZGsgdG8gZXhwb3NlIG9ubHkgaXRzIHJwYyBuYW1lc3BhY2VcbiAgICogICAvLyBOb3csIHlvdSB5b3UgYXJlIGFibGUgY2FsbCBycGMuPG1ldGhvZC1uYW1lPigpXG4gICAqICAgLy8gQWxsIHJwYyBtZXRob2QgeWllbGQgUHJvbWlzZXMuIFRoZWlyIHVzYWdlIGlzIGZ1cnRoZXIgZXhwbGFpbmVkIGJlbG93LlxuICAgKiB9KVxuICAgKlxuICAgKi9cbiAgY29uc3QgcnBjID0ge1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEVOUyBuYW1lIGZvciBhbiBhZGRyZXNzLiBUaGlzIGlzIGtub3duIGFzIGEgcmV2ZXJzZSBsb29rdXAuXG4gICAgICogVW5mb3J0dW5hdGVseSwgdXNlcnMgbXVzdCBleHBsaWNpdGx5IHNldCB0aGVpciBvd24gcmVzb2x2ZXIuXG4gICAgICogU28gbW9zdCBvZiB0aGUgdGltZSwgdGhpcyBtZXRob2QganVzdCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZ1xuICAgICAqIE1vcmUgaW5mbyBoZXJlOlxuICAgICAqIChodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvZW4vbGF0ZXN0L3VzZXJndWlkZS5odG1sI3JldmVyc2UtbmFtZS1yZXNvbHV0aW9uKVxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIGFkZHJlc3MgdG8gbG9vayB1cCBhbiBFTlMgbmFtZSBmb3JcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldEVOU05hbWUoJzB4ZDM0ZGIzM2YuLi4nKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldEVOU05hbWUoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbnMucmV2ZXJzZShhZGRyZXNzKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGN1c3RvbSBuZXR3b3JrcyBvciB1bmF2YWlsYWJsZSByZXNvbHZlcnMgY2FuIGNhdXNlIGZhaWx1cmVcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlICE9PSAnRU5TIG5hbWUgbm90IGRlZmluZWQuJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBDb3VsZCBub3QgZ2V0IEVOUyBuYW1lIGZvciBhZGRyZXNzIFwiJHthZGRyZXNzfVwiOmAsXG4gICAgICAgICAgICBlcnIubWVzc2FnZSxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlcmUncyBubyBuYW1lLCB3ZSBjYW4ganVzdCByZXNvbHZlIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWRkcmVzcyBmb3IgYW4gRU5TIG5hbWVcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBFTlMgbmFtZSB0byBsb29rIHVwIGFuIGFkZHJlc3MgZm9yXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRFTlNBZGRyZXNzKCd2aXRhbGlrLmV0aCcpXG4gICAgICogLy8gPT4gc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RU5TQWRkcmVzcyhuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVucy5sb29rdXAobmFtZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBjdXN0b20gbmV0d29ya3Mgb3IgdW5hdmFpbGFibGUgcmVzb2x2ZXJzIGNhbiBjYXVzZSBmYWlsdXJlXG4gICAgICAgIGlmIChlcnIubWVzc2FnZSAhPT0gJ0VOUyBuYW1lIG5vdCBkZWZpbmVkLicpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgQ291bGQgbm90IGdldCBhZGRyZXNzIGZvciBFTlMgbmFtZSBcIiR7bmFtZX1cIjpgLFxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbmFtZSwgd2UgY2FuIGp1c3QgcmVzb2x2ZSBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBibG9jayBieSBudW1iZXIsIGhhc2gsIG9yIGtleXdvcmQgKCdlYXJsaWVzdCcgfCAnbGF0ZXN0JylcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJsb2NrIC0gTnVtYmVyIG9mIGJsb2NrIHRvIGdldFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRCbG9jaygnbGF0ZXN0JylcbiAgICAgKiAvLyA9PiB7XG4gICAgICogICBcIm51bWJlclwiOiBzdHJpbmcsXG4gICAgICogICBcImhhc2hcIjogc3RyaW5nLFxuICAgICAqICAgXCJwYXJlbnRIYXNoXCI6IHN0cmluZyxcbiAgICAgKiAgIFwibm9uY2VcIjogc3RyaW5nLFxuICAgICAqICAgXCJzaGEzVW5jbGVzXCI6IHN0cmluZyxcbiAgICAgKiAgIFwibG9nc0Jsb29tXCI6IHN0cmluZyxcbiAgICAgKiAgIFwidHJhbnNhY3Rpb25zUm9vdFwiOiBzdHJpbmcsXG4gICAgICogICBcInN0YXRlUm9vdFwiOiBzdHJpbmcsXG4gICAgICogICBcInJlY2VpcHRzUm9vdFwiOiBzdHJpbmcsXG4gICAgICogICBcIm1pbmVyXCI6IHN0cmluZyxcbiAgICAgKiAgIFwibWl4SGFzaFwiOiBzdHJpbmcsXG4gICAgICogICBcImRpZmZpY3VsdHlcIjogc3RyaW5nLFxuICAgICAqICAgXCJ0b3RhbERpZmZpY3VsdHlcIjogc3RyaW5nLFxuICAgICAqICAgXCJleHRyYURhdGFcIjogc3RyaW5nLFxuICAgICAqICAgXCJzaXplXCI6IHN0cmluZyxcbiAgICAgKiAgIFwiZ2FzTGltaXRcIjogc3RyaW5nLFxuICAgICAqICAgXCJnYXNVc2VkXCI6IHN0cmluZyxcbiAgICAgKiAgIFwidGltZXN0YW1wXCI6IG51bWJlcixcbiAgICAgKiAgIFwidHJhbnNhY3Rpb25zXCI6IEFycmF5PFRyYW5zYWN0aW9uPixcbiAgICAgKiAgIFwidHJhbnNhY3Rpb25zUm9vdFwiOiBzdHJpbmcsXG4gICAgICogICBcInVuY2xlc1wiOiBBcnJheTxVbmNsZT4sXG4gICAgICogfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKGlkOiBzdHJpbmcpOiBQcm9taXNlPEJsb2NrPiB7XG4gICAgICBjb25zdCBibG9jayA9IGlkLnRvU3RyaW5nKCkuc3RhcnRzV2l0aCgnMHgnKVxuICAgICAgICA/IGF3YWl0IGNvbmZpZy5ldGguZ2V0QmxvY2tCeUhhc2goaWQsIHRydWUpXG4gICAgICAgIDogYXdhaXQgY29uZmlnLmV0aC5nZXRCbG9ja0J5TnVtYmVyKGlkLCB0cnVlKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgIGRpZmZpY3VsdHk6IHRvU3RyaW5nKGJsb2NrLmRpZmZpY3VsdHkpLFxuICAgICAgICBnYXNMaW1pdDogdG9TdHJpbmcoYmxvY2suZ2FzTGltaXQpLFxuICAgICAgICBnYXNVc2VkOiB0b1N0cmluZyhibG9jay5nYXNVc2VkKSxcbiAgICAgICAgbnVtYmVyOiB0b1N0cmluZyhibG9jay5udW1iZXIpLFxuICAgICAgICBzaXplOiB0b1N0cmluZyhibG9jay5zaXplKSxcbiAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIodG9TdHJpbmcoYmxvY2sudGltZXN0YW1wKSksXG4gICAgICAgIHRvdGFsRGlmZmljdWx0eTogdG9TdHJpbmcoYmxvY2sudG90YWxEaWZmaWN1bHR5KSxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgRVRIIGJhbGFuY2UgZm9yIGFuIGFjY291bnRcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHIgLSBFVEggYWNjb3VudCBhZGRyZXNzXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRFdGhCYWxhbmNlKCcweGYwMC4uLicpXG4gICAgICogLy8gPT4gc3RyaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBhc3luYyBnZXRFdGhCYWxhbmNlKGFkZHI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcoXG4gICAgICAgIGF3YWl0IGNvbmZpZy5ldGguZ2V0QmFsYW5jZShcbiAgICAgICAgICBhd2FpdCByZXNvbHZlQWRkcmVzcyhycGMuZ2V0RU5TQWRkcmVzcywgYWRkciksXG4gICAgICAgICksXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHVuYm9uZGluZyBwZXJpb2QgZm9yIHRyYW5zY29kZXJzXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0VW5ib25kaW5nUGVyaW9kKClcbiAgICAgKiAvLyA9PiBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRVbmJvbmRpbmdQZXJpb2QoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHJldHVybiBoZWFkVG9TdHJpbmcoYXdhaXQgQm9uZGluZ01hbmFnZXIudW5ib25kaW5nUGVyaW9kKCkpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBhY3RpdmUgdHJhbnNjb2RlcnNcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXROdW1BY3RpdmVUcmFuc2NvZGVycygpXG4gICAgICogLy8gPT4gc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TnVtQWN0aXZlVHJhbnNjb2RlcnMoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHJldHVybiBoZWFkVG9TdHJpbmcoYXdhaXQgQm9uZGluZ01hbmFnZXIubnVtQWN0aXZlVHJhbnNjb2RlcnMoKSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWF4aW11bSBlYXJuaW5ncyBmb3IgY2xhaW1zIHJvdW5kc1xuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldE1heEVhcm5pbmdzQ2xhaW1zUm91bmRzKClcbiAgICAgKiAvLyA9PiBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRNYXhFYXJuaW5nc0NsYWltc1JvdW5kcygpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIGhlYWRUb1N0cmluZyhhd2FpdCBCb25kaW5nTWFuYWdlci5tYXhFYXJuaW5nc0NsYWltc1JvdW5kcygpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0b3RhbCBhbW91bnQgb2YgYm9uZGVkIHRva2Vuc1xuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0VG90YWxCb25kZWQoKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRvdGFsQm9uZGVkKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICByZXR1cm4gaGVhZFRvU3RyaW5nKGF3YWl0IEJvbmRpbmdNYW5hZ2VyLmdldFRvdGFsQm9uZGVkKCkpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRvdGFsIHN1cHBseSBvZiB0b2tlbiAoTFRQVSkgYXZhaWxhYmxlIGluIHRoZSBwcm90b2NvbFxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldFRva2VuVG90YWxTdXBwbHkoKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRva2VuVG90YWxTdXBwbHkoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHJldHVybiBoZWFkVG9TdHJpbmcoYXdhaXQgTGl2ZXBlZXJUb2tlbi50b3RhbFN1cHBseSgpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdXNlcidzIHRva2VuIGJhbGFuY2UgKExQVFUpXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYWRkciAtIHVzZXIncyBFVEggYWRkcmVzc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0VG9rZW5CYWxhbmNlKCcweGYwMC4uLicpXG4gICAgICogLy8gPT4gc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VG9rZW5CYWxhbmNlKGFkZHI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICByZXR1cm4gaGVhZFRvU3RyaW5nKFxuICAgICAgICBhd2FpdCBMaXZlcGVlclRva2VuLmJhbGFuY2VPZihcbiAgICAgICAgICBhd2FpdCByZXNvbHZlQWRkcmVzcyhycGMuZ2V0RU5TQWRkcmVzcywgYWRkciksXG4gICAgICAgICksXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgZ2VuZXJhbCBpbmZvcm1hdGlvbiBhYm91dCB0b2tlbnNcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBhZGRyIC0gdXNlcidzIEVUSCBhZGRyZXNzXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxUb2tlbkluZm8+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRUb2tlbkluZm8oKVxuICAgICAqIC8vID0+IFRva2VuSW5mbyB7IHRvdGFsU3VwcGx5OiBzdHJpbmcsIGJhbGFuY2U6IHN0cmluZyB9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0VG9rZW5JbmZvKGFkZHI6IHN0cmluZyk6IFByb21pc2U8VG9rZW5JbmZvPiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3RhbFN1cHBseTogYXdhaXQgcnBjLmdldFRva2VuVG90YWxTdXBwbHkoKSxcbiAgICAgICAgYmFsYW5jZTogYXdhaXQgcnBjLmdldFRva2VuQmFsYW5jZShcbiAgICAgICAgICBhd2FpdCByZXNvbHZlQWRkcmVzcyhycGMuZ2V0RU5TQWRkcmVzcywgYWRkciksXG4gICAgICAgICksXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVycyB0b2tlbnMgKExQVFUpIGZyb20gb25lIGFjY291bnQgdG8gYW5vdGhlclxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG8gLSB0aGUgYWNjb3VudCBFVEggYWRkcmVzcyB0byBzZW5kIHRva2VucyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIHRva2VuIHRvIHNlbmQgKExQVFUpXG4gICAgICogQHBhcmFtIHtUeENvbmZpZ30gW3R4ID0gY29uZmlnLmRlZmF1bHRUeF0gLSBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgYGZyb21gIGFuZCBgZ2FzYCB2YWx1ZXMgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxUeFJlY2VpcHQ+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy50cmFuc2ZlclRva2VuKCcweGYwMC4uLicsICcxMCcpXG4gICAgICogLy8gPT4gVHhSZWNlaXB0IHtcbiAgICAgKiAvLyAgIHRyYW5zYWN0aW9uSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgdHJhbnNhY3Rpb25JbmRleFwiOiBCTixcbiAgICAgKiAvLyAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgYmxvY2tOdW1iZXI6IEJOLFxuICAgICAqIC8vICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IEJOLFxuICAgICAqIC8vICAgZ2FzVXNlZDogQk4sXG4gICAgICogLy8gICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgICAgKiAvLyAgIGxvZ3M6IEFycmF5PExvZyB7XG4gICAgICogLy8gICAgIGxvZ0luZGV4OiBCTixcbiAgICAgKiAvLyAgICAgYmxvY2tOdW1iZXI6IEJOLFxuICAgICAqIC8vICAgICBibG9ja0hhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRyYW5zYWN0aW9uSW5kZXg6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgYWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgICBkYXRhOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRvcGljczogQXJyYXk8c3RyaW5nPlxuICAgICAqIC8vICAgfT5cbiAgICAgKiAvLyB9XG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmZXJUb2tlbihcbiAgICAgIHRvOiBzdHJpbmcsXG4gICAgICBhbW91bnQ6IHN0cmluZyxcbiAgICAgIHR4ID0gY29uZmlnLmRlZmF1bHRUeCxcbiAgICApOiBQcm9taXNlPFR4UmVjZWlwdD4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKGFtb3VudClcbiAgICAgIC8vIG1ha2Ugc3VyZSBiYWxhbmNlIGlzIGhpZ2hlciB0aGFuIHRyYW5zZmVyXG4gICAgICBjb25zdCBiYWxhbmNlID0gKGF3YWl0IExpdmVwZWVyVG9rZW4uYmFsYW5jZU9mKHR4LmZyb20pKVswXVxuICAgICAgaWYgKCFiYWxhbmNlLmd0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgdHJhbnNmZXIgJHt0b1N0cmluZyhcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICl9IExQVCBiZWNhdXNlIGlzIGl0IGdyZWF0ZXIgdGhhbiB5b3VyIGN1cnJlbnQgYmFsYW5jZSAoJHtiYWxhbmNlfSBMUFQpLmAsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldFR4UmVjZWlwdChcbiAgICAgICAgYXdhaXQgTGl2ZXBlZXJUb2tlbi50cmFuc2ZlcihcbiAgICAgICAgICBhd2FpdCByZXNvbHZlQWRkcmVzcyhycGMuZ2V0RU5TQWRkcmVzcywgdG8pLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHR4LFxuICAgICAgICApLFxuICAgICAgICBjb25maWcuZXRoLFxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIExQVCB0aGUgZmF1Y2V0IGRpc3RyaWJ1dGVzIHdoZW4gdGFwcGVkXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0RmF1Y2V0QW1vdW50KClcbiAgICAgKiAvLyA9PiBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGYXVjZXRBbW91bnQoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHJldHVybiBoZWFkVG9TdHJpbmcoYXdhaXQgTGl2ZXBlZXJUb2tlbkZhdWNldC5yZXF1ZXN0QW1vdW50KCkpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhvdyBvZnRlbiBhbiBhZGRyZXNzIGNhbiB0YXAgdGhlIGZhdWNldCAoaW4gaG91cnMpXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0RmF1Y2V0V2FpdCgpXG4gICAgICogLy8gPT4gc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmF1Y2V0V2FpdCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIGhlYWRUb1N0cmluZyhhd2FpdCBMaXZlcGVlclRva2VuRmF1Y2V0LnJlcXVlc3RXYWl0KCkpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5leHQgdGltZXN0YW1wIGF0IHdoaWNoIHRoZSBnaXZlbiBhZGRyZXNzIHdpbGwgYmUgYWxsb3dlZCB0byB0YXAgdGhlIGZhdWNldFxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFkZHIgLSB1c2VyJ3MgRVRIIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldEZhdWNldE5leHQoKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldEZhdWNldE5leHQoYWRkcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHJldHVybiBoZWFkVG9TdHJpbmcoXG4gICAgICAgIGF3YWl0IExpdmVwZWVyVG9rZW5GYXVjZXQubmV4dFZhbGlkUmVxdWVzdChcbiAgICAgICAgICBhd2FpdCByZXNvbHZlQWRkcmVzcyhycGMuZ2V0RU5TQWRkcmVzcywgYWRkciksXG4gICAgICAgICksXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluZm8gYWJvdXQgdGhlIHN0YXRlIG9mIHRoZSBMUFQgZmF1Y2V0XG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYWRkciAtIHVzZXIncyBFVEggYWRkcmVzc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8RmF1Y2V0SW5mbz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldEZhdWNldEluZm8oJzB4ZjAwLi4uJylcbiAgICAgKiAvLyA9PiBGYXVjZXRJbmZvIHtcbiAgICAgKiAvLyAgIGFtb3VudDogc3RyaW5nLFxuICAgICAqIC8vICAgd2FpdDogc3RyaW5nLFxuICAgICAqIC8vICAgbmV4dDogc3RyaW5nLFxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGYXVjZXRJbmZvKGFkZHI6IHN0cmluZyk6IFByb21pc2U8RmF1Y2V0SW5mbz4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW1vdW50OiBhd2FpdCBycGMuZ2V0RmF1Y2V0QW1vdW50KCksXG4gICAgICAgIHdhaXQ6IGF3YWl0IHJwYy5nZXRGYXVjZXRXYWl0KCksXG4gICAgICAgIG5leHQ6IGF3YWl0IHJwYy5nZXRGYXVjZXROZXh0KFxuICAgICAgICAgIGF3YWl0IHJlc29sdmVBZGRyZXNzKHJwYy5nZXRFTlNBZGRyZXNzLCBhZGRyKSxcbiAgICAgICAgKSxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGVyIHJvdW5kIGluZmxhdGlvbiByYXRlXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0SW5mbGF0aW9uKClcbiAgICAgKiAvLyA9PiBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRJbmZsYXRpb24oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHJldHVybiBoZWFkVG9TdHJpbmcoYXdhaXQgTWludGVyLmluZmxhdGlvbigpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjaGFuZ2UgaW4gaW5mbGF0aW9uIHJhdGUgcGVyIHJvdW5kIHVudGlsIHRoZSB0YXJnZXQgYm9uZGluZyByYXRlIGlzIGFjaGlldmVkXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0SW5mbGF0aW9uQ2hhbmdlKClcbiAgICAgKiAvLyA9PiBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRJbmZsYXRpb25DaGFuZ2UoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHJldHVybiBoZWFkVG9TdHJpbmcoYXdhaXQgTWludGVyLmluZmxhdGlvbkNoYW5nZSgpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVsZWdhdG9yIHN0YXR1cyBvZiB0aGUgZ2l2ZW4gYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFkZHIgLSB1c2VyJ3MgRVRIIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldERlbGVnYXRvclN0YXR1cygnMHhmMDAuLi4nKVxuICAgICAqIC8vID0+ICdQZW5kaW5nJyB8ICdCb25kZWQnIHwgJ1VuYm9uZGVkJ1xuICAgICAqL1xuICAgIGFzeW5jIGdldERlbGVnYXRvclN0YXR1cyhhZGRyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgY29uc3Qgc3RhdHVzID0gaGVhZFRvU3RyaW5nKFxuICAgICAgICBhd2FpdCBCb25kaW5nTWFuYWdlci5kZWxlZ2F0b3JTdGF0dXMoXG4gICAgICAgICAgYXdhaXQgcmVzb2x2ZUFkZHJlc3MocnBjLmdldEVOU0FkZHJlc3MsIGFkZHIpLFxuICAgICAgICApLFxuICAgICAgKVxuICAgICAgcmV0dXJuIERFTEVHQVRPUl9TVEFUVVNbc3RhdHVzXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmFsIGluZm8gYWJvdXQgYSBkZWxlZ2F0b3JcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBhZGRyIC0gdXNlcidzIEVUSCBhZGRyZXNzXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxEZWxlZ2F0b3I+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXREZWxlZ2F0b3IoJzB4ZjAwLi4uJylcbiAgICAgKiAvLyA9PiBEZWxlZ2F0b3Ige1xuICAgICAqIC8vICAgYWxsb3dhbmNlOiBzdHJpbmcsXG4gICAgICogLy8gICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICBib25kZWRBbW91bnQ6IHN0cmluZyxcbiAgICAgKiAvLyAgIGRlbGVnYXRlQWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgZGVsZWdhdGVBbW91bnQ6IHN0cmluZyxcbiAgICAgKiAvLyAgIGZlZXM6IHN0cmluZyxcbiAgICAgKiAvLyAgIGxhc3RDbGFpbVJvdW5kOiBzdHJpbmcsXG4gICAgICogLy8gICBwZW5kaW5nRmVlczogc3RyaW5nLFxuICAgICAqIC8vICAgcGVuZGluZ1N0YWtlOiBzdHJpbmcsXG4gICAgICogLy8gICBzdGFydFJvdW5kOiBzdHJpbmcsXG4gICAgICogLy8gICBzdGF0dXM6ICdQZW5kaW5nJyB8ICdCb25kZWQnIHwgJ1VuYm9uZGluZycgfCAnVW5ib25kZWQnLFxuICAgICAqIC8vICAgd2l0aGRyYXdSb3VuZDogc3RyaW5nLFxuICAgICAqIC8vICAgbmV4dFVuYm9uZGluZ0xvY2tJZDogc3RyaW5nLFxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZWxlZ2F0b3IoYWRkcjogc3RyaW5nKTogUHJvbWlzZTxEZWxlZ2F0b3I+IHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhycGMuZ2V0RU5TQWRkcmVzcywgYWRkcilcbiAgICAgIGNvbnN0IGFsbG93YW5jZSA9IGhlYWRUb1N0cmluZyhcbiAgICAgICAgYXdhaXQgTGl2ZXBlZXJUb2tlbi5hbGxvd2FuY2UoYWRkcmVzcywgQm9uZGluZ01hbmFnZXIuYWRkcmVzcyksXG4gICAgICApXG4gICAgICBjb25zdCBwb2xsQ3JlYXRvckFsbG93YW5jZSA9IGhlYWRUb1N0cmluZyhcbiAgICAgICAgYXdhaXQgTGl2ZXBlZXJUb2tlbi5hbGxvd2FuY2UoYWRkcmVzcywgUG9sbENyZWF0b3IuYWRkcmVzcyksXG4gICAgICApXG4gICAgICBjb25zdCBjdXJyZW50Um91bmQgPSBhd2FpdCBycGMuZ2V0Q3VycmVudFJvdW5kKClcbiAgICAgIGNvbnN0IHBlbmRpbmdTdGFrZSA9IGhlYWRUb1N0cmluZyhcbiAgICAgICAgYXdhaXQgQm9uZGluZ01hbmFnZXIucGVuZGluZ1N0YWtlKGFkZHJlc3MsIGN1cnJlbnRSb3VuZCksXG4gICAgICApXG4gICAgICBjb25zdCBwZW5kaW5nRmVlcyA9IGhlYWRUb1N0cmluZyhcbiAgICAgICAgYXdhaXQgQm9uZGluZ01hbmFnZXIucGVuZGluZ0ZlZXMoYWRkcmVzcywgY3VycmVudFJvdW5kKSxcbiAgICAgIClcbiAgICAgIGNvbnN0IGQgPSBhd2FpdCBCb25kaW5nTWFuYWdlci5nZXREZWxlZ2F0b3IoYWRkcmVzcylcbiAgICAgIGNvbnN0IGJvbmRlZEFtb3VudCA9IHRvU3RyaW5nKGQuYm9uZGVkQW1vdW50KVxuICAgICAgY29uc3QgZmVlcyA9IHRvU3RyaW5nKGQuZmVlcylcbiAgICAgIGNvbnN0IGRlbGVnYXRlQWRkcmVzcyA9XG4gICAgICAgIGQuZGVsZWdhdGVBZGRyZXNzID09PSBFTVBUWV9BRERSRVNTID8gJycgOiBkLmRlbGVnYXRlQWRkcmVzc1xuICAgICAgY29uc3QgZGVsZWdhdGVkQW1vdW50ID0gdG9TdHJpbmcoZC5kZWxlZ2F0ZWRBbW91bnQpXG4gICAgICBjb25zdCBsYXN0Q2xhaW1Sb3VuZCA9IHRvU3RyaW5nKGQubGFzdENsYWltUm91bmQpXG4gICAgICBjb25zdCBzdGFydFJvdW5kID0gdG9TdHJpbmcoZC5zdGFydFJvdW5kKVxuICAgICAgY29uc3QgbmV4dFVuYm9uZGluZ0xvY2tJZCA9IHRvU3RyaW5nKGQubmV4dFVuYm9uZGluZ0xvY2tJZClcblxuICAgICAgbGV0IHVuYm9uZGluZ0xvY2tJZCA9IHRvQk4obmV4dFVuYm9uZGluZ0xvY2tJZClcbiAgICAgIGlmICh1bmJvbmRpbmdMb2NrSWQuY21wKG5ldyBCTigwKSkgPiAwKSB7XG4gICAgICAgIHVuYm9uZGluZ0xvY2tJZCA9IHVuYm9uZGluZ0xvY2tJZC5zdWIobmV3IEJOKDEpKVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBhbW91bnQ6IHdpdGhkcmF3QW1vdW50LFxuICAgICAgICB3aXRoZHJhd1JvdW5kLFxuICAgICAgfSA9IGF3YWl0IHJwYy5nZXREZWxlZ2F0b3JVbmJvbmRpbmdMb2NrKFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICB0b1N0cmluZyh1bmJvbmRpbmdMb2NrSWQpLFxuICAgICAgKVxuICAgICAgY29uc3Qgc3RhdHVzID1cbiAgICAgICAgd2l0aGRyYXdSb3VuZCAhPT0gJzAnICYmIHRvQk4oY3VycmVudFJvdW5kKS5jbXAodG9CTih3aXRoZHJhd1JvdW5kKSkgPCAwXG4gICAgICAgICAgPyBERUxFR0FUT1JfU1RBVFVTLlVuYm9uZGluZ1xuICAgICAgICAgIDogYXdhaXQgcnBjLmdldERlbGVnYXRvclN0YXR1cyhhZGRyZXNzKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBhbGxvd2FuY2UsXG4gICAgICAgIHBvbGxDcmVhdG9yQWxsb3dhbmNlLFxuICAgICAgICBib25kZWRBbW91bnQsXG4gICAgICAgIGRlbGVnYXRlQWRkcmVzcyxcbiAgICAgICAgZGVsZWdhdGVkQW1vdW50LFxuICAgICAgICBmZWVzLFxuICAgICAgICBsYXN0Q2xhaW1Sb3VuZCxcbiAgICAgICAgcGVuZGluZ0ZlZXMsXG4gICAgICAgIHBlbmRpbmdTdGFrZSxcbiAgICAgICAgc3RhcnRSb3VuZCxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICB3aXRoZHJhd1JvdW5kLFxuICAgICAgICB3aXRoZHJhd0Ftb3VudCxcbiAgICAgICAgbmV4dFVuYm9uZGluZ0xvY2tJZCxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgdW5ib25kaW5nIGxvY2tzIGZvciBhIGRlbGVnYXRvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyIC0gZGVsZWdhdG9yJ3MgRVRIIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PFVuYm9uZGluZ0xvY2s+Pn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0RGVsZWdhdG9yVW5ib25kaW5nTG9ja3MoJzB4ZjAwLi4uJylcbiAgICAgKiAvLyA9PiBVbmJvbmRpbmdMb2NrIFt7XG4gICAgICogLy8gICBpZDogc3RyaW5nLFxuICAgICAqIC8vICAgZGVsZWdhdG9yOiBzdHJpbmcsXG4gICAgICogLy8gICBhbW91bnQ6IHN0cmluZyxcbiAgICAgKiAvLyAgIHdpdGhkcmF3Um91bmQ6IHN0cmluZ1xuICAgICAqIC8vIH1dXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVsZWdhdG9yVW5ib25kaW5nTG9ja3MoXG4gICAgICBhZGRyOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxBcnJheTxVbmJvbmRpbmdMb2NrPj4ge1xuICAgICAgbGV0IHsgbmV4dFVuYm9uZGluZ0xvY2tJZCB9ID0gYXdhaXQgcnBjLmdldERlbGVnYXRvcihhZGRyKVxuXG4gICAgICBsZXQgdW5ib25kaW5nTG9ja0lkID0gdG9OdW1iZXIobmV4dFVuYm9uZGluZ0xvY2tJZClcbiAgICAgIGlmICh1bmJvbmRpbmdMb2NrSWQgPiAwKSB7XG4gICAgICAgIHVuYm9uZGluZ0xvY2tJZCAtPSAxXG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSBbXVxuXG4gICAgICB3aGlsZSAodW5ib25kaW5nTG9ja0lkID49IDApIHtcbiAgICAgICAgY29uc3QgdW5ib25kID0gYXdhaXQgcnBjLmdldERlbGVnYXRvclVuYm9uZGluZ0xvY2soXG4gICAgICAgICAgYWRkcixcbiAgICAgICAgICB0b1N0cmluZyh1bmJvbmRpbmdMb2NrSWQpLFxuICAgICAgICApXG4gICAgICAgIHJlc3VsdC5wdXNoKHVuYm9uZClcbiAgICAgICAgdW5ib25kaW5nTG9ja0lkIC09IDFcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gdW5ib25kaW5nIGxvY2sgZm9yIGEgZGVsZWdhdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHIgLSBkZWxlZ2F0b3IncyBFVEggYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1bmJvbmRpbmdMb2NrSWQgLSB1bmJvbmRpbmcgbG9jayBJRFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXREZWxlZ2F0b3JVbmJvbmRpbmdMb2NrKCcweGYwMC4uLicsIDEpXG4gICAgICogLy8gPT4gVW5ib25kaW5nTG9jayB7XG4gICAgICogLy8gICBpZDogc3RyaW5nLFxuICAgICAqIC8vICAgZGVsZWdhdG9yOiBzdHJpbmcsXG4gICAgICogLy8gICBhbW91bnQ6IHN0cmluZyxcbiAgICAgKiAvLyAgIHdpdGhkcmF3Um91bmQ6IHN0cmluZ1xuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZWxlZ2F0b3JVbmJvbmRpbmdMb2NrKFxuICAgICAgYWRkcjogc3RyaW5nLFxuICAgICAgdW5ib25kaW5nTG9ja0lkOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxVbmJvbmRpbmdMb2NrPiB7XG4gICAgICBjb25zdCBsb2NrID0gYXdhaXQgQm9uZGluZ01hbmFnZXIuZ2V0RGVsZWdhdG9yVW5ib25kaW5nTG9jayhcbiAgICAgICAgYWRkcixcbiAgICAgICAgdW5ib25kaW5nTG9ja0lkLFxuICAgICAgKVxuICAgICAgY29uc3QgYW1vdW50ID0gdG9TdHJpbmcobG9jay5hbW91bnQpXG4gICAgICBjb25zdCB3aXRoZHJhd1JvdW5kID0gdG9TdHJpbmcobG9jay53aXRoZHJhd1JvdW5kKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHVuYm9uZGluZ0xvY2tJZCxcbiAgICAgICAgZGVsZWdhdG9yOiBhZGRyLFxuICAgICAgICBhbW91bnQsXG4gICAgICAgIHdpdGhkcmF3Um91bmQsXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYm9uZHMgTFBUIGZyb20gYW4gYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdW5ib25kaW5nTG9ja0lkXG4gICAgICogQHBhcmFtIHtUeENvbmZpZ30gW3R4ID0gY29uZmlnLmRlZmF1bHRUeF0gLSBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgYGZyb21gIGFuZCBgZ2FzYCB2YWx1ZXMgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxUeFJlY2VpcHQ+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5yZWJvbmQoMClcbiAgICAgKiAvLyA9PiBUeFJlY2VpcHQge1xuICAgICAqIC8vICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICB0cmFuc2FjdGlvbkluZGV4XCI6IEJOLFxuICAgICAqIC8vICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICBjdW11bGF0aXZlR2FzVXNlZDogQk4sXG4gICAgICogLy8gICBnYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgbG9nczogQXJyYXk8TG9nIHtcbiAgICAgKiAvLyAgICAgbG9nSW5kZXg6IEJOLFxuICAgICAqIC8vICAgICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25JbmRleDogc3RyaW5nLFxuICAgICAqIC8vICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICAgIGRhdGE6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdG9waWNzOiBBcnJheTxzdHJpbmc+XG4gICAgICogLy8gICB9PlxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyByZWJvbmQoXG4gICAgICB1bmJvbmRpbmdMb2NrSWQ6IG51bWJlcixcbiAgICAgIHR4ID0gY29uZmlnLmRlZmF1bHRUeCxcbiAgICApOiBQcm9taXNlPFR4UmVjZWlwdD4ge1xuICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgQm9uZGluZ01hbmFnZXIucmVib25kKHVuYm9uZGluZ0xvY2tJZCwge1xuICAgICAgICAuLi5jb25maWcuZGVmYXVsdFR4LFxuICAgICAgICAuLi50eCxcbiAgICAgIH0pXG4gICAgICBpZiAodHgucmV0dXJuVHhIYXNoKSB7XG4gICAgICAgIHJldHVybiB0eEhhc2hcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldFR4UmVjZWlwdCh0eEhhc2gsIGNvbmZpZy5ldGgpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYm9uZHMgTFBUIGZyb20gYW4gYWRkcmVzcyB3aXRoIGhpbnRcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVuYm9uZGluZ0xvY2tJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQb3NQcmV2XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1Bvc05leHRcbiAgICAgKiBAcGFyYW0ge1R4Q29uZmlnfSBbdHggPSBjb25maWcuZGVmYXVsdFR4XSAtIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBgZnJvbWAgYW5kIGBnYXNgIHZhbHVlcyBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFR4UmVjZWlwdD59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLnJlYm9uZFdpdGhIaW50KDAsIFwiMHhcIiwgXCIweFwiKVxuICAgICAqIC8vID0+IFR4UmVjZWlwdCB7XG4gICAgICogLy8gICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIHRyYW5zYWN0aW9uSW5kZXhcIjogQk4sXG4gICAgICogLy8gICBibG9ja0hhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgIGN1bXVsYXRpdmVHYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGdhc1VzZWQ6IEJOLFxuICAgICAqIC8vICAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICBsb2dzOiBBcnJheTxMb2cge1xuICAgICAqIC8vICAgICBsb2dJbmRleDogQk4sXG4gICAgICogLy8gICAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRyYW5zYWN0aW9uSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkluZGV4OiBzdHJpbmcsXG4gICAgICogLy8gICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgZGF0YTogc3RyaW5nLFxuICAgICAqIC8vICAgICB0b3BpY3M6IEFycmF5PHN0cmluZz5cbiAgICAgKiAvLyAgIH0+XG4gICAgICogLy8gfVxuICAgICAqL1xuICAgIGFzeW5jIHJlYm9uZFdpdGhIaW50KFxuICAgICAgdW5ib25kaW5nTG9ja0lkOiBudW1iZXIsXG4gICAgICBuZXdQb3NQcmV2OiBzdHJpbmcsXG4gICAgICBuZXdQb3NOZXh0OiBzdHJpbmcsXG4gICAgICB0eDogVHhPYmplY3QsXG4gICAgKTogUHJvbWlzZTxUeFJlY2VpcHQ+IHtcbiAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IEJvbmRpbmdNYW5hZ2VyLnJlYm9uZFdpdGhIaW50KFxuICAgICAgICB1bmJvbmRpbmdMb2NrSWQsXG4gICAgICAgIG5ld1Bvc1ByZXYsXG4gICAgICAgIG5ld1Bvc05leHQsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5jb25maWcuZGVmYXVsdFR4LFxuICAgICAgICAgIC4uLnR4LFxuICAgICAgICB9LFxuICAgICAgKVxuICAgICAgaWYgKHR4LnJldHVyblR4SGFzaCkge1xuICAgICAgICByZXR1cm4gdHhIYXNoXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCB1dGlscy5nZXRUeFJlY2VpcHQodHhIYXNoLCBjb25maWcuZXRoKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWJvbmRzIExQVCBmcm9tIGFuIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVuYm9uZGluZ0xvY2tJZFxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IFt0eCA9IGNvbmZpZy5kZWZhdWx0VHhdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGBmcm9tYCBhbmQgYGdhc2AgdmFsdWVzIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8VHhSZWNlaXB0Pn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMucmVib25kRnJvbVVuYm9uZGVkKFwiMHhcIiwgMSlcbiAgICAgKiAvLyA9PiBUeFJlY2VpcHQge1xuICAgICAqIC8vICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICB0cmFuc2FjdGlvbkluZGV4XCI6IEJOLFxuICAgICAqIC8vICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICBjdW11bGF0aXZlR2FzVXNlZDogQk4sXG4gICAgICogLy8gICBnYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgbG9nczogQXJyYXk8TG9nIHtcbiAgICAgKiAvLyAgICAgbG9nSW5kZXg6IEJOLFxuICAgICAqIC8vICAgICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25JbmRleDogc3RyaW5nLFxuICAgICAqIC8vICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICAgIGRhdGE6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdG9waWNzOiBBcnJheTxzdHJpbmc+XG4gICAgICogLy8gICB9PlxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyByZWJvbmRGcm9tVW5ib25kZWQoXG4gICAgICB0bzogc3RyaW5nLFxuICAgICAgdW5ib25kaW5nTG9ja0lkOiBudW1iZXIsXG4gICAgICB0eCA9IGNvbmZpZy5kZWZhdWx0VHgsXG4gICAgKTogUHJvbWlzZTxUeFJlY2VpcHQ+IHtcbiAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IEJvbmRpbmdNYW5hZ2VyLnJlYm9uZEZyb21VbmJvbmRlZChcbiAgICAgICAgdG8sXG4gICAgICAgIHVuYm9uZGluZ0xvY2tJZCxcbiAgICAgICAge1xuICAgICAgICAgIC4uLmNvbmZpZy5kZWZhdWx0VHgsXG4gICAgICAgICAgLi4udHgsXG4gICAgICAgIH0sXG4gICAgICApXG5cbiAgICAgIGlmICh0eC5yZXR1cm5UeEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHR4SGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdXRpbHMuZ2V0VHhSZWNlaXB0KHR4SGFzaCwgY29uZmlnLmV0aClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVib25kcyBMUFQgZnJvbSBhbiBhZGRyZXNzIHdpdGggaGludFxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdW5ib25kaW5nTG9ja0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1Bvc1ByZXZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UG9zTmV4dFxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IFt0eCA9IGNvbmZpZy5kZWZhdWx0VHhdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGBmcm9tYCBhbmQgYGdhc2AgdmFsdWVzIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8VHhSZWNlaXB0Pn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMucmVib25kRnJvbVVuYm9uZGVkV2l0aEhpbnQoXCIweFwiLCAxLCBcIjB4XCIsIFwiMHhcIilcbiAgICAgKiAvLyA9PiBUeFJlY2VpcHQge1xuICAgICAqIC8vICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICB0cmFuc2FjdGlvbkluZGV4XCI6IEJOLFxuICAgICAqIC8vICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICBjdW11bGF0aXZlR2FzVXNlZDogQk4sXG4gICAgICogLy8gICBnYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgbG9nczogQXJyYXk8TG9nIHtcbiAgICAgKiAvLyAgICAgbG9nSW5kZXg6IEJOLFxuICAgICAqIC8vICAgICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25JbmRleDogc3RyaW5nLFxuICAgICAqIC8vICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICAgIGRhdGE6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdG9waWNzOiBBcnJheTxzdHJpbmc+XG4gICAgICogLy8gICB9PlxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyByZWJvbmRGcm9tVW5ib25kZWRXaXRoSGludChcbiAgICAgIHRvOiBzdHJpbmcsXG4gICAgICB1bmJvbmRpbmdMb2NrSWQ6IG51bWJlcixcbiAgICAgIG5ld1Bvc1ByZXY6IHN0cmluZyxcbiAgICAgIG5ld1Bvc05leHQ6IHN0cmluZyxcbiAgICAgIHR4ID0gY29uZmlnLmRlZmF1bHRUeCxcbiAgICApOiBQcm9taXNlPFR4UmVjZWlwdD4ge1xuICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgQm9uZGluZ01hbmFnZXIucmVib25kRnJvbVVuYm9uZGVkV2l0aEhpbnQoXG4gICAgICAgIHRvLFxuICAgICAgICB1bmJvbmRpbmdMb2NrSWQsXG4gICAgICAgIG5ld1Bvc1ByZXYsXG4gICAgICAgIG5ld1Bvc05leHQsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5jb25maWcuZGVmYXVsdFR4LFxuICAgICAgICAgIC4uLnR4LFxuICAgICAgICB9LFxuICAgICAgKVxuXG4gICAgICBpZiAodHgucmV0dXJuVHhIYXNoKSB7XG4gICAgICAgIHJldHVybiB0eEhhc2hcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldFR4UmVjZWlwdCh0eEhhc2gsIGNvbmZpZy5ldGgpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGRlbGVnYXRvcidzIHBlbmRpbmcgc3Rha2VcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHIgLSB1c2VyJ3MgRVRIIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kUm91bmQgVGhlIGxhc3Qgcm91bmQgdG8gY29tcHV0ZSBwZW5kaW5nIHN0YWtlIGZyb21cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldFBlbmRpbmdTdGFrZSgnMHhmMDAuLi4nKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFBlbmRpbmdTdGFrZShhZGRyOiBzdHJpbmcsIGVuZFJvdW5kOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHJwYy5nZXRFTlNBZGRyZXNzLCBhZGRyKVxuICAgICAgICBpZiAoIWVuZFJvdW5kKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFJvdW5kID0gYXdhaXQgcnBjLmdldEN1cnJlbnRSb3VuZCgpXG4gICAgICAgICAgcmV0dXJuIGhlYWRUb1N0cmluZyhcbiAgICAgICAgICAgIGF3YWl0IEJvbmRpbmdNYW5hZ2VyLnBlbmRpbmdTdGFrZShhZGRyZXNzLCBjdXJyZW50Um91bmQpLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZFRvU3RyaW5nKFxuICAgICAgICAgIGF3YWl0IEJvbmRpbmdNYW5hZ2VyLnBlbmRpbmdTdGFrZShhZGRyZXNzLCBlbmRSb3VuZCksXG4gICAgICAgIClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnIubWVzc2FnZSA9ICdFcnJvcjogZ2V0UGVuZGluZ1N0YWtlXFxuJyArIGVyci5tZXNzYWdlXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBkZWxlZ2F0b3IncyBwZW5kaW5nIGZlZXNcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBhZGRyIC0gdXNlcidzIEVUSCBhZGRyZXNzXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBlbmRSb3VuZCBUaGUgbGFzdCByb3VuZCB0byBjb21wdXRlIHBlbmRpbmcgZmVlcyBmcm9tXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRQZW5kaW5nRmVlcygnMHhmMDAuLi4nKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFBlbmRpbmdGZWVzKGFkZHI6IHN0cmluZywgZW5kUm91bmQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MocnBjLmdldEVOU0FkZHJlc3MsIGFkZHIpXG4gICAgICAgIGlmICghZW5kUm91bmQpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Um91bmQgPSBhd2FpdCBycGMuZ2V0Q3VycmVudFJvdW5kKClcbiAgICAgICAgICByZXR1cm4gaGVhZFRvU3RyaW5nKFxuICAgICAgICAgICAgYXdhaXQgQm9uZGluZ01hbmFnZXIucGVuZGluZ0ZlZXMoYWRkcmVzcywgY3VycmVudFJvdW5kKSxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRUb1N0cmluZyhhd2FpdCBCb25kaW5nTWFuYWdlci5wZW5kaW5nRmVlcyhhZGRyZXNzLCBlbmRSb3VuZCkpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSAnRXJyb3I6IGdldFBlbmRpbmdGZWVzXFxuJyArIGVyci5tZXNzYWdlXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdHJhbnNjb2RlciBpcyBhY3RpdmVcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBhZGRyIC0gdXNlcidzIEVUSCBhZGRyZXNzXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0VHJhbnNjb2RlcklzQWN0aXZlKCcweGYwMC4uLicpXG4gICAgICogLy8gPT4gYm9vbGVhblxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zY29kZXJJc0FjdGl2ZShhZGRyOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgIHJldHVybiBoZWFkVG9Cb29sKFxuICAgICAgICBhd2FpdCBCb25kaW5nTWFuYWdlci5pc0FjdGl2ZVRyYW5zY29kZXIoXG4gICAgICAgICAgYXdhaXQgcmVzb2x2ZUFkZHJlc3MocnBjLmdldEVOU0FkZHJlc3MsIGFkZHIpLFxuICAgICAgICApLFxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgYSB0cmFuc2NvZGVyXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYWRkciAtIHVzZXIncyBFVEggYWRkcmVzc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0VHJhbnNjb2RlclN0YXR1cygnMHhmMDAuLi4nKVxuICAgICAqIC8vID0+ICdOb3RSZWdpc3RlcmVkJyB8ICdSZWdpc3RlcmVkJ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zY29kZXJTdGF0dXMoYWRkcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGhlYWRUb1N0cmluZyhcbiAgICAgICAgYXdhaXQgQm9uZGluZ01hbmFnZXIudHJhbnNjb2RlclN0YXR1cyhcbiAgICAgICAgICBhd2FpdCByZXNvbHZlQWRkcmVzcyhycGMuZ2V0RU5TQWRkcmVzcywgYWRkciksXG4gICAgICAgICksXG4gICAgICApXG4gICAgICByZXR1cm4gVFJBTlNDT0RFUl9TVEFUVVNbc3RhdHVzXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdHJhbnNjb2RlcidzIHRvdGFsIHN0YWtlXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYWRkciAtIHVzZXIncyBFVEggYWRkcmVzc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0VHJhbnNjb2RlclRvdGFsU3Rha2UoJzB4ZjAwLi4uJylcbiAgICAgKiAvLyA9PiBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2NvZGVyVG90YWxTdGFrZShhZGRyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIGhlYWRUb1N0cmluZyhcbiAgICAgICAgYXdhaXQgQm9uZGluZ01hbmFnZXIudHJhbnNjb2RlclRvdGFsU3Rha2UoXG4gICAgICAgICAgYXdhaXQgcmVzb2x2ZUFkZHJlc3MocnBjLmdldEVOU0FkZHJlc3MsIGFkZHIpLFxuICAgICAgICApLFxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdHJhbnNjb2RlcidzIHBvb2wgbWF4IHNpemVcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRUcmFuc2NvZGVyUG9vbE1heFNpemUoKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zY29kZXJQb29sTWF4U2l6ZSgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIGhlYWRUb1N0cmluZyhhd2FpdCBCb25kaW5nTWFuYWdlci5nZXRUcmFuc2NvZGVyUG9vbE1heFNpemUoKSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvIGFib3V0IGEgdHJhbnNjb2RlclxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFkZHIgLSB1c2VyJ3MgRVRIIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFRyYW5zY29kZXI+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRUcmFuc2NvZGVyKCcweGYwMC4uLicpXG4gICAgICogLy8gPT4gVHJhbnNjb2RlciB7XG4gICAgICogLy8gICBhY3RpdmU6IGJvb2xlYW4sXG4gICAgICogLy8gICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICByZXdhcmRDdXQ6IHN0cmluZyxcbiAgICAgKiAvLyAgIGZlZVNoYXJlOiBzdHJpbmcsXG4gICAgICogLy8gICBsYXN0UmV3YXJkUm91bmQ6IHN0cmluZyxcbiAgICAgKiAvLyAgIHBlbmRpbmdSZXdhcmRDdXQgc3RyaW5nLFxuICAgICAqIC8vICAgcGVuZGluZ0ZlZVNoYXJlOiBzdHJpbmcsXG4gICAgICogLy8gICBwZW5kaW5nUHJpY2VQZXJTZWdtZW50OiBzdHJpbmcsXG4gICAgICogLy8gICBwcmljZVBlclNlZ21lbnQ6IHN0cmluZyxcbiAgICAgKiAvLyAgIHN0YXR1czogJ05vdFJlZ2lzdGVyZWQnIHwgJ1JlZ2lzdGVyZWQnLFxuICAgICAqIC8vICAgdG90YWxTdGFrZTogc3RyaW5nLFxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2NvZGVyKGFkZHI6IHN0cmluZyk6IFByb21pc2U8VHJhbnNjb2Rlcj4ge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHJwYy5nZXRFTlNBZGRyZXNzLCBhZGRyKVxuICAgICAgY29uc3QgdG90YWxTdGFrZSA9IGF3YWl0IHJwYy5nZXRUcmFuc2NvZGVyVG90YWxTdGFrZShhZGRyZXNzKVxuICAgICAgY29uc3QgdCA9IGF3YWl0IEJvbmRpbmdNYW5hZ2VyLmdldFRyYW5zY29kZXIoYWRkcmVzcylcbiAgICAgIGNvbnN0IGZlZVNoYXJlID0gdG9TdHJpbmcodC5mZWVTaGFyZSlcbiAgICAgIGNvbnN0IGxhc3RSZXdhcmRSb3VuZCA9IHRvU3RyaW5nKHQubGFzdFJld2FyZFJvdW5kKVxuICAgICAgY29uc3QgcmV3YXJkQ3V0ID0gdG9TdHJpbmcodC5yZXdhcmRDdXQpXG4gICAgICBjb25zdCBhY3RpdmF0aW9uUm91bmQgPSB0b1N0cmluZyh0LmFjdGl2YXRpb25Sb3VuZClcbiAgICAgIGNvbnN0IGRlYWN0aXZhdGlvblJvdW5kID0gdG9TdHJpbmcodC5kZWFjdGl2YXRpb25Sb3VuZClcbiAgICAgIGNvbnN0IGxhc3RBY3RpdmVTdGFrZVVwZGF0ZVJvdW5kID0gdG9TdHJpbmcodC5sYXN0QWN0aXZlU3Rha2VVcGRhdGVSb3VuZClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGZlZVNoYXJlLFxuICAgICAgICBsYXN0UmV3YXJkUm91bmQsXG4gICAgICAgIGFjdGl2YXRpb25Sb3VuZCxcbiAgICAgICAgZGVhY3RpdmF0aW9uUm91bmQsXG4gICAgICAgIHJld2FyZEN1dCxcbiAgICAgICAgdG90YWxTdGFrZSxcbiAgICAgICAgbGFzdEFjdGl2ZVN0YWtlVXBkYXRlUm91bmQsXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdHJhbnNjb2RlcnNcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHJldHVybiB7QXJyYXk8VHJhbnNjb2Rlcj59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldFRyYW5zY29kZXJzKClcbiAgICAgKiAvLyA9PiBBcnJheTxUcmFuc2NvZGVyPlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zY29kZXJzKCk6IFByb21pc2U8QXJyYXk8VHJhbnNjb2Rlcj4+IHtcbiAgICAgIGNvbnN0IHRyYW5zY29kZXJzID0gW11cbiAgICAgIGxldCBhZGRyID0gaGVhZFRvU3RyaW5nKGF3YWl0IEJvbmRpbmdNYW5hZ2VyLmdldEZpcnN0VHJhbnNjb2RlckluUG9vbCgpKVxuICAgICAgd2hpbGUgKGFkZHIgIT09IEVNUFRZX0FERFJFU1MpIHtcbiAgICAgICAgY29uc3QgdHJhbnNjb2RlciA9IGF3YWl0IHJwYy5nZXRUcmFuc2NvZGVyKGFkZHIpXG4gICAgICAgIHRyYW5zY29kZXJzLnB1c2godHJhbnNjb2RlcilcbiAgICAgICAgYWRkciA9IGhlYWRUb1N0cmluZyhhd2FpdCBCb25kaW5nTWFuYWdlci5nZXROZXh0VHJhbnNjb2RlckluUG9vbChhZGRyKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2NvZGVyc1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBwcm90b2NvbCBpcyBwYXVzZWRcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0UHJvdG9jb2xQYXVzZWQoKVxuICAgICAqIC8vID0+IGJvb2xlYW5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm90b2NvbFBhdXNlZCgpOiBQcm9taXNlPFByb3RvY29sPiB7XG4gICAgICByZXR1cm4gaGVhZFRvQm9vbChhd2FpdCBDb250cm9sbGVyLnBhdXNlZCgpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm90b2NvbFxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFByb3RvY29sPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0UHJvdG9jb2woKVxuICAgICAqIC8vID0+IFByb3RvY29sIHtcbiAgICAgICAgcGF1c2VkXG4gICAgICAgIHRvdGFsVG9rZW5TdXBwbHlcbiAgICAgICAgdG90YWxCb25kZWRUb2tlblxuICAgICAgICB0YXJnZXRCb25kaW5nUmF0ZVxuICAgICAgICB0cmFuc2NvZGVyUG9vbE1heFNpemVcbiAgICAgICAgbWF4RWFybmluZ3NDbGFpbXNSb3VuZHNcbiAgICAgfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3RvY29sKCk6IFByb21pc2U8UHJvdG9jb2w+IHtcbiAgICAgIGNvbnN0IHBhdXNlZCA9IGF3YWl0IHJwYy5nZXRQcm90b2NvbFBhdXNlZCgpXG4gICAgICBjb25zdCB0b3RhbFRva2VuU3VwcGx5ID0gYXdhaXQgcnBjLmdldFRva2VuVG90YWxTdXBwbHkoKVxuICAgICAgY29uc3QgdG90YWxCb25kZWRUb2tlbiA9IGF3YWl0IHJwYy5nZXRUb3RhbEJvbmRlZCgpXG4gICAgICBjb25zdCB0YXJnZXRCb25kaW5nUmF0ZSA9IGF3YWl0IHJwYy5nZXRUYXJnZXRCb25kaW5nUmF0ZSgpXG4gICAgICBjb25zdCB0cmFuc2NvZGVyUG9vbE1heFNpemUgPSBhd2FpdCBycGMuZ2V0VHJhbnNjb2RlclBvb2xNYXhTaXplKClcbiAgICAgIGNvbnN0IG1heEVhcm5pbmdzQ2xhaW1zUm91bmRzID0gYXdhaXQgcnBjLmdldE1heEVhcm5pbmdzQ2xhaW1zUm91bmRzKClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdXNlZCxcbiAgICAgICAgdG90YWxUb2tlblN1cHBseSxcbiAgICAgICAgdG90YWxCb25kZWRUb2tlbixcbiAgICAgICAgdGFyZ2V0Qm9uZGluZ1JhdGUsXG4gICAgICAgIHRyYW5zY29kZXJQb29sTWF4U2l6ZSxcbiAgICAgICAgbWF4RWFybmluZ3NDbGFpbXNSb3VuZHMsXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIHJvdW5kIChpbiBibG9ja3MpXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0Um91bmRMZW5ndGgoKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFJvdW5kTGVuZ3RoKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICByZXR1cm4gaGVhZFRvU3RyaW5nKGF3YWl0IFJvdW5kc01hbmFnZXIucm91bmRMZW5ndGgoKSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZXN0aW1hdGVkIG51bWJlciBvZiByb3VuZHMgcGVyIHllYXJcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRSb3VuZHNQZXJZZWFyKClcbiAgICAgKiAvLyA9PiBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRSb3VuZHNQZXJZZWFyKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICByZXR1cm4gaGVhZFRvU3RyaW5nKGF3YWl0IFJvdW5kc01hbmFnZXIucm91bmRzUGVyWWVhcigpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgcm91bmRcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRDdXJyZW50Um91bmQoKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRSb3VuZCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIGhlYWRUb1N0cmluZyhhd2FpdCBSb3VuZHNNYW5hZ2VyLmN1cnJlbnRSb3VuZCgpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCByb3VuZCBpcyBpbml0YWxpemVkXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldEN1cnJlbnRSb3VuZElzSW5pdGlhbGl6ZWQoKVxuICAgICAqIC8vID0+IGJvb2xlYW5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDdXJyZW50Um91bmRJc0luaXRpYWxpemVkKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgcmV0dXJuIGhlYWRUb0Jvb2woYXdhaXQgUm91bmRzTWFuYWdlci5jdXJyZW50Um91bmRJbml0aWFsaXplZCgpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2sgYXQgd2hpY2ggdGhlIGN1cnJlbnQgcm91bmQgc3RhcnRlZFxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldEN1cnJlbnRSb3VuZFN0YXJ0QmxvY2soKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRSb3VuZFN0YXJ0QmxvY2soKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHJldHVybiBoZWFkVG9TdHJpbmcoYXdhaXQgUm91bmRzTWFuYWdlci5jdXJyZW50Um91bmRTdGFydEJsb2NrKCkpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91c2x5IGludGl0aWFsaXplZCByb3VuZFxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldExhc3RJbml0aWFsaXplZFJvdW5kKClcbiAgICAgKiAvLyA9PiBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRMYXN0SW5pdGlhbGl6ZWRSb3VuZCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIGhlYWRUb1N0cmluZyhhd2FpdCBSb3VuZHNNYW5hZ2VyLmxhc3RJbml0aWFsaXplZFJvdW5kKCkpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgZ2VuZXJhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm91bmRzIGluIHRoZSBwcm90b2NvbFxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJvdW5kSW5mbz59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmdldEN1cnJlbnRSb3VuZEluZm8oKVxuICAgICAqIC8vID0+IFJvdW5kSW5mbyB7XG4gICAgICogLy8gICBpZDogc3RyaW5nLFxuICAgICAqIC8vICAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW4sXG4gICAgICogLy8gICBzdGFydEJsb2NrOiBzdHJpbmcsXG4gICAgICogLy8gICBsYXN0SW5pdGlhbGl6ZWRSb3VuZDogc3RyaW5nLFxuICAgICAqIC8vICAgbGVuZ3RoOiBzdHJpbmcsXG4gICAgICogLy8gfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnRSb3VuZEluZm8oKTogUHJvbWlzZTxSb3VuZEluZm8+IHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGF3YWl0IHJwYy5nZXRSb3VuZExlbmd0aCgpXG4gICAgICBjb25zdCBpZCA9IGF3YWl0IHJwYy5nZXRDdXJyZW50Um91bmQoKVxuICAgICAgY29uc3QgaW5pdGlhbGl6ZWQgPSBhd2FpdCBycGMuZ2V0Q3VycmVudFJvdW5kSXNJbml0aWFsaXplZCgpXG4gICAgICBjb25zdCBsYXN0SW5pdGlhbGl6ZWRSb3VuZCA9IGF3YWl0IHJwYy5nZXRMYXN0SW5pdGlhbGl6ZWRSb3VuZCgpXG4gICAgICBjb25zdCBzdGFydEJsb2NrID0gYXdhaXQgcnBjLmdldEN1cnJlbnRSb3VuZFN0YXJ0QmxvY2soKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIGluaXRpYWxpemVkLFxuICAgICAgICBsYXN0SW5pdGlhbGl6ZWRSb3VuZCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBzdGFydEJsb2NrLFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBnZXRMaXBVcGdyYWRlUm91bmQobGlwTnVtYmVyKSB7XG4gICAgICByZXR1cm4gKGF3YWl0IFJvdW5kc01hbmFnZXIubGlwVXBncmFkZVJvdW5kKGxpcE51bWJlcikpWzBdXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgTFBUIGZyb20gdGhlIGZhdWNldFxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0ge1R4Q29uZmlnfSBbdHggPSBjb25maWcuZGVmYXVsdFR4XSAtIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBgZnJvbWAgYW5kIGBnYXNgIHZhbHVlcyBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFR4UmVjZWlwdD59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLnRhcEZhdWNldCgnMTMzNycpXG4gICAgICogLy8gPT4gVHhSZWNlaXB0IHtcbiAgICAgKiAvLyAgIHRyYW5zYWN0aW9uSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgdHJhbnNhY3Rpb25JbmRleFwiOiBCTixcbiAgICAgKiAvLyAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgYmxvY2tOdW1iZXI6IEJOLFxuICAgICAqIC8vICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IEJOLFxuICAgICAqIC8vICAgZ2FzVXNlZDogQk4sXG4gICAgICogLy8gICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgICAgKiAvLyAgIGxvZ3M6IEFycmF5PExvZyB7XG4gICAgICogLy8gICAgIGxvZ0luZGV4OiBCTixcbiAgICAgKiAvLyAgICAgYmxvY2tOdW1iZXI6IEJOLFxuICAgICAqIC8vICAgICBibG9ja0hhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRyYW5zYWN0aW9uSW5kZXg6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgYWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgICBkYXRhOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRvcGljczogQXJyYXk8c3RyaW5nPlxuICAgICAqIC8vICAgfT5cbiAgICAgKiAvLyB9XG4gICAgICovXG4gICAgYXN5bmMgdGFwRmF1Y2V0KHR4ID0gY29uZmlnLmRlZmF1bHRUeCk6IFByb21pc2U8VHhSZWNlaXB0PiB7XG4gICAgICAvLyBjb25zdCBtcyA9IGF3YWl0IHJwYy5nZXRGYXVjZXRUYXBJbih0eC5mcm9tKVxuICAgICAgLy8gaWYgKG1zID4gMClcbiAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgLy8gICAgIGBDYW4ndCB0YXAgdGhlIGZhdWNldCByaWdodCBub3cuIFlvdXIgbmV4dCB0YXAgaXMgaW4gJHtmb3JtYXREdXJhdGlvbihcbiAgICAgIC8vICAgICAgIG1zLFxuICAgICAgLy8gICAgICl9LmAsXG4gICAgICAvLyAgIClcbiAgICAgIC8vIHRhcCB0aGUgZmF1Y2V0XG4gICAgICByZXR1cm4gYXdhaXQgdXRpbHMuZ2V0VHhSZWNlaXB0KFxuICAgICAgICBhd2FpdCBMaXZlcGVlclRva2VuRmF1Y2V0LnJlcXVlc3QodHgpLFxuICAgICAgICBjb25maWcuZXRoLFxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcm91bmRcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtUeENvbmZpZ30gW3R4ID0gY29uZmlnLmRlZmF1bHRUeF0gLSBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgYGZyb21gIGFuZCBgZ2FzYCB2YWx1ZXMgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxUeFJlY2VpcHQ+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5pbml0aWFsaXplUm91bmQoKVxuICAgICAqIC8vID0+IFR4UmVjZWlwdCB7XG4gICAgICogLy8gICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIHRyYW5zYWN0aW9uSW5kZXhcIjogQk4sXG4gICAgICogLy8gICBibG9ja0hhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgIGN1bXVsYXRpdmVHYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGdhc1VzZWQ6IEJOLFxuICAgICAqIC8vICAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICBsb2dzOiBBcnJheTxMb2cge1xuICAgICAqIC8vICAgICBsb2dJbmRleDogQk4sXG4gICAgICogLy8gICAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRyYW5zYWN0aW9uSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkluZGV4OiBzdHJpbmcsXG4gICAgICogLy8gICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgZGF0YTogc3RyaW5nLFxuICAgICAqIC8vICAgICB0b3BpY3M6IEFycmF5PHN0cmluZz5cbiAgICAgKiAvLyAgIH0+XG4gICAgICogLy8gfVxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemVSb3VuZCh0eCA9IGNvbmZpZy5kZWZhdWx0VHgpOiBQcm9taXNlPFR4UmVjZWlwdD4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgUm91bmRzTWFuYWdlci5pbml0aWFsaXplUm91bmQodHgpXG4gICAgICAgIGlmICh0eC5yZXR1cm5UeEhhc2gpIHtcbiAgICAgICAgICByZXR1cm4gdHhIYXNoXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldFR4UmVjZWlwdCh0eEhhc2gsIGNvbmZpZy5ldGgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSAnRXJyb3I6IGluaXRpYWxpemVSb3VuZFxcbicgKyBlcnIubWVzc2FnZVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgYXBwcm92ZVRva2VuUG9sbENyZWF0aW9uQ29zdChcbiAgICAgIGFtb3VudDogc3RyaW5nLFxuICAgICAgdHg6IFR4T2JqZWN0LFxuICAgICk6IFByb21pc2U8VHhSZWNlaXB0PiB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRvQk4oYW1vdW50KVxuICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgTGl2ZXBlZXJUb2tlbi5hcHByb3ZlKFBvbGxDcmVhdG9yLmFkZHJlc3MsIHRva2VuLCB7XG4gICAgICAgIC4uLmNvbmZpZy5kZWZhdWx0VHgsXG4gICAgICAgIC4uLnR4LFxuICAgICAgfSlcbiAgICAgIGlmICh0eC5yZXR1cm5UeEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHR4SGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdXRpbHMuZ2V0VHhSZWNlaXB0KHR4SGFzaCwgY29uZmlnLmV0aClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBvbGxcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3Bvc2FsIC0gVGhlIElQRlMgbXVsdGloYXNoIGZvciB0aGUgcHJvcG9zYWxcbiAgICAgKiBAcGFyYW0ge1R4Q29uZmlnfSBbdHggPSBjb25maWcuZGVmYXVsdFR4XSAtIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBgZnJvbWAgYW5kIGBnYXNgIHZhbHVlcyBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFR4UmVjZWlwdD59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLmNyZWF0ZVBvbGwoJ1FtLi4uJylcbiAgICAgKiAvLyA9PiBUeFJlY2VpcHQge1xuICAgICAqIC8vICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICB0cmFuc2FjdGlvbkluZGV4XCI6IEJOLFxuICAgICAqIC8vICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICBjdW11bGF0aXZlR2FzVXNlZDogQk4sXG4gICAgICogLy8gICBnYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgbG9nczogQXJyYXk8TG9nIHtcbiAgICAgKiAvLyAgICAgbG9nSW5kZXg6IEJOLFxuICAgICAqIC8vICAgICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25JbmRleDogc3RyaW5nLFxuICAgICAqIC8vICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICAgIGRhdGE6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdG9waWNzOiBBcnJheTxzdHJpbmc+XG4gICAgICogLy8gICB9PlxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQb2xsKHByb3Bvc2FsLCB0eCA9IGNvbmZpZy5kZWZhdWx0VHgpOiBQcm9taXNlPFR4UmVjZWlwdD4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgUG9sbENyZWF0b3IuY3JlYXRlUG9sbChwcm9wb3NhbCwge1xuICAgICAgICAgIC4uLmNvbmZpZy5kZWZhdWx0VHgsXG4gICAgICAgICAgLi4udHgsXG4gICAgICAgIH0pXG4gICAgICAgIGlmICh0eC5yZXR1cm5UeEhhc2gpIHtcbiAgICAgICAgICByZXR1cm4gdHhIYXNoXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldFR4UmVjZWlwdCh0eEhhc2gsIGNvbmZpZy5ldGgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSAnRXJyb3I6IGNyZWF0ZVBvbGxcXG4nICsgZXJyLm1lc3NhZ2VcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBQb2xsQ3JlYXRvciB0cmFuc2ZlciBhbGxvd2FuY2VcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBhZGRyIC0gdXNlcidzIEVUSCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtUeENvbmZpZ30gW3R4ID0gY29uZmlnLmRlZmF1bHRUeF0gLSBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgYGZyb21gIGFuZCBgZ2FzYCB2YWx1ZXMgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxUeFJlY2VpcHQ+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5nZXRQb2xsQ3JlYXRvckFsbG93YW5jZSgnMHguLi4nKVxuICAgICAqIC8vID0+IFR4UmVjZWlwdCB7XG4gICAgICogLy8gICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIHRyYW5zYWN0aW9uSW5kZXhcIjogQk4sXG4gICAgICogLy8gICBibG9ja0hhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgIGN1bXVsYXRpdmVHYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGdhc1VzZWQ6IEJOLFxuICAgICAqIC8vICAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICBsb2dzOiBBcnJheTxMb2cge1xuICAgICAqIC8vICAgICBsb2dJbmRleDogQk4sXG4gICAgICogLy8gICAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRyYW5zYWN0aW9uSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkluZGV4OiBzdHJpbmcsXG4gICAgICogLy8gICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgZGF0YTogc3RyaW5nLFxuICAgICAqIC8vICAgICB0b3BpY3M6IEFycmF5PHN0cmluZz5cbiAgICAgKiAvLyAgIH0+XG4gICAgICogLy8gfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFBvbGxDcmVhdG9yQWxsb3dhbmNlKGFkZHIpOiBQcm9taXNlPFR4UmVjZWlwdD4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHJwYy5nZXRFTlNBZGRyZXNzLCBhZGRyKVxuICAgICAgICByZXR1cm4gaGVhZFRvU3RyaW5nKFxuICAgICAgICAgIGF3YWl0IExpdmVwZWVyVG9rZW4uYWxsb3dhbmNlKGFkZHJlc3MsIFBvbGxDcmVhdG9yLmFkZHJlc3MpLFxuICAgICAgICApXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSAnRXJyb3I6IGdldFBvbGxDcmVhdG9yQWxsb3dhbmNlXFxuJyArIGVyci5tZXNzYWdlXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgQm9uZGluZ01hbmFnZXIgdHJhbnNmZXIgYWxsb3dhbmNlXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYWRkciAtIHVzZXIncyBFVEggYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IFt0eCA9IGNvbmZpZy5kZWZhdWx0VHhdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGBmcm9tYCBhbmQgYGdhc2AgdmFsdWVzIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8VHhSZWNlaXB0Pn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0Qm9uZGluZ01hbmFnZXJBbGxvd2FuY2UoJzB4Li4uJylcbiAgICAgKiAvLyA9PiBUeFJlY2VpcHQge1xuICAgICAqIC8vICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICB0cmFuc2FjdGlvbkluZGV4XCI6IEJOLFxuICAgICAqIC8vICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICBjdW11bGF0aXZlR2FzVXNlZDogQk4sXG4gICAgICogLy8gICBnYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgbG9nczogQXJyYXk8TG9nIHtcbiAgICAgKiAvLyAgICAgbG9nSW5kZXg6IEJOLFxuICAgICAqIC8vICAgICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25JbmRleDogc3RyaW5nLFxuICAgICAqIC8vICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICAgIGRhdGE6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdG9waWNzOiBBcnJheTxzdHJpbmc+XG4gICAgICogLy8gICB9PlxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCb25kaW5nTWFuYWdlckFsbG93YW5jZShhZGRyKTogUHJvbWlzZTxUeFJlY2VpcHQ+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhycGMuZ2V0RU5TQWRkcmVzcywgYWRkcilcbiAgICAgICAgcmV0dXJuIGhlYWRUb1N0cmluZyhcbiAgICAgICAgICBhd2FpdCBMaXZlcGVlclRva2VuLmFsbG93YW5jZShhZGRyZXNzLCBCb25kaW5nTWFuYWdlci5hZGRyZXNzKSxcbiAgICAgICAgKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gJ0Vycm9yOiBnZXRCb25kaW5nTWFuYWdlckFsbG93YW5jZVxcbicgKyBlcnIubWVzc2FnZVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBvbGxcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBvbGxBZGRyZXNzIC0gcG9sbCBjb250cmFjdCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtpbnR9IGNob2ljZUlkIC0gdm90ZSAoMCA9IHllcywgMSA9IG5vKVxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IFt0eCA9IGNvbmZpZy5kZWZhdWx0VHhdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGBmcm9tYCBhbmQgYGdhc2AgdmFsdWVzIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8VHhSZWNlaXB0Pn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuaW5pdGlhbGl6ZVJvdW5kKClcbiAgICAgKiAvLyA9PiBUeFJlY2VpcHQge1xuICAgICAqIC8vICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICB0cmFuc2FjdGlvbkluZGV4XCI6IEJOLFxuICAgICAqIC8vICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICBjdW11bGF0aXZlR2FzVXNlZDogQk4sXG4gICAgICogLy8gICBnYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgbG9nczogQXJyYXk8TG9nIHtcbiAgICAgKiAvLyAgICAgbG9nSW5kZXg6IEJOLFxuICAgICAqIC8vICAgICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25JbmRleDogc3RyaW5nLFxuICAgICAqIC8vICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICAgIGRhdGE6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdG9waWNzOiBBcnJheTxzdHJpbmc+XG4gICAgICogLy8gICB9PlxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyB2b3RlKFxuICAgICAgcG9sbEFkZHJlc3MsXG4gICAgICBjaG9pY2VJZCxcbiAgICAgIHR4ID0gY29uZmlnLmRlZmF1bHRUeCxcbiAgICApOiBQcm9taXNlPFR4UmVjZWlwdD4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUG9sbCA9IGF3YWl0IGdldENvbnRyYWN0QXQoY29uZmlnLmV0aCwge1xuICAgICAgICAgIC4uLlBvbGxBcnRpZmFjdCxcbiAgICAgICAgICBkZWZhdWx0VHg6IGNvbmZpZy5kZWZhdWx0VHgsXG4gICAgICAgICAgYWRkcmVzczogcG9sbEFkZHJlc3MsXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IFBvbGwudm90ZShjaG9pY2VJZCwge1xuICAgICAgICAgIC4uLmNvbmZpZy5kZWZhdWx0VHgsXG4gICAgICAgICAgLi4udHgsXG4gICAgICAgIH0pXG4gICAgICAgIGlmICh0eC5yZXR1cm5UeEhhc2gpIHtcbiAgICAgICAgICByZXR1cm4gdHhIYXNoXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldFR4UmVjZWlwdCh0eEhhc2gsIGNvbmZpZy5ldGgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSAnRXJyb3I6IHZvdGVcXG4nICsgZXJyLm1lc3NhZ2VcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsYWltcyB0b2tlbiBhbmQgZXRoIGVhcm5pbmdzIGZyb20gdGhlIHNlbmRlcidzIGBsYXN0Q2xhaW1Sb3VuZCArIDFgIHRocm91Z2ggYSBnaXZlbiBgZW5kUm91bmRgXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRSb3VuZCAtIHRoZSByb3VuZCB0byBjbGFpbSBlYXJuaW5ncyB1bnRpbFxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IFt0eCA9IGNvbmZpZy5kZWZhdWx0VHhdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGBmcm9tYCBhbmQgYGdhc2AgdmFsdWVzIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuY2xhaW1FYXJuaW5ncygpXG4gICAgICogLy8gPT4gc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgY2xhaW1FYXJuaW5ncyhcbiAgICAgIGVuZFJvdW5kOiBzdHJpbmcsXG4gICAgICB0eCA9IGNvbmZpZy5kZWZhdWx0VHgsXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgIHJldHVybiBhd2FpdCBCb25kaW5nTWFuYWdlci5jbGFpbUVhcm5pbmdzKGVuZFJvdW5kLCB7XG4gICAgICAgIC4uLmNvbmZpZy5kZWZhdWx0VHgsXG4gICAgICAgIC4uLnR4LFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgYXBwcm92ZVRva2VuQm9uZEFtb3VudChcbiAgICAgIGFtb3VudDogc3RyaW5nLFxuICAgICAgdHg6IFR4T2JqZWN0LFxuICAgICk6IFByb21pc2U8VHhSZWNlaXB0PiB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRvQk4oYW1vdW50KVxuICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgTGl2ZXBlZXJUb2tlbi5hcHByb3ZlKFxuICAgICAgICBCb25kaW5nTWFuYWdlci5hZGRyZXNzLFxuICAgICAgICB0b2tlbixcbiAgICAgICAge1xuICAgICAgICAgIC4uLmNvbmZpZy5kZWZhdWx0VHgsXG4gICAgICAgICAgLi4udHgsXG4gICAgICAgIH0sXG4gICAgICApXG4gICAgICBpZiAodHgucmV0dXJuVHhIYXNoKSB7XG4gICAgICAgIHJldHVybiB0eEhhc2hcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldFR4UmVjZWlwdCh0eEhhc2gsIGNvbmZpZy5ldGgpXG4gICAgfSxcblxuICAgIGFzeW5jIGJvbmRBcHByb3ZlZFRva2VuQW1vdW50KFxuICAgICAgdG86IHN0cmluZyxcbiAgICAgIGFtb3VudDogc3RyaW5nLFxuICAgICAgdHg6IFR4T2JqZWN0LFxuICAgICk6IFByb21pc2U8VHhSZWNlaXB0PiB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRvQk4oYW1vdW50KVxuICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgQm9uZGluZ01hbmFnZXIuYm9uZChcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIGF3YWl0IHJlc29sdmVBZGRyZXNzKHJwYy5nZXRFTlNBZGRyZXNzLCB0byksXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5jb25maWcuZGVmYXVsdFR4LFxuICAgICAgICAgIC4uLnR4LFxuICAgICAgICB9LFxuICAgICAgKVxuXG4gICAgICBpZiAodHgucmV0dXJuVHhIYXNoKSB7XG4gICAgICAgIHJldHVybiB0eEhhc2hcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldFR4UmVjZWlwdCh0eEhhc2gsIGNvbmZpZy5ldGgpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJvbmRzIHRvIGEgdHJhbnNjb2RlciB3aXRoIGhpbnRcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvbGREZWxlZ2F0ZU5ld1Bvc1ByZXZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkRGVsZWdhdGVOZXdQb3NOZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJEZWxlZ2F0ZU5ld1Bvc1ByZXZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VyckRlbGVnYXRlTmV3UG9zTmV4dFxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IFt0eCA9IGNvbmZpZy5kZWZhdWx0VHhdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGBmcm9tYCBhbmQgYGdhc2AgdmFsdWVzIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8VHhSZWNlaXB0Pn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuYm9uZFdpdGhIaW50KFwiMTAwXCIsIFwiMHhcIiwgXCIweFwiLCBcIjB4XCIsIFwiMHhcIiwgXCIweFwiKVxuICAgICAqIC8vID0+IFR4UmVjZWlwdCB7XG4gICAgICogLy8gICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIHRyYW5zYWN0aW9uSW5kZXhcIjogQk4sXG4gICAgICogLy8gICBibG9ja0hhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgIGN1bXVsYXRpdmVHYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGdhc1VzZWQ6IEJOLFxuICAgICAqIC8vICAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICBsb2dzOiBBcnJheTxMb2cge1xuICAgICAqIC8vICAgICBsb2dJbmRleDogQk4sXG4gICAgICogLy8gICAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRyYW5zYWN0aW9uSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkluZGV4OiBzdHJpbmcsXG4gICAgICogLy8gICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgZGF0YTogc3RyaW5nLFxuICAgICAqIC8vICAgICB0b3BpY3M6IEFycmF5PHN0cmluZz5cbiAgICAgKiAvLyAgIH0+XG4gICAgICogLy8gfVxuICAgICAqL1xuICAgIGFzeW5jIGJvbmRXaXRoSGludChcbiAgICAgIGFtb3VudDogc3RyaW5nLFxuICAgICAgdG86IHN0cmluZyxcbiAgICAgIG9sZERlbGVnYXRlTmV3UG9zUHJldjogc3RyaW5nLFxuICAgICAgb2xkRGVsZWdhdGVOZXdQb3NOZXh0OiBzdHJpbmcsXG4gICAgICBjdXJyRGVsZWdhdGVOZXdQb3NQcmV2OiBzdHJpbmcsXG4gICAgICBjdXJyRGVsZWdhdGVOZXdQb3NOZXh0OiBzdHJpbmcsXG4gICAgICB0eDogVHhPYmplY3QsXG4gICAgKTogUHJvbWlzZTxUeFJlY2VpcHQ+IHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9CTihhbW91bnQpXG4gICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCBCb25kaW5nTWFuYWdlci5ib25kV2l0aEhpbnQoXG4gICAgICAgIHRva2VuLFxuICAgICAgICBhd2FpdCByZXNvbHZlQWRkcmVzcyhycGMuZ2V0RU5TQWRkcmVzcywgdG8pLFxuICAgICAgICBvbGREZWxlZ2F0ZU5ld1Bvc1ByZXYsXG4gICAgICAgIG9sZERlbGVnYXRlTmV3UG9zTmV4dCxcbiAgICAgICAgY3VyckRlbGVnYXRlTmV3UG9zUHJldixcbiAgICAgICAgY3VyckRlbGVnYXRlTmV3UG9zTmV4dCxcbiAgICAgICAge1xuICAgICAgICAgIC4uLmNvbmZpZy5kZWZhdWx0VHgsXG4gICAgICAgICAgLi4udHgsXG4gICAgICAgIH0sXG4gICAgICApXG5cbiAgICAgIGlmICh0eC5yZXR1cm5UeEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHR4SGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdXRpbHMuZ2V0VHhSZWNlaXB0KHR4SGFzaCwgY29uZmlnLmV0aClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZXN0aW1hdGVkIGFtb3VudCBvZiBnYXMgdG8gYmUgdXNlZCBieSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICogbWV0aG9kLlxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW1cbiAgICAgKiAgY29udHJhY3ROYW1lOiBuYW1lIG9mIGNvbnRyYWN0IGNvbnRhaW5pbmcgbWV0aG9kIHlvdSB3aXNoIHRvIGZpbmQgZ2FzIHByaWNlIGZvci5cbiAgICAgKiAgbWV0aG9kTmFtZTogbmFtZSBvZiBtZXRob2Qgb24gY29udHJhY3QuXG4gICAgICogIG1ldGhvZEFyZ3M6IGFycmF5IG9mIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCB0byB0aGUgY29udHJhY3QgaW4gc3BlY2lmaWVkIG9yZGVyLlxuICAgICAqICB0eDogKG9wdGlvYW5sKXtcbiAgICAgKiAgICBmcm9tOiBhZGRyZXNzIC0gMHguLi4sXG4gICAgICogICAgZ2FzOiBudW1iZXIsXG4gICAgICogICAgdmFsdWU6IChvcHRpb25hbCkgbnVtYmVyIG9yIHN0cmluZyBjb250YWluaW5nIG51bWJlclxuICAgICAqICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPG51bWJlcj59IGNvbnRhaW5pbmcgZXN0aW1hdGVkIGdhcyBwcmljZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy5lc3RpbWF0ZUdhcyhcbiAgICAgKiAgJ0JvbmRpbmdNYW5hZ2VyJyxcbiAgICAgKiAgJ2JvbmQnLFxuICAgICAqICBbMTAsICcweDAwLi4uLi4nXVxuICAgICAqIClcbiAgICAgKiAvLyA9PiAzMzQ1NFxuICAgICAqL1xuICAgIGFzeW5jIGVzdGltYXRlR2FzKFxuICAgICAgY29udHJhY3ROYW1lOiBzdHJpbmcsXG4gICAgICBtZXRob2ROYW1lOiBzdHJpbmcsXG4gICAgICBtZXRob2RBcmdzOiBBcnJheSxcbiAgICAgIHR4ID0gY29uZmlnLmRlZmF1bHRUeCxcbiAgICApOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgdHgudmFsdWUgPSB0eC52YWx1ZSA/IHR4LnZhbHVlIDogJzAnXG4gICAgICBjb25zdCBnYXNSYXRlID0gMS4yXG4gICAgICBjb25zdCBjb250cmFjdEFCSSA9IGNvbmZpZy5hYmlzW2NvbnRyYWN0TmFtZV1cbiAgICAgIGNvbnN0IG1ldGhvZEFCSSA9IHV0aWxzLmZpbmRBYmlCeU5hbWUoY29udHJhY3RBQkksIG1ldGhvZE5hbWUpXG4gICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHV0aWxzLmVuY29kZU1ldGhvZFBhcmFtcyhtZXRob2RBQkksIG1ldGhvZEFyZ3MpXG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChcbiAgICAgICAgdG9OdW1iZXIoXG4gICAgICAgICAgYXdhaXQgY29uZmlnLmV0aC5lc3RpbWF0ZUdhcyh7XG4gICAgICAgICAgICB0bzogY29uZmlnLmNvbnRyYWN0c1tjb250cmFjdE5hbWVdLmFkZHJlc3MsXG4gICAgICAgICAgICBmcm9tOiBjb25maWcuZGVmYXVsdFR4LmZyb20sXG4gICAgICAgICAgICB2YWx1ZTogdHgudmFsdWUsXG4gICAgICAgICAgICBkYXRhOiBlbmNvZGVkRGF0YSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKSAqIGdhc1JhdGUsXG4gICAgICApXG4gICAgfSxcblxuICAgIGdldENhbGxkYXRhKFxuICAgICAgY29udHJhY3ROYW1lOiBzdHJpbmcsXG4gICAgICBtZXRob2ROYW1lOiBzdHJpbmcsXG4gICAgICBtZXRob2RBcmdzOiBBcnJheSxcbiAgICApOiBzdHJpbmcge1xuICAgICAgY29uc3QgY29udHJhY3RBQkkgPSBjb25maWcuYWJpc1tjb250cmFjdE5hbWVdXG4gICAgICBjb25zdCBtZXRob2RBQkkgPSB1dGlscy5maW5kQWJpQnlOYW1lKGNvbnRyYWN0QUJJLCBtZXRob2ROYW1lKVxuICAgICAgcmV0dXJuIHV0aWxzLmVuY29kZU1ldGhvZFBhcmFtcyhtZXRob2RBQkksIG1ldGhvZEFyZ3MpXG4gICAgfSxcblxuICAgIGFzeW5jIGVzdGltYXRlR2FzUmF3KHR4KSB7XG4gICAgICBjb25zdCBnYXNSYXRlID0gMS4yXG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChcbiAgICAgICAgdG9OdW1iZXIoXG4gICAgICAgICAgYXdhaXQgY29uZmlnLmV0aC5lc3RpbWF0ZUdhcyh7XG4gICAgICAgICAgICAuLi50eCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKSAqIGdhc1JhdGUsXG4gICAgICApXG4gICAgfSxcblxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCA9IGNvbmZpZy5kZWZhdWx0VHgpOiBQcm9taXNlPFR4UmVjZWlwdD4ge1xuICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgY29uZmlnLmV0aC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAuLi5jb25maWcuZGVmYXVsdFR4LFxuICAgICAgICAuLi50eCxcbiAgICAgIH0pXG5cbiAgICAgIGlmICh0eC5yZXR1cm5UeEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHR4SGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdXRpbHMuZ2V0VHhSZWNlaXB0KHR4SGFzaCwgY29uZmlnLmV0aClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5ib25kcyBMUFQgZnJvbSBhbiBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IFt0eCA9IGNvbmZpZy5kZWZhdWx0VHhdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGBmcm9tYCBhbmQgYGdhc2AgdmFsdWVzIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8VHhSZWNlaXB0Pn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMudW5ib25kKGFtb3VudClcbiAgICAgKiAvLyA9PiBUeFJlY2VpcHQge1xuICAgICAqIC8vICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICB0cmFuc2FjdGlvbkluZGV4XCI6IEJOLFxuICAgICAqIC8vICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICBjdW11bGF0aXZlR2FzVXNlZDogQk4sXG4gICAgICogLy8gICBnYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgbG9nczogQXJyYXk8TG9nIHtcbiAgICAgKiAvLyAgICAgbG9nSW5kZXg6IEJOLFxuICAgICAqIC8vICAgICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25JbmRleDogc3RyaW5nLFxuICAgICAqIC8vICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICAgIGRhdGE6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdG9waWNzOiBBcnJheTxzdHJpbmc+XG4gICAgICogLy8gICB9PlxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyB1bmJvbmQoYW1vdW50OiBzdHJpbmcsIHR4ID0gY29uZmlnLmRlZmF1bHRUeCk6IFByb21pc2U8VHhSZWNlaXB0PiB7XG4gICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCBCb25kaW5nTWFuYWdlci51bmJvbmQoYW1vdW50LCB7XG4gICAgICAgIC4uLmNvbmZpZy5kZWZhdWx0VHgsXG4gICAgICAgIC4uLnR4LFxuICAgICAgfSlcblxuICAgICAgaWYgKHR4LnJldHVyblR4SGFzaCkge1xuICAgICAgICByZXR1cm4gdHhIYXNoXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCB1dGlscy5nZXRUeFJlY2VpcHQodHhIYXNoLCBjb25maWcuZXRoKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmJvbmRzIExQVCBmcm9tIGFuIGFkZHJlc3Mgd2l0aCBoaW50XG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UG9zUHJldlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQb3NOZXh0XG4gICAgICogQHBhcmFtIHtUeENvbmZpZ30gW3R4ID0gY29uZmlnLmRlZmF1bHRUeF0gLSBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgYGZyb21gIGFuZCBgZ2FzYCB2YWx1ZXMgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxUeFJlY2VpcHQ+fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy51bmJvbmRXaXRoSGludChcIjEwMFwiLCBcIjB4XCIsIFwiMHhcIilcbiAgICAgKiAvLyA9PiBUeFJlY2VpcHQge1xuICAgICAqIC8vICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICB0cmFuc2FjdGlvbkluZGV4XCI6IEJOLFxuICAgICAqIC8vICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICBjdW11bGF0aXZlR2FzVXNlZDogQk4sXG4gICAgICogLy8gICBnYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgbG9nczogQXJyYXk8TG9nIHtcbiAgICAgKiAvLyAgICAgbG9nSW5kZXg6IEJOLFxuICAgICAqIC8vICAgICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25JbmRleDogc3RyaW5nLFxuICAgICAqIC8vICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICAgIGRhdGE6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdG9waWNzOiBBcnJheTxzdHJpbmc+XG4gICAgICogLy8gICB9PlxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyB1bmJvbmRXaXRoSGludChcbiAgICAgIGFtb3VudDogc3RyaW5nLFxuICAgICAgbmV3UG9zUHJldjogc3RyaW5nLFxuICAgICAgbmV3UG9zTmV4dDogc3RyaW5nLFxuICAgICAgdHggPSBjb25maWcuZGVmYXVsdFR4LFxuICAgICk6IFByb21pc2U8VHhSZWNlaXB0PiB7XG4gICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCBCb25kaW5nTWFuYWdlci51bmJvbmRXaXRoSGludChcbiAgICAgICAgYW1vdW50LFxuICAgICAgICBuZXdQb3NQcmV2LFxuICAgICAgICBuZXdQb3NOZXh0LFxuICAgICAgICB7XG4gICAgICAgICAgLi4uY29uZmlnLmRlZmF1bHRUeCxcbiAgICAgICAgICAuLi50eCxcbiAgICAgICAgfSxcbiAgICAgIClcblxuICAgICAgaWYgKHR4LnJldHVyblR4SGFzaCkge1xuICAgICAgICByZXR1cm4gdHhIYXNoXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCB1dGlscy5nZXRUeFJlY2VpcHQodHhIYXNoLCBjb25maWcuZXRoKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRyYW5zY29kZXIgcGFyYW1ldGVyc1xuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmV3YXJkQ3V0IC0gdGhlIGJsb2NrIHJld2FyZCBjdXQgeW91IHdpc2ggdG8gc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZlZVNoYXJlIC0gdGhlIGZlZSBzaGFyZSB5b3Ugd2lzaCB0byBzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpY2VQZXJTZWdtZW50IC0gdGhlIHByaWNlIHBlciBzZWdtZW50IHlvdSB3aXNoIHRvIHNldFxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IFt0eCA9IGNvbmZpZy5kZWZhdWx0VHhdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGBmcm9tYCBhbmQgYGdhc2AgdmFsdWVzIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8VHhSZWNlaXB0Pn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuc2V0dXBUcmFuc2NvZGVyKCcxMCcsICcxMCcsICc1JylcbiAgICAgKiAvLyA9PiBUeFJlY2VpcHQge1xuICAgICAqIC8vICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICB0cmFuc2FjdGlvbkluZGV4XCI6IEJOLFxuICAgICAqIC8vICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICBjdW11bGF0aXZlR2FzVXNlZDogQk4sXG4gICAgICogLy8gICBnYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgbG9nczogQXJyYXk8TG9nIHtcbiAgICAgKiAvLyAgICAgbG9nSW5kZXg6IEJOLFxuICAgICAqIC8vICAgICBibG9ja051bWJlcjogQk4sXG4gICAgICogLy8gICAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25JbmRleDogc3RyaW5nLFxuICAgICAqIC8vICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICAgIGRhdGE6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdG9waWNzOiBBcnJheTxzdHJpbmc+XG4gICAgICogLy8gICB9PlxuICAgICAqIC8vIH1cbiAgICAgKi9cbiAgICBhc3luYyBzZXR1cFRyYW5zY29kZXIoXG4gICAgICByZXdhcmRDdXQ6IHN0cmluZywgLy8gcGVyY2VudGFnZVxuICAgICAgZmVlU2hhcmU6IHN0cmluZywgLy8gcGVyY2VudGFnZVxuICAgICAgcHJpY2VQZXJTZWdtZW50OiBzdHJpbmcsIC8vIGxwdFxuICAgICAgdHggPSBjb25maWcuZGVmYXVsdFR4LFxuICAgICk6IFByb21pc2U8VHhSZWNlaXB0PiB7XG4gICAgICAvLyBiZWNvbWUgYSB0cmFuc2NvZGVyXG4gICAgICByZXR1cm4gYXdhaXQgdXRpbHMuZ2V0VHhSZWNlaXB0KFxuICAgICAgICBhd2FpdCBCb25kaW5nTWFuYWdlci50cmFuc2NvZGVyKFxuICAgICAgICAgIHRvQk4ocmV3YXJkQ3V0KSxcbiAgICAgICAgICB0b0JOKGZlZVNoYXJlKSxcbiAgICAgICAgICB0b0JOKHByaWNlUGVyU2VnbWVudCksXG4gICAgICAgICAgdHgsXG4gICAgICAgICksXG4gICAgICAgIGNvbmZpZy5ldGgsXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0YXJnZXQgYm9uZGluZyByYXRlXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMuZ2V0VGFyZ2V0Qm9uZGluZ1JhdGUoKVxuICAgICAqIC8vID0+IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRhcmdldEJvbmRpbmdSYXRlKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICByZXR1cm4gaGVhZFRvU3RyaW5nKGF3YWl0IE1pbnRlci50YXJnZXRCb25kaW5nUmF0ZSgpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaXRoZHJhd3MgZWFybmVkIHRva2VuIChUcmFuc2ZlcnMgYSBzZW5kZXIncyBkZWxlZ2F0b3IgYGJvbmRlZEFtb3VudGAgdG8gdGhlaXIgYHRva2VuQmFsYW5jZWApXG4gICAgICogQG1lbWJlcm9mIGxpdmVwZWVyfnJwY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdW5ib25kTG9ja0lkXSAtIHRoZSB1bmJvbmQgbG9jayBpZFxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IFt0eCA9IGNvbmZpZy5kZWZhdWx0VHhdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGBmcm9tYCBhbmQgYGdhc2AgdmFsdWVzIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEByZXR1cm4ge1R4UmVjZWlwdH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBhd2FpdCBycGMud2l0aGRyYXdTdGFrZSgpXG4gICAgICogLy8gPT4gVHhSZWNlaXB0IHtcbiAgICAgKiAvLyAgIHRyYW5zYWN0aW9uSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgdHJhbnNhY3Rpb25JbmRleFwiOiBCTixcbiAgICAgKiAvLyAgIGJsb2NrSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgYmxvY2tOdW1iZXI6IEJOLFxuICAgICAqIC8vICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IEJOLFxuICAgICAqIC8vICAgZ2FzVXNlZDogQk4sXG4gICAgICogLy8gICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgICAgKiAvLyAgIGxvZ3M6IEFycmF5PExvZyB7XG4gICAgICogLy8gICAgIGxvZ0luZGV4OiBCTixcbiAgICAgKiAvLyAgICAgYmxvY2tOdW1iZXI6IEJOLFxuICAgICAqIC8vICAgICBibG9ja0hhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgdHJhbnNhY3Rpb25IYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRyYW5zYWN0aW9uSW5kZXg6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgYWRkcmVzczogc3RyaW5nLFxuICAgICAqIC8vICAgICBkYXRhOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRvcGljczogQXJyYXk8c3RyaW5nPlxuICAgICAqIC8vICAgfT5cbiAgICAgKiAvLyB9XG4gICAgICovXG4gICAgYXN5bmMgd2l0aGRyYXdTdGFrZShcbiAgICAgIHVuYm9uZExvY2tJZDogc3RyaW5nLFxuICAgICAgdHggPSBjb25maWcuZGVmYXVsdFR4LFxuICAgICk6IFByb21pc2U8VHhSZWNlaXB0PiB7XG4gICAgICBpZiAodHlwZW9mIHVuYm9uZExvY2tJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGFyZ3VtZW50IHVuYm9uZGluZ0xvY2tJZCcpXG4gICAgICB9XG4gICAgICBsZXQgaWQgPSB0b0JOKHVuYm9uZExvY2tJZClcbiAgICAgIGxldCB0eEhhc2ggPSBhd2FpdCBCb25kaW5nTWFuYWdlci53aXRoZHJhd1N0YWtlKHRvU3RyaW5nKGlkKSwgdHgpXG5cbiAgICAgIGlmICh0eC5yZXR1cm5UeEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHR4SGFzaFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdXRpbHMuZ2V0VHhSZWNlaXB0KHR4SGFzaCwgY29uZmlnLmV0aClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2l0aGRyYXdzIGVhcm5lZCB0b2tlbiAoVHJhbnNmZXJzIGEgc2VuZGVyJ3MgZGVsZWdhdG9yIGBib25kZWRBbW91bnRgIHRvIHRoZWlyIGB0b2tlbkJhbGFuY2VgKVxuICAgICAqIEBtZW1iZXJvZiBsaXZlcGVlcn5ycGNcbiAgICAgKiBAcGFyYW0ge30gW3VuYm9uZGxvY2tdIC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIHVuYm9uZGxvY2sgaWQsIGFtb3VudCAmIHdpdGhkcmF3Um91bmRcbiAgICAgKiBAcGFyYW0ge1R4Q29uZmlnfSBbdHggPSBjb25maWcuZGVmYXVsdFR4XSAtIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBgZnJvbWAgYW5kIGBnYXNgIHZhbHVlcyBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtUeFJlY2VpcHR9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYXdhaXQgcnBjLndpdGhkcmF3U3Rha2VXaXRoVW5ib25kTG9jayh1bmJvbmRsb2NrKVxuICAgICAqIC8vID0+IFR4UmVjZWlwdCB7XG4gICAgICogLy8gICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIHRyYW5zYWN0aW9uSW5kZXhcIjogQk4sXG4gICAgICogLy8gICBibG9ja0hhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgIGN1bXVsYXRpdmVHYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGdhc1VzZWQ6IEJOLFxuICAgICAqIC8vICAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICBsb2dzOiBBcnJheTxMb2cge1xuICAgICAqIC8vICAgICBsb2dJbmRleDogQk4sXG4gICAgICogLy8gICAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRyYW5zYWN0aW9uSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkluZGV4OiBzdHJpbmcsXG4gICAgICogLy8gICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgZGF0YTogc3RyaW5nLFxuICAgICAqIC8vICAgICB0b3BpY3M6IEFycmF5PHN0cmluZz5cbiAgICAgKiAvLyAgIH0+XG4gICAgICogLy8gfVxuICAgICAqL1xuXG4gICAgYXN5bmMgd2l0aGRyYXdTdGFrZVdpdGhVbmJvbmRMb2NrKFxuICAgICAgdW5ib25kbG9jazogeyBpZDogc3RyaW5nLCBhbW91bnQ6IHN0cmluZywgd2l0aGRyYXdSb3VuZDogc3RyaW5nIH0sXG4gICAgICB0eCA9IGNvbmZpZy5kZWZhdWx0VHgsXG4gICAgKTogUHJvbWlzZTxUeFJlY2VpcHQ+IHtcbiAgICAgIGNvbnN0IHsgaWQsIGFtb3VudCwgd2l0aGRyYXdSb3VuZCB9ID0gdW5ib25kbG9ja1xuXG4gICAgICBjb25zdCBjdXJyZW50Um91bmQgPSBhd2FpdCBycGMuZ2V0Q3VycmVudFJvdW5kKClcblxuICAgICAgLy8gZW5zdXJlIHRoZSB1bmJvbmRpbmcgcGVyaW9kIGlzIG92ZXJcbiAgICAgIGlmICh3aXRoZHJhd1JvdW5kID4gY3VycmVudFJvdW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVsZWdhdG9yIG11c3Qgd2FpdCB0aHJvdWdoIHVuYm9uZGluZyBwZXJpb2QnKVxuICAgICAgfSBlbHNlIGlmIChhbW91bnQgPT09ICcwJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbGVnYXRvciBkb2VzIG5vdCBoYXZlIGFueXRoaW5nIHRvIHdpdGhkcmF3JylcbiAgICAgIH0gZWxzZSBpZiAoYW1vdW50IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Ftb3VudCBjYW5ub3QgYmUgbmVnYXRpdmUnKVxuICAgICAgfVxuXG4gICAgICBsZXQgdW5ib25kaW5nTG9ja0lkID0gdG9CTihpZClcbiAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IEJvbmRpbmdNYW5hZ2VyLndpdGhkcmF3U3Rha2UoXG4gICAgICAgIHRvU3RyaW5nKHVuYm9uZGluZ0xvY2tJZCksXG4gICAgICAgIHR4LFxuICAgICAgKVxuICAgICAgaWYgKHR4LnJldHVyblR4SGFzaCkge1xuICAgICAgICByZXR1cm4gdHhIYXNoXG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgdXRpbHMuZ2V0VHhSZWNlaXB0KHR4SGFzaCwgY29uZmlnLmV0aClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2l0aGRyYXdzIGVhcm5lZCBmZWVzIChUcmFuc2ZlcnMgYSBzZW5kZXIncyBkZWxlZ2F0b3IgYGZlZXNgIHRvIHRoZWlyIGBldGhCYWxhbmNlYClcbiAgICAgKiBAbWVtYmVyb2YgbGl2ZXBlZXJ+cnBjXG4gICAgICogQHBhcmFtIHtUeENvbmZpZ30gW3R4ID0gY29uZmlnLmRlZmF1bHRUeF0gLSBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgYGZyb21gIGFuZCBgZ2FzYCB2YWx1ZXMgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHJldHVybiB7VHhSZWNlaXB0fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGF3YWl0IHJwYy53aXRoZHJhd0ZlZXMoKVxuICAgICAqIC8vID0+IFR4UmVjZWlwdCB7XG4gICAgICogLy8gICB0cmFuc2FjdGlvbkhhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIHRyYW5zYWN0aW9uSW5kZXhcIjogQk4sXG4gICAgICogLy8gICBibG9ja0hhc2g6IHN0cmluZyxcbiAgICAgKiAvLyAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgIGN1bXVsYXRpdmVHYXNVc2VkOiBCTixcbiAgICAgKiAvLyAgIGdhc1VzZWQ6IEJOLFxuICAgICAqIC8vICAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gICAgICogLy8gICBsb2dzOiBBcnJheTxMb2cge1xuICAgICAqIC8vICAgICBsb2dJbmRleDogQk4sXG4gICAgICogLy8gICAgIGJsb2NrTnVtYmVyOiBCTixcbiAgICAgKiAvLyAgICAgYmxvY2tIYXNoOiBzdHJpbmcsXG4gICAgICogLy8gICAgIHRyYW5zYWN0aW9uSGFzaDogc3RyaW5nLFxuICAgICAqIC8vICAgICB0cmFuc2FjdGlvbkluZGV4OiBzdHJpbmcsXG4gICAgICogLy8gICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICAgKiAvLyAgICAgZGF0YTogc3RyaW5nLFxuICAgICAqIC8vICAgICB0b3BpY3M6IEFycmF5PHN0cmluZz5cbiAgICAgKiAvLyAgIH0+XG4gICAgICogLy8gfVxuICAgICAqL1xuICAgIGFzeW5jIHdpdGhkcmF3RmVlcyh0eCA9IGNvbmZpZy5kZWZhdWx0VHgpOiBQcm9taXNlPFR4UmVjZWlwdD4ge1xuICAgICAgbGV0IHR4SGFzaCA9IGF3YWl0IEJvbmRpbmdNYW5hZ2VyLndpdGhkcmF3RmVlcyh0eClcbiAgICAgIGlmICh0eC5yZXR1cm5UeEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHR4SGFzaFxuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IHV0aWxzLmdldFR4UmVjZWlwdCh0eEhhc2gsIGNvbmZpZy5ldGgpXG4gICAgfSxcblxuICAgIGFzeW5jIHZlcmlmeVNuYXBzaG90KGlkLCBwcm9vZiwgbGVhZkhhc2gpIHtcbiAgICAgIHJldHVybiBhd2FpdCBNZXJrbGVTbmFwc2hvdC52ZXJpZnkoaWQsIHByb29mLCBsZWFmSGFzaClcbiAgICB9LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IGNyZWF0ZUxpdmVwZWVyU0RLLFxuICAgIGNvbmZpZyxcbiAgICBycGMsXG4gICAgdXRpbHMsXG4gICAgZXZlbnRzLFxuICAgIGNvbnN0YW50czoge1xuICAgICAgQUREUkVTU19QQUQsXG4gICAgICBFTVBUWV9BRERSRVNTLFxuICAgICAgREVMRUdBVE9SX1NUQVRVUyxcbiAgICAgIFRSQU5TQ09ERVJfU1RBVFVTLFxuICAgICAgVklERU9fUFJPRklMRV9JRF9TSVpFLFxuICAgICAgVklERU9fUFJPRklMRVMsXG4gICAgfSxcbiAgfVxuXG4gIC8vIEtlZXBpbmcgdHlwZWRlZnMgZG93biBoZXJlIHNvIHRoZXkgc2hvdyB1cCBsYXN0IGluIHRoZSBnZW5lcmF0ZWQgQVBJIHRhYmxlIG9mIGNvbnRlbnRzXG5cbiAgLyoqXG4gICAqIEFCSSBwcm9wZXJ0eSBkZXNjcmlwdG9yXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEFCSVByb3BEZXNjcmlwdG9yXG4gICAqIEBwcm9wIHtib29sZWFufSBjb25zdGFudHMgLSBpcyB0aGUgbWV0aG9kIGNvbnN0YW50P1xuICAgKiBAcHJvcCB7QXJyYXk8eyBuYW1lOiBzdHJpbmcsIHR5cGU6IHN0cmluZyB9Pn0gaW5wdXRzIC0gdGhlIG1ldGhvZCBwYXJhbXNcbiAgICogQHByb3Age0FycmF5PHsgbmFtZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcgfT59IG91dHB1dHMgLSBtZXRob2QgcmV0dXJuIHZhbHVlc1xuICAgKiBAcHJvcCB7Ym9vbGVhbn0gcGF5YWJsZSAtIGlzIHRoZSBtZXRob2QgcGF5YWJsZT9cbiAgICogQHByb3Age3N0cmluZ30gc3RhdGVNdXRhYmlsaXR5IC0gdHlwZSBvZiBzdGF0ZSBtdXRhYmlsaXR5XG4gICAqIEBwcm9wIHtzdHJpbmd9IHR5cGUgLSB0eXBlIG9mIGNvbnRyYWN0IHByb3BlcnR5XG4gICAqL1xuXG4gIC8qKlxuICAgKiBNb3N0bHkgXCJgdHJ1ZmZsZWAtc3R5bGVcIiBBQkkgYXJ0aWZhY3RzIGJ1dCBubyBieXRlY29kZS9uZXR3b3JrIHByb3BlcnRpZXMgcmVxdWlyZWRcbiAgICogQHR5cGVkZWYge09iamVjdH0gQ29udHJhY3RBcnRpZmFjdFxuICAgKiBAcHJvcCB7c3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgY29udHJhY3RcbiAgICogQHByb3Age0FycmF5PEFCSVByb3BEZXNjcmlwdG9yPn0gYWJpIC0gbGlzdHMgaW5mbyBhYm91dCBjb250cmFjdCBwcm9wZXJ0aWVzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTREsgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IExpdmVwZWVyU0RLT3B0aW9uc1xuICAgKiBAcHJvcCB7c3RyaW5nfSBbY29udHJvbGxlckFkZHJlc3MgPSAnMHgzN2RDNzEzNjZFYzY1NTA5M2I5OTMwYmM4MTZFMTZlNmI1ODdGOTY4J10gLSBUaGUgYWRkcmVzcyBvZiB0aGUgZGVscG95ZWQgQ29udHJvbGxlciBjb250cmFjdFxuICAgKiBAcHJvcCB7c3RyaW5nfSBbcHJvdmlkZXIgPSAnaHR0cHM6Ly9yaW5rZWJ5LmluZnVyYS5pby9zckZhV2cwU2xsamRKQW9DbFgzQiddIC0gVGhlIEVUSCBodHRwIHByb3ZpZGVyIGZvciBycGMgbWV0aG9kc1xuICAgKiBAcHJvcCB7bnVtYmVyfSBbZ2FzID0gMF0gLSB0aGUgYW1vdW50IG9mIGdhcyB0byBpbmNsdWRlIHdpdGggdHJhbnNhY3Rpb25zIGJ5IGRlZmF1bHRcbiAgICogQHByb3Age09iamVjdDxzdHJpbmcsIENvbnRyYWN0QXJ0aWZhY3Q+fSBhcnRpZmFjdHMgLSBhbiBvYmplY3QgY29udGFpbmluZyBjb250cmFjdCBuYW1lIC0+IENvbnRyYWN0QXJ0aWZhY3QgbWFwcGluZ3NcbiAgICogQHByb3Age09iamVjdDxzdHJpbmcsIHN0cmluZz59IHByaXZhdGVLZXlzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgcHVibGljIC0+IHByaXZhdGUga2V5IG1hcHBpbmdzLiBTaG91bGQgYmUgc3BlY2lmaWVkIGlmIHVzaW5nIHRoZSBTREsgZm9yIHRyYW5zYWN0aW9ucyB3aXRob3V0IE1ldGFNYXNrICh2aWEgQ0xJLCBldGMpXG4gICAqIEBwcm9wIHtzdHJpbmd8bnVtYmVyfSBhY2NvdW50IC0gdGhlIGFjY291bnQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRyYW5zYWN0aW5nIGFuZCBkYXRhLWZldGNoaW5nLiBDYW4gYmUgb25lIG9mIHRoZSBwdWJsaWNLZXlzIHNwZWNpZmllZCBpbiB0aGUgYHByaXZhdGVLZXlzYCBvcHRpb24gb3IgYW4gaW5kZXggb2YgYW4gYWNjb3VudCBhdmFpbGFibGUgdmlhIE1ldGFNYXNrXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBjb250cmFjdCBpbmZvIGFuZCB1dGlsaXR5IG1ldGhvZHMgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIExpdmVwZWVyIHByb3RvY29sJ3Mgc21hcnQgY29udHJhY3RzXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IExpdmVwZWVyU0RLXG4gICAqIEBwcm9wIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBjb25maWcgLSB0aGlzIHByb3AgaXMgbW9zdGx5IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgYW5kIGNvdWxkIGNoYW5nZSBhIGxvdCBpbiB0aGUgZnV0dXJlLiBDdXJyZW50bHksIGl0IGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcHM6IGBhYmlzYCwgYGFjY291bnRzYCwgYGNvbnRyYWN0c2AsIGBkZWZhdWx0VHhgLCBgZXRoYFxuICAgKiBAcHJvcCB7T2JqZWN0PHN0cmluZywgYW55Pn0gY29uc3RhbnRzIC0gRXhwb3NlcyBzb21lIGNvbnN0YW50IHZhbHVlcy4gQ3VycmVudGx5LCBpdCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BzOiBgQUREUkVTU19QQURgLCBgREVMRUdBVE9SX1NUQVRVU2AsIGBFTVBUWV9BRERSRVNTYCwgYFRSQU5TQ09ERVJfU1RBVFVTYCwgYFZJREVPX1BST0ZJTEVTYCwgYFZJREVPX1BST0ZJTEVfSURfU0laRWBcbiAgICogQHByb3Age0Z1bmN0aW9ufSBjcmVhdGUgLSBzYW1lIGFzIHRoZSBgY3JlYXRlTGl2ZXBlZXJTREtgIGZ1bmN0aW9uXG4gICAqIEBwcm9wIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q+fSBldmVudHMgLSBPYmplY3QgbWFwcGluZyBhbiBldmVudCBuYW1lIC0+IGNvbnRyYWN0IGV2ZW50IGRlc2NyaXB0b3Igb2JqZWN0XG4gICAqIEBwcm9wIHtPYmplY3Q8c3RyaW5nLCBGdW5jdGlvbj59IHJwYyAtIGNvbnRhaW5zIGFsbCBvZiB0aGUgcnBjIG1ldGhvZHMgYXZhaWxhYmxlIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBMaXZlcGVlciBwcm90b2NvbFxuICAgKiBAcHJvcCB7T2JqZWN0PHN0cmluZywgRnVuY3Rpb24+fSB1dGlscyAtIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcy4gTW9zdGx5IGhlcmUganVzdCBiZWNhdXNlLiBDb3VsZCBwb3NzaWJseSBiZSByZW1vdmVkIG9yIG1vdmVkIGludG8gaXRzIG93biBtb2R1bGUgaW4gdGhlIGZ1dHVyZVxuICAgKi9cblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRvdGFsIHRva2VuIHN1cHBseSBhbmQgYSB1c2VyJ3MgYWNjb3VudCBiYWxhbmNlLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUb2tlbkluZm9cbiAgICogQHByb3Age3N0cmluZ30gdG90YWxTdXBwbHkgLSB0b3RhbCBzdXBwbHkgb2YgdG9rZW4gYXZhaWxhYmxlIGluIHRoZSBwcm90b2NvbCAoTFBUVSlcbiAgICogQHByb3Age3N0cmluZ30gYmFsYW5jZSAtIHVzZXIncyB0b2tlbiBiYWxhbmNlIChMUFRVKVxuICAgKi9cblxuICAvKipcbiAgICogVHJhbnNhY3Rpb24gY29uZmlnIG9iamVjdFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUeENvbmZpZ1xuICAgKiBAcHJvcCB7c3RyaW5nfSBmcm9tIC0gdGhlIEVUSCBhY2NvdW50IGFkZHJlc3MgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24gZnJvbVxuICAgKiBAcHJvcCB7bnVtYmVyfSBnYXMgLSB0aGUgYW1vdW50IG9mIGdhcyB0byBpbmNsdWRlIGluIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogVHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUeFJlY2VpcHRcbiAgICogQHByb3Age3N0cmluZ30gdHJhbnNhY3Rpb25IYXNoIC0gdGhlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICogQHByb3Age0JOfSB0cmFuc2FjdGlvbkluZGV4IC0gdGhlIHRyYW5zYWN0aW9uIGluZGV4XG4gICAqIEBwcm9wIHtzdHJpbmd9IGJsb2NrSGFzaCAtIHRoZSB0cmFuc2FjdGlvbiBibG9jayBoYXNoXG4gICAqIEBwcm9wIHtCTn0gYmxvY2tOdW1iZXIgLSB0aGUgdHJhbnNhY3Rpb24gYmxvY2sgbnVtYmVyXG4gICAqIEBwcm9wIHtCTn0gY3VtdWxhdGl2ZUdhc1VzZWQgLSB0aGUgY3VtdWxhdGl2ZSBnYXMgdXNlZCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHByb3Age0JOfSBnYXNVc2VkIC0gdGhlIGdhcyB1c2VkIGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcHJvcCB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgLSB0aGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgdHJhbnNhY3Rpb24gbWV0aG9kXG4gICAqIEBwcm9wIHtBcnJheTxMb2c+fSBsb2dzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbG9ncyB0aGF0IHdlcmUgZmlyZWQgZHVyaW5nIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGNvbnRyYWN0IGxvZ1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBMb2dcbiAgICogQHByb3Age0JOfSBsb2dJbmRleCAtIHRoZSBsb2cgaW5kZXhcbiAgICogQHByb3Age0JOfSBibG9ja051bWJlciAtIHRoZSBsb2cgYmxvY2sgbnVtYmVyXG4gICAqIEBwcm9wIHtzdHJpbmd9IGJsb2NrSGFzaCAtIHRoZSBsb2cgYmxvY2sgaGFzaFxuICAgKiBAcHJvcCB7c3RyaW5nfSB0cmFuc2FjdGlvbkhhc2ggLSB0aGUgbG9nJ3MgdHJhbnNhY3Rpb24gaGFzaFxuICAgKiBAcHJvcCB7Qk59IHRyYW5zYWN0aW9uSW5kZXggLSB0aGUgbG9nJ3MgdHJhbnNhY3Rpb24gaW5kZXhcbiAgICogQHByb3Age3N0cmluZ30gYWRkcmVzcyAtIHRoZSBsb2cncyBhZGRyZXNzXG4gICAqIEBwcm9wIHtzdHJpbmd9IGRhdGEgLSB0aGUgbG9nJ3MgZGF0YVxuICAgKiBAcHJvcCB7QXJyYXk8c3RyaW5nPn0gdG9waWNzIC0gdGhlIGxvZydzIHRvcGljc1xuICAgKi9cblxuICAvKipcbiAgICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0YXR1cyBvZiB0aGUgTFBUIGZhdWNldFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBGYXVjZXRJbmZvXG4gICAqIEBwcm9wIHtzdHJpbmd9IGFtb3VudCAtIHRoZSBhbW91bnQgZGlzdHJpYnV0ZWQgYnkgdGhlIGZhdWNldFxuICAgKiBAcHJvcCB7c3RyaW5nfSB3YWl0IC0gdGhlIGZhdWNldCByZXF1ZXN0IGNvb2xkb3duIHRpbWVcbiAgICogQHByb3Age3N0cmluZ30gbmV4dCAtIHRoZSBuZXh0IHRpbWUgYSB2YWxpZCBmYXVjZXQgcmVxdWVzdCBtYXkgYmUgbWFkZVxuICAgKi9cblxuICAvKipcbiAgICogQSBCcm9hZGNhc3RlciBzdHJ1Y3RcbiAgICogQHR5cGVkZWYge09iamVjdH0gQnJvYWRjYXN0ZXJcbiAgICogQHByb3Age3N0cmluZ30gYWRkcmVzcyAtIHRoZSBFVEggYWRkcmVzcyBvZiB0aGUgYnJvYWRjYXN0ZXJcbiAgICogQHByb3Age3N0cmluZ30gZGVwb3NpdCAtIHRoZSBhbW91bnQgb2YgTFBUIHRoZSBicm9hZGNhc3RlciBoYXMgZGVwb3NpdGVkXG4gICAqIEBwcm9wIHtzdHJpbmd9IHdpdGhkcmF3QmxvY2sgLSB0aGUgbmV4dCBibG9jayBhdCB3aGljaCBhIGJyb2FkY2FzdGVyIG1heSB3aXRoZHJhdyB0aGVpciBkZXBvc2l0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIERlbGVnYXRvciBzdHJ1Y3RcbiAgICogQHR5cGVkZWYge09iamVjdH0gRGVsZWdhdG9yXG4gICAqIEBwcm9wIHtzdHJpbmd9IGFsbG93YW5jZSAtIHRoZSBkZWxlZ2F0b3IncyBMaXZlcGVlclRva2VuIGFwcHJvdmVkIGFtb3VudCBmb3IgdHJhbnNmZXJcbiAgICogQHByb3Age3N0cmluZ30gYWRkcmVzcyAtIHRoZSBkZWxlZ2F0b3IncyBFVEggYWRkcmVzc1xuICAgKiBAcHJvcCB7c3RyaW5nfSBib25kZWRBbW91bnQgLSBUaGUgYW1vdW50IG9mIExQVFUgYSBkZWxlZ2F0b3IgaGFzIGJvbmRlZFxuICAgKiBAcHJvcCB7c3RyaW5nfSBkZWxlZ2F0ZUFkZHJlc3MgLSB0aGUgRVRIIGFkZHJlc3Mgb2YgdGhlIGRlbGVnYXRvcidzIGRlbGVnYXRlXG4gICAqIEBwcm9wIHtzdHJpbmd9IGRlbGVnYXRlZEFtb3VudCAtIHRoZSBhbW91bnQgb2YgTFBUVSB0aGUgZGVsZWdhdG9yIGhhcyBkZWxlZ2F0ZWRcbiAgICogQHByb3Age3N0cmluZ30gZmVlcyAtIHRoZSBhbW91bnQgb2YgTFBUVSBhIGRlbGVnYXRvciBoYXMgY29sbGVjdGVkXG4gICAqIEBwcm9wIHtzdHJpbmd9IGxhc3RDbGFpbVJvdW5kIC0gdGhlIGxhc3Qgcm91bmQgdGhhdCB0aGUgZGVsZWdhdG9yIGNsYWltZWQgcmV3YXJkIGFuZCBmZWUgcG9vbCBzaGFyZXNcbiAgICogQHByb3Age3N0cmluZ30gcGVuZGluZ0ZlZXMgLSB0aGUgYW1vdW50IG9mIEVUSCB0aGUgZGVsZWdhdG9yIGhhcyBlYXJuZWQgdXAgdG8gdGhlIGN1cnJlbnQgcm91bmRcbiAgICogQHByb3Age3N0cmluZ30gcGVuZGluZ1N0YWtlIC0gdGhlIGFtb3VudCBvZiB0b2tlbiB0aGUgZGVsZWdhdG9yIGhhcyBlYXJuZWQgdXAgdG8gdGhlIGN1cnJlbnQgcm91bmRcbiAgICogQHByb3Age3N0cmluZ30gc3RhcnRSb3VuZCAtIHRoZSByb3VuZCB0aGUgZGVsZWdhdG9yIGJlY29tZXMgYm9uZGVkIGFuZCBkZWxlZ2F0ZWQgdG8gaXRzIGRlbGVnYXRlXG4gICAqIEBwcm9wIHtzdHJpbmd9IHN0YXR1cyAtIHRoZSBkZWxlZ2F0b3IncyBzdGF0dXNcbiAgICogQHByb3Age3N0cmluZ30gd2l0aGRyYXdhYmxlQW1vdW50IC0gdGhlIGFtb3VudCBvZiBMUFRVIGEgZGVsZWdhdG9yIGNhbiB3aXRoZHJhd1xuICAgKiBAcHJvcCB7c3RyaW5nfSB3aXRoZHJhd1JvdW5kIC0gdGhlIHJvdW5kIHRoZSBkZWxlZ2F0b3IgY2FuIHdpdGhkcmF3IGl0cyBzdGFrZVxuICAgKiBAcHJvcCB7c3RyaW5nfSBuZXh0VW5ib25kaW5nTG9ja0lkIC0gdGhlIG5leHQgdW5ib25kaW5nIGxvY2sgSUQgZm9yIHRoZSBkZWxlZ2F0b3JcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgVHJhbnNjb2RlciBzdHJ1Y3RcbiAgICogQHR5cGVkZWYge09iamVjdH0gVHJhbnNjb2RlclxuICAgKiBAcHJvcCB7Ym9vbGVhbn0gYWN0aXZlIC0gd2hldGhlciBvciBub3QgdGhlIHRyYW5zY29kZXIgaXMgYWN0aXZlXG4gICAqIEBwcm9wIHtzdHJpbmd9IGFkZHJlc3MgLSB0aGUgdHJhbnNjb2RlcidzIEVUSCBhZGRyZXNzXG4gICAqIEBwcm9wIHtzdHJpbmd9IHJld2FyZEN1dCAtICUgb2YgYmxvY2sgcmV3YXJkIGN1dCBwYWlkIHRvIHRyYW5zY29kZXIgYnkgYSBkZWxlZ2F0b3JcbiAgICogQHByb3Age3N0cmluZ30gZmVlU2hhcmUgLSAlIG9mIGZlZXMgcGFpZCB0byBkZWxlZ2F0b3JzIGJ5IHRyYW5zY29kZXJcbiAgICogQHByb3Age3N0cmluZ30gbGFzdFJld2FyZFJvdW5kIC0gbGFzdCByb3VuZCB0aGF0IHRoZSB0cmFuc2NvZGVyIGNhbGxlZCByZXdhcmRcbiAgICogQHByb3Age3N0cmluZ30gcGVuZGluZ1Jld2FyZEN1dCAtIHBlbmRpbmcgYmxvY2sgcmV3YXJkIGN1dCBmb3IgbmV4dCByb3VuZCBpZiB0aGUgdHJhbnNjb2RlciBpcyBhY3RpdmVcbiAgICogQHByb3Age3N0cmluZ30gcGVuZGluZ0ZlZVNoYXJlIC0gcGVuZGluZyBmZWUgc2hhcmUgZm9yIG5leHQgcm91bmQgaWYgdGhlIHRyYW5zY29kZXIgaXMgYWN0aXZlXG4gICAqIEBwcm9wIHtzdHJpbmd9IHBlbmRpbmdQcmljZVBlclNlZ21lbnQgLSBwZW5kaW5nIHByaWNlIHBlciBzZWdtZW50IGZvciBuZXh0IHJvdW5kIGlmIHRoZSB0cmFuc2NvZGVyIGlzIGFjdGl2ZVxuICAgKiBAcHJvcCB7c3RyaW5nfSBwcmljZVBlclNlZ21lbnQgLSBwcmljZSBwZXIgc2VnbWVudCBmb3IgYSBzdHJlYW0gKExQVFUpXG4gICAqIEBwcm9wIHtzdHJpbmd9IHN0YXR1cyAtIHRoZSB0cmFuc2NvZGVyJ3Mgc3RhdHVzXG4gICAqIEBwcm9wIHtzdHJpbmd9IHRvdGFsU3Rha2UgLSB0b3RhbCB0b2tlbnMgZGVsZWdhdGVkIHRvd2FyZCBhIHRyYW5zY29kZXIgKGluY2x1ZGluZyB0aGVpciBvd24pXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBVbmJvbmRpbmdMb2NrIHN0cnVjdFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmJvbmRpbmdMb2NrXG4gICAqIEBwcm9wIHtzdHJpbmd9IGlkIC0gdGhlIHVuYm9uZGluZyBsb2NrIElEXG4gICAqIEBwcm9wIHtzdHJpbmd9IGRlbGVnYXRvciAtIHRoZSBkZWxlZ2F0b3IncyBFVEggYWRkcmVzc1xuICAgKiBAcHJvcCB7c3RyaW5nfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIHRva2VucyBiZWluZyB1bmJvbmRlZFxuICAgKiBAcHJvcCB7c3RyaW5nfSB3aXRoZHJhd1JvdW5kIC0gdGhlIHJvdW5kIGF0IHdoaWNoIHVuYm9uZGluZyBwZXJpb2QgaXMgb3ZlciBhbmQgdG9rZW5zIGNhbiBiZSB3aXRoZHJhd25cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHJvdW5kXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFJvdW5kSW5mb1xuICAgKiBAcHJvcCB7c3RyaW5nfSBpZCAtIHRoZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgcm91bmRcbiAgICogQHByb3Age2Jvb2xlYW59IGluaXRpYWxpemVkIC0gd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgcm91bmQgaXMgaW5pdGlhbGl6ZWRcbiAgICogQHByb3Age3N0cmluZ30gc3RhcnRCbG9jayAtIHRoZSBzdGFydCBibG9jayBvZiB0aGUgY3VycmVudCByb3VuZFxuICAgKiBAcHJvcCB7c3RyaW5nfSBsYXN0SW5pdGlhbGl6ZWRSb3VuZCAtIHRoZSBsYXN0IHJvdW5kIHRoYXQgd2FzIGluaXRpYWxpemVkIHByaW9yIHRvIHRoZSBjdXJyZW50XG4gICAqIEBwcm9wIHtzdHJpbmd9IGxlbmd0aCAtIHRoZSBsZW5ndGggb2Ygcm91bmRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCBhbiBFdGhlcmV1bSBibG9ja1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBCbG9ja1xuICAgKiBAcHJvcCB7c3RyaW5nfSBudW1iZXIgLSBibG9jayBudW1iZXJcbiAgICogQHByb3Age3N0cmluZ30gaGFzaCAtIGJsb2NrIGhhc2hcbiAgICogQHByb3Age3N0cmluZ30gcGFyZW50SGFzaCAtIHBhcmVudCBoYXMgb2YgdGhlIGJsb2NrXG4gICAqIEBwcm9wIHtzdHJpbmd9IG5vbmNlIC0gYmxvY2sgbm9uY2VcbiAgICogQHByb3Age3N0cmluZ30gc2hhM1VuY2xlcyAtIGJsb2NrIHNoYTMgdW5jbGVzXG4gICAqIEBwcm9wIHtzdHJpbmd9IGxvZ3NCbG9vbSAtIGxvZ3NzIGJsb29tIGZvciB0aGUgYmxvY2tcbiAgICogQHByb3Age3N0cmluZ30gdHJhbnNhY3Rpb25zUm9vdCAtIGJsb2NrIHRyYW5zYWN0aW9uIHJvb3QgaGFzaFxuICAgKiBAcHJvcCB7c3RyaW5nfSBzdGF0ZVJvb3QgLSBibG9jayBzdGF0ZSByb290IGhhc2hcbiAgICogQHByb3Age3N0cmluZ30gcmVjZWlwdHNSb290IC0gYmxvY2sgcmVjZWlwdHMgcm9vdCBoYXNoXG4gICAqIEBwcm9wIHtzdHJpbmd9IG1pbmVyIC0gYmxvY2sgbWluZXIgaGFzaFxuICAgKiBAcHJvcCB7c3RyaW5nfSBtaXhIYXNoIC0gYmxvY2sgbWl4SGFzaFxuICAgKiBAcHJvcCB7c3RyaW5nfSBkaWZmaWN1bHR5IC0gZGlmZmljdWx0eSBpbnRcbiAgICogQHByb3Age3N0cmluZ30gdG90YWxEaWZmaWN1bHR5IC0gdG90YWwgZGlmZmljdWx0eSBpbnRcbiAgICogQHByb3Age3N0cmluZ30gZXh0cmFEYXRhIC0gaGFzaCBvZiBleHRyYSBkYXRhXG4gICAqIEBwcm9wIHtzdHJpbmd9IHNpemUgLSBibG9jayBzaXplXG4gICAqIEBwcm9wIHtzdHJpbmd9IGdhc0xpbWl0IC0gYmxvY2sgZ2FzIGxpbWl0XG4gICAqIEBwcm9wIHtzdHJpbmd9IGdhc1VzZWQgLSBnYXMgdXNlZCBpbiBibG9ja1xuICAgKiBAcHJvcCB7bnVtYmVyfSB0aW1lc3RhbXAgLSBibG9jayB0aW1lc3RhbXBcbiAgICogQHByb3Age3N0cmluZ30gdHJhbnNhY3Rpb25zIC0gYmxvY2sgdHJhbnNhY3Rpb25zIGhhc2hcbiAgICogQHByb3Age3N0cmluZ30gdW5jbGVzIC0gYmxvY2sgdW5jbGVzIGhhc2hcbiAgICogQHByb3Age0FycmF5PFRyYW5zYWN0aW9uPn0gdHJhbnNhY3Rpb25zIC0gdHJhbnNhY3Rpb25zIGluIHRoZSBibG9ja1xuICAgKiBAcHJvcCB7c3RyaW5nfSB0cmFuc2FjdGlvbnNSb290IC0gcm9vdCB0cmFuc2FjdGlvbiBoYXNoXG4gICAqIEBwcm9wIHtBcnJheTxVbmNsZT59IHVuY2xlcyAtIGJsb2NrIHVuY2xlc1xuICAgKi9cblxuICAvKipcbiAgICogQSBQcm90b2NvbCBzdHJ1Y3RcbiAgICogQHR5cGVkZWYge09iamVjdH0gUHJvdG9jb2xcbiAgICogQHByb3Age2Jvb2xlYW59IHBhdXNlZCAtIHRoZSBwcm90b2NvbCBwYXVzZWQgb3Igbm90XG4gICAqIEBwcm9wIHtzdHJpbmd9IHRvdGFsVG9rZW5TdXBwbHkgLSB0b3RhbCB0b2tlbiBzdXBwbHkgZm9yIHByb3RvY29sXG4gICAqIEBwcm9wIHtzdHJpbmd9IHRvdGFsQm9uZGVkVG9rZW4gLSB0b3RhbCBib25kZWQgdG9rZW4gZm9yIHByb3RvY29sXG4gICAqIEBwcm9wIHtzdHJpbmd9IHRhcmdldEJvbmRpbmdSYXRlIC0gdGFyZ2V0IGJvbmRpbmcgcmF0ZSBmb3IgcHJvdG9jb2xcbiAgICogQHByb3Age3N0cmluZ30gdHJhbnNjb2RlclBvb2xNYXhTaXplIC0gdHJhbnNjb2RlciBwb29sIG1heCBzaXplXG4gICAqL1xufVxuXG5leHBvcnQgeyBjcmVhdGVMaXZlcGVlclNESyBhcyBMaXZlcGVlclNESywgY3JlYXRlTGl2ZXBlZXJTREsgYXMgZGVmYXVsdCB9XG4iXX0=